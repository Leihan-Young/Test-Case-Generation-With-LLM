[
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Garbage collection for variable and function definitions. Basically performs\n * a mark-and-sweep type algorithm over the JavaScript parse tree.\n *\n * For each scope:\n * (1) Scan the variable/function declarations at that scope.\n * (2) Traverse the scope for references, marking all referenced variables.\n *     Unlike other compiler passes, this is a pre-order traversal, not a\n *     post-order traversal.\n * (3) If the traversal encounters an assign without other side-effects,\n *     create a continuation. Continue the continuation iff the assigned\n *     variable is referenced.\n * (4) When the traversal completes, remove all unreferenced variables.\n *\n * If it makes it easier, you can think of the continuations of the traversal\n * as a reference graph. Each continuation represents a set of edges, where the\n * source node is a known variable, and the destination nodes are lazily\n * evaluated when the continuation is executed.\n *\n * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n * between global symbols. However, {@code SmartNameRemoval} cannot handle\n * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n * substantially more complicated because it tries to handle namespaces\n * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n *\n * This pass also uses a more complex analysis of assignments, where\n * an assignment to a variable or a property of that variable does not\n * necessarily count as a reference to that variable, unless we can prove\n * that it modifies external state. This is similar to\n * {@code FlowSensitiveInlineVariables}, except that it works for variables\n * used across scopes.\n *\n */\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final boolean removeGlobals;\n  private boolean preserveFunctionExpressionNames;\n  private final Set<Var> referenced = Sets.newHashSet();\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n  private boolean modifyCallSites;\n  private CallSiteOptimizer callSiteOptimizer;\n  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Garbage collection for variable and function definitions. Basically performs\n * a mark-and-sweep type algorithm over the JavaScript parse tree.\n *\n * For each scope:\n * (1) Scan the variable/function declarations at that scope.\n * (2) Traverse the scope for references, marking all referenced variables.\n *     Unlike other compiler passes, this is a pre-order traversal, not a\n *     post-order traversal.\n * (3) If the traversal encounters an assign without other side-effects,\n *     create a continuation. Continue the continuation iff the assigned\n *     variable is referenced.\n * (4) When the traversal completes, remove all unreferenced variables.\n *\n * If it makes it easier, you can think of the continuations of the traversal\n * as a reference graph. Each continuation represents a set of edges, where the\n * source node is a known variable, and the destination nodes are lazily\n * evaluated when the continuation is executed.\n *\n * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n * between global symbols. However, {@code SmartNameRemoval} cannot handle\n * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n * substantially more complicated because it tries to handle namespaces\n * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n *\n * This pass also uses a more complex analysis of assignments, where\n * an assignment to a variable or a property of that variable does not\n * necessarily count as a reference to that variable, unless we can prove\n * that it modifies external state. This is similar to\n * {@code FlowSensitiveInlineVariables}, except that it works for variables\n * used across scopes.\n *\n */\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final boolean removeGlobals;\n  private boolean preserveFunctionExpressionNames;\n  private final Set<Var> referenced = Sets.newHashSet();\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n  private boolean modifyCallSites;\n  private CallSiteOptimizer callSiteOptimizer;\n  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? (\":m\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? \":m0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(new String(errReader.toByteArray()), runner.shouldRunCompiler());\n    Supplier<List<SourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<SourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<SourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  private void setFilename(int i, String filename) {\n    this.filenames.put(i, filename);\n  }\n  private String getFilename(int i) {\n    if (filenames.isEmpty()) {\n      return \"input\" + i;\n    }\n    return filenames.get(i);\n  }\n  public void testSimpleModeLeavesUnusedParams() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    testSame(\"window.f = function(a) {};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains generally useful AST utilities.\n *\n */\npublic final class NodeUtil {\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains generally useful AST utilities.\n *\n */\npublic final class NodeUtil {\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);  // TODO: why is nothing done with this?\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        ImmutableList.<SourceFile>of(),\n        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testIssue821() {\n    foldSame(\"var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;\");\n    foldSame(\"var a = ((Math.random() ? 0 : 1) ||\" +\n             \"(Math.random()>0.5? '1' : 2 )) + 3 + 4;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n  private boolean shouldReportThis(Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n  private boolean shouldReportThis(Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFailure(String js) {\n    test(js, null, CheckGlobalThis.GLOBAL_THIS);\n  }\n  public void testStaticFunction6() {\n    testSame(\"function a() { return function() { this = 8; } }\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) throws CmdLineException {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     try {\n *       (new MyCommandLineRunner(args)).run();\n *     } catch (CmdLineException e) {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) throws CmdLineException {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     try {\n *       (new MyCommandLineRunner(args)).run();\n *     } catch (CmdLineException e) {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n  }\n  private Compiler compile(String original) {\n    return compile( new String[] { original });\n  }\n  private Compiler compile(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = null;\n    try {\n      runner = new CommandLineRunner(argStrings);\n    } catch (CmdLineException e) {\n      throw new RuntimeException(e);\n    }\n    Compiler compiler = runner.createCompiler();\n    lastCompiler = compiler;\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    CompilerOptions options = runner.createOptions();\n    try {\n      runner.setRunOptions(options);\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n      fail(\"Unexpected exception \" + e);\n    } catch (IOException e) {\n      assert(false);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = null;\n    try {\n      runner = new CommandLineRunner(argStrings);\n    } catch (CmdLineException e) {\n      throw new RuntimeException(e);\n    }\n    Compiler compiler = runner.createCompiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testProcessClosurePrimitives() {\n    test(\"var goog = {}; goog.provide('goog.dom');\",\n         \"var goog = {}; goog.dom = {};\");\n    args.add(\"--process_closure_primitives=false\");\n    testSame(\"var goog = {}; goog.provide('goog.dom');\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Splits var statements contains multiple declarations into individual\n * statements.\n * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n * not all such statements can be broken up, for instance:\n *   \"a[next()] = a[next()] = 0\"\n * can not be made into\n *   \"a[next()] = 0; a[next()] = a[next()];\n * 3) init expressions in FOR statements are extracted and placed before the\n * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n * 4) WHILE statements are converted to FOR statements. For example:\n * \"while(true);\" becomes \"for(;true;);\"\n * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n *   inlining.\n *\n*\n */\nclass Normalize implements CompilerPass, Callback {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  private void reportCodeChange(String changeDescription);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Splits var statements contains multiple declarations into individual\n * statements.\n * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n * not all such statements can be broken up, for instance:\n *   \"a[next()] = a[next()] = 0\"\n * can not be made into\n *   \"a[next()] = 0; a[next()] = a[next()];\n * 3) init expressions in FOR statements are extracted and placed before the\n * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n * 4) WHILE statements are converted to FOR statements. For example:\n * \"while(true);\" becomes \"for(;true;);\"\n * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n *   inlining.\n *\n*\n */\nclass Normalize implements CompilerPass, Callback {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  private void reportCodeChange(String changeDescription);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n  }\n  private Compiler compile(String original) {\n    return compile( new String[] { original });\n  }\n  private Compiler compile(String[] original) {\n    CompilerRunner runner = new CompilerRunner(new String[] {});\n    Compiler compiler = runner.createCompiler();\n    lastCompiler = compiler;\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    CompilerOptions options = runner.createOptions();\n    try {\n      runner.setRunOptions(options);\n    } catch (AbstractCompilerRunner.FlagUsageException e) {\n      fail(\"Unexpected exception \" + e);\n    } catch (IOException e) {\n      assert(false);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original) {\n    CompilerRunner runner = new CompilerRunner(new String[] {});\n    Compiler compiler = runner.createCompiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testIssue115() {\n    CompilerRunner.FLAG_compilation_level.setForTest(\n        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n    CompilerRunner.FLAG_warning_level.setForTest(\n        WarningLevel.VERBOSE);\n    test(\"function f() { \" +\n         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\",\n         \"function f() { \" +\n         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * DisambiguateProperties renames properties to disambiguate between unrelated\n * fields with the same name. Two properties are considered related if they\n * share a definition on their prototype chains, or if they are potentially\n * referenced together via union types.\n *\n * <p> Renamimg only occurs if there are two or more distinct properties with\n * the same name.\n *\n * <p> This pass allows other passes, such as inlining and code removal to take\n * advantage of type information implicitly.\n *\n * <pre>\n *   Foo.a;\n *   Bar.a;\n * </pre>\n *\n * <p> will become\n *\n * <pre>\n *   Foo.a$Foo;\n *   Bar.a$Bar;\n * </pre>\n *\n*\n */\nclass DisambiguateProperties<T> implements CompilerPass {\n  private final boolean showInvalidationWarnings = false;\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n}\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n*\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private Map<Node, Integer> astPosition;\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  private static boolean mayThrowException(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * DisambiguateProperties renames properties to disambiguate between unrelated\n * fields with the same name. Two properties are considered related if they\n * share a definition on their prototype chains, or if they are potentially\n * referenced together via union types.\n *\n * <p> Renamimg only occurs if there are two or more distinct properties with\n * the same name.\n *\n * <p> This pass allows other passes, such as inlining and code removal to take\n * advantage of type information implicitly.\n *\n * <pre>\n *   Foo.a;\n *   Bar.a;\n * </pre>\n *\n * <p> will become\n *\n * <pre>\n *   Foo.a$Foo;\n *   Bar.a$Bar;\n * </pre>\n *\n*\n */\nclass DisambiguateProperties<T> implements CompilerPass {\n  private final boolean showInvalidationWarnings = false;\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n}\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n*\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private Map<Node, Integer> astPosition;\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  private static boolean mayThrowException(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertUnreachable(String js) {\n    test(js, js, CheckUnreachableCode.UNREACHABLE_CODE);\n  }\n  public void testInstanceOfThrowsException() {\n    testSame(\"function f() {try { if (value instanceof type) return true; } \" +\n             \"catch (e) { }}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The {@code UnionType} implements a common JavaScript idiom in which the\n * code is specifically designed to work with multiple input types.  Because\n * JavaScript always knows the runtime type of an object value, this is safer\n * than a C union.<p>\n *\n * For instance, values of the union type {@code (String,boolean)} can be of\n * type {@code String} or of type {@code boolean}. The commutativity of the\n * statement is captured by making {@code (String,boolean)} and\n * {@code (boolean,String)} equal.<p>\n *\n * The implementation of this class prevents the creation of nested\n * unions.<p>\n */\npublic class UnionType extends JSType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean canAssignTo(JSType that);\n  JSType meet(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The {@code UnionType} implements a common JavaScript idiom in which the\n * code is specifically designed to work with multiple input types.  Because\n * JavaScript always knows the runtime type of an object value, this is safer\n * than a C union.<p>\n *\n * For instance, values of the union type {@code (String,boolean)} can be of\n * type {@code String} or of type {@code boolean}. The commutativity of the\n * statement is captured by making {@code (String,boolean)} and\n * {@code (boolean,String)} equal.<p>\n *\n * The implementation of this class prevents the creation of nested\n * unions.<p>\n */\npublic class UnionType extends JSType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean canAssignTo(JSType that);\n  JSType meet(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertTypeCanAssignToItself(JSType type) {\n    assertTrue(type.canAssignTo(type));\n  }\n  public void testGreatestSubtypeUnionTypes5() throws Exception {\n    JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n    assertEquals(NO_OBJECT_TYPE, errUnion.getGreatestSubtype(STRING_OBJECT_TYPE));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * FoldConstants simplifies expressions which consist only of constants,\n * e.g (1 + 2).\n *\n*\n*\n */\nclass FoldConstants extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private final AbstractCompiler compiler;\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * FoldConstants simplifies expressions which consist only of constants,\n * e.g (1 + 2).\n *\n*\n*\n */\nclass FoldConstants extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private final AbstractCompiler compiler;\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\", \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\", \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\", \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n\n    // Works with numbers\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n    // Works on boolean\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n    // Only optimize if it's a size win.\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n    \n    // TODO(user): Its possible to fold this better.\n    foldSame(\"x = ['', foo].join(',')\");\n    foldSame(\"x = ['', foo, ''].join(',')\");\n    \n    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n         \"x = [',', foo, ','].join(',')\");\n    \n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n         \"x = [',', foo, ',', bar].join(',')\");\n    \n    fold(\"x = [1,2,3].join('abcdef')\",\n         \"x = '1abcdef2abcdef3'\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n*\n*\n*\n */\nclass GlobalNamespace {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n/**\n * A builder for {@link JSDocInfo} objects. This builder abstracts the\n * construction process of {@link JSDocInfo} objects whilst minimizing the\n * number of instances of {@link JSDocInfo} objects. It provides early\n * incompatibility detection among properties stored on the {@code JSDocInfo}\n * object being created.\n *\n*\n */\nfinal public class JSDocInfoBuilder {\n  private JSDocInfo currentInfo;\n  private boolean populated = false;\n  private boolean parseDocumentation = false;\n  private JSDocInfo.Marker currentMarker = null;\n  /**\n   * Adds a name declaration to the current marker.\n   */\n  public void markName(String name, int lineno, int charno);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n*\n*\n*\n */\nclass GlobalNamespace {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n/**\n * A builder for {@link JSDocInfo} objects. This builder abstracts the\n * construction process of {@link JSDocInfo} objects whilst minimizing the\n * number of instances of {@link JSDocInfo} objects. It provides early\n * incompatibility detection among properties stored on the {@code JSDocInfo}\n * object being created.\n *\n*\n */\nfinal public class JSDocInfoBuilder {\n  private JSDocInfo currentInfo;\n  private boolean populated = false;\n  private boolean parseDocumentation = false;\n  private JSDocInfo.Marker currentMarker = null;\n  /**\n   * Adds a name declaration to the current marker.\n   */\n  public void markName(String name, int lineno, int charno);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testJSDocComments() {\n    test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n    test(\"function A() { /* This is a normal comment */ this.foo; }\", e);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class\n * directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n *\n * This class is totally not thread-safe.\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class\n * directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n *\n * This class is totally not thread-safe.\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? (\":m\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? \":m0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(new String(errReader.toByteArray()), runner.shouldRunCompiler());\n    Supplier<List<SourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<SourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<SourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  private void setFilename(int i, String filename) {\n    this.filenames.put(i, filename);\n  }\n  private String getFilename(int i) {\n    if (filenames.isEmpty()) {\n      return \"input\" + i;\n    }\n    return filenames.get(i);\n  }\n  public void testGetMsgWiringNoWarnings() throws Exception {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"/** @desc A bad foo. */ var MSG_FOO = 1;\", \"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testScoped(String code, String expected) {\n    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n  }\n  private void testScopedNoChanges(String aliases, String code) {\n    testScoped(aliases + code, code);\n  }\n  private void testTypes(String aliases, String code) {\n    testScopedNoChanges(aliases, code);\n    verifyTypes();\n  }\n  private void verifyTypes() {\n    Compiler lastCompiler = getLastCompiler();\n    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n        lastCompiler.jsRoot);\n  }\n  private void testFailure(String code, DiagnosticType expectedError) {\n    test(code, null, expectedError);\n  }\n  private void testScopedFailure(String code, DiagnosticType expectedError) {\n    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n  }\n  private void verifyAliasTransformationPosition(int startLine, int startChar,\n      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n    assertEquals(startLine, pos.getStartLine());\n    assertEquals(startChar, pos.getPositionOnStartLine());\n    assertTrue(\n        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n        pos.getEndLine() >= endLine);\n    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n  }\n  public void testIssue1144() {\n    test(\"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"goog.scope(function () {\" +\n         \"  var sub = ns.sub;\" +\n         \"  /** @type {sub.C} */\" +\n         \"  var x = null;\" +\n         \"});\",\n         SCOPE_NAMESPACE +\n         \"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"$jscomp.scope.x = null;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private JSType testParseType(String type) throws Exception {\n    return testParseType(type, type);\n  }\n  private JSType testParseType(\n      String type, String typeExpected) throws Exception {\n    JSDocInfo info = parse(\"@type {\" + type + \"}*/\");\n\n    assertNotNull(info);\n    assertTrue(info.hasType());\n\n    JSType actual = resolve(info.getType());\n    assertEquals(typeExpected, actual.toString());\n    return actual;\n  }\n  private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker,\n                                                       String description,\n                                                       int startCharno,\n                                                       int endLineno,\n                                                       int endCharno) {\n    assertTrue(marker.getDescription() != null);\n    assertEquals(description, marker.getDescription().getItem());\n\n    // Match positional information.\n    assertEquals(marker.getAnnotation().getStartLine(),\n                 marker.getDescription().getStartLine());\n    assertEquals(startCharno, marker.getDescription().getPositionOnStartLine());\n    assertEquals(endLineno, marker.getDescription().getEndLine());\n    assertEquals(endCharno, marker.getDescription().getPositionOnEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertTypeInMarker(\n      JSDocInfo.Marker marker, String typeName,\n      int startLineno, int startCharno, int endLineno, int endCharno,\n      boolean hasBrackets) {\n\n    assertTrue(marker.getType() != null);\n    assertTrue(marker.getType().getItem().isString());\n\n    // Match the name and brackets information.\n    String foundName = marker.getType().getItem().getString();\n\n    assertEquals(typeName, foundName);\n    assertEquals(hasBrackets, marker.getType().hasBrackets());\n\n    // Match position information.\n    assertEquals(startCharno, marker.getType().getPositionOnStartLine());\n    assertEquals(endCharno, marker.getType().getPositionOnEndLine());\n    assertEquals(startLineno, marker.getType().getStartLine());\n    assertEquals(endLineno, marker.getType().getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n      String name, int startLine, int startCharno) {\n    assertTrue(marker.getName() != null);\n    assertEquals(name, marker.getName().getItem());\n\n    assertEquals(startCharno, marker.getName().getPositionOnStartLine());\n    assertEquals(startCharno + name.length(),\n                 marker.getName().getPositionOnEndLine());\n\n    assertEquals(startLine, marker.getName().getStartLine());\n    assertEquals(startLine, marker.getName().getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno) {\n    return assertAnnotationMarker(jsdoc, annotationName, startLineno,\n                                  startCharno, 0);\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno,\n                                                  int index) {\n\n    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();\n\n    assertTrue(markers.size() > 0);\n\n    int counter = 0;\n\n    for (JSDocInfo.Marker marker : markers) {\n      if (marker.getAnnotation() != null) {\n        if (annotationName.equals(marker.getAnnotation().getItem())) {\n\n          if (counter == index) {\n            assertEquals(startLineno, marker.getAnnotation().getStartLine());\n            assertEquals(startCharno,\n                         marker.getAnnotation().getPositionOnStartLine());\n            assertEquals(startLineno, marker.getAnnotation().getEndLine());\n            assertEquals(startCharno + annotationName.length(),\n                         marker.getAnnotation().getPositionOnEndLine());\n\n            return marker;\n          }\n\n          counter++;\n        }\n      }\n    }\n\n    fail(\"No marker found\");\n    return null;\n  }\n  private <T> void assertContains(Collection<T> collection, T item) {\n    assertTrue(collection.contains(item));\n  }\n  private List<JSDocInfo> parseFull(String code, String... warnings) {\n    CompilerEnvirons environment = new CompilerEnvirons();\n\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    environment.setErrorReporter(testErrorReporter);\n\n    environment.setRecordingComments(true);\n    environment.setRecordingLocalJsDocComments(true);\n\n    Parser p = new Parser(environment, testErrorReporter);\n    AstRoot script = p.parse(code, null, 0);\n\n    Config config =\n        new Config(extraAnnotations, extraSuppressions,\n            true, LanguageMode.ECMASCRIPT3, false);\n\n    List<JSDocInfo> jsdocs = Lists.newArrayList();\n    for (Comment comment : script.getComments()) {\n      JsDocInfoParser jsdocParser =\n        new JsDocInfoParser(\n            new JsDocTokenStream(comment.getValue().substring(3),\n                comment.getLineno()),\n            comment,\n            null,\n            config,\n            testErrorReporter);\n      jsdocParser.parse();\n      jsdocs.add(jsdocParser.retrieveAndResetParsedJSDocInfo());\n    }\n\n    assertTrue(\"some expected warnings were not reported\",\n        testErrorReporter.hasEncounteredAllWarnings());\n    return jsdocs;\n  }\n  private JSDocInfo parseFileOverviewWithoutDoc(String comment,\n                                                String... warnings) {\n    return parse(comment, false, true, warnings);\n  }\n  private JSDocInfo parseFileOverview(String comment, String... warnings) {\n    return parse(comment, true, true, warnings);\n  }\n  private JSDocInfo parse(String comment, String... warnings) {\n    return parse(comment, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n                          String... warnings) {\n    return parse(comment, parseDocumentation, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n      boolean parseFileOverview, String... warnings) {\n    TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n\n    Config config = new Config(extraAnnotations, extraSuppressions,\n        parseDocumentation, LanguageMode.ECMASCRIPT3, false);\n    StaticSourceFile file = new SimpleSourceFile(\"testcode\", false);\n    Node associatedNode = new Node(Token.SCRIPT);\n    associatedNode.setInputId(new InputId(file.getName()));\n    associatedNode.setStaticSourceFile(file);\n    JsDocInfoParser jsdocParser = new JsDocInfoParser(\n        stream(comment),\n        new Comment(0, 0, CommentType.JSDOC, comment),\n        associatedNode,\n        config, errorReporter);\n\n    if (fileLevelJsDocBuilder != null) {\n      jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    }\n\n    jsdocParser.parse();\n\n    assertTrue(\"expected warnings were not reported\",\n        errorReporter.hasEncounteredAllWarnings());\n\n    if (parseFileOverview) {\n      return jsdocParser.getFileOverviewJSDocInfo();\n    } else {\n      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n  }\n  private Node parseType(String typeComment) {\n    return JsDocInfoParser.parseTypeString(typeComment);\n  }\n  private JsDocTokenStream stream(String source) {\n    return new JsDocTokenStream(source, 0);\n  }\n  private void assertTemplatizedTypeEquals(TemplateType key, JSType expected,\n                                           JSTypeExpression te) {\n    assertEquals(\n        expected, resolve(te).getTemplateTypeMap().getTemplateType(key));\n  }\n  public void testStructuralConstructor2() throws Exception {\n    JSType type = testParseType(\n        \"function (new:?)\",\n        // toString skips unknowns, but isConstructor reveals the truth.\n        \"function (): ?\");\n    assertTrue(type.isConstructor());\n    assertFalse(type.isNominalConstructor());\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testGetprop4() throws Exception {\n    testTypes(\"var x = null; x.prop = 3;\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class implements the root of the intermediate representation.\n *\n */\npublic class Node implements Cloneable, Serializable {\n  private static final long serialVersionUID = 1L;\n  public Node getChildBefore(Node child);\n}\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class implements the root of the intermediate representation.\n *\n */\npublic class Node implements Cloneable, Serializable {\n  private static final long serialVersionUID = 1L;\n  public Node getChildBefore(Node child);\n}\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testScoped(String code, String expected) {\n    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n  }\n  private void testScopedNoChanges(String aliases, String code) {\n    testScoped(aliases + code, code);\n  }\n  private void testTypes(String aliases, String code) {\n    testScopedNoChanges(aliases, code);\n    verifyTypes();\n  }\n  private void verifyTypes() {\n    Compiler lastCompiler = getLastCompiler();\n    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n        lastCompiler.jsRoot);\n  }\n  private void testFailure(String code, DiagnosticType expectedError) {\n    test(code, null, expectedError);\n  }\n  private void testScopedFailure(String code, DiagnosticType expectedError) {\n    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n  }\n  private void verifyAliasTransformationPosition(int startLine, int startChar,\n      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n    assertEquals(startLine, pos.getStartLine());\n    assertEquals(startChar, pos.getPositionOnStartLine());\n    assertTrue(\n        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n        pos.getEndLine() >= endLine);\n    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n  }\n  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A reverse abstract interpreter (RAI) for specific closure patterns such as\n * {@code goog.isDef}.\n *\n */\npublic class ClosureReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A reverse abstract interpreter (RAI) for specific closure patterns such as\n * {@code goog.isDef}.\n *\n */\npublic class ClosureReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    CompilerTypeTestCase {\n  private void testClosureFunction(String function, JSType type,\n      JSType trueType, JSType falseType) {\n    // function(a) where a : type\n    Node n = compiler.parseTestCode(\"var a; \" + function + \"(a)\");\n    Node call = n.getLastChild().getLastChild();\n    Node name = call.getLastChild();\n\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null);\n    FlowScope flowScope = LinkedFlowScope.createEntryLattice(scope);\n\n    assertEquals(Token.CALL, call.getType());\n    assertEquals(Token.NAME, name.getType());\n\n    GoogleCodingConvention convention = new GoogleCodingConvention();\n    flowScope.inferSlotType(\"a\", type);\n    ClosureReverseAbstractInterpreter rai =\n        new ClosureReverseAbstractInterpreter(convention, registry);\n\n    // trueScope\n    Asserts.assertTypeEquals(\n        trueType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, true)\n        .getSlot(\"a\").getType());\n\n    // falseScope\n    Asserts.assertTypeEquals(\n        falseType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, false)\n        .getSlot(\"a\").getType());\n  }\n  public void testGoogIsArray2() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        ALL_TYPE,\n        ARRAY_TYPE,\n        ALL_TYPE);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1058() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \"  * @constructor\\n\" +\n        \"  * @template CLASS\\n\" +\n        \"  */\\n\" +\n        \"var Class = function() {};\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \"  * @param {function(CLASS):CLASS} a\\n\" +\n        \"  * @template T\\n\" +\n        \"  */\\n\" +\n        \"Class.prototype.foo = function(a) {\\n\" +\n        \"  return 'string';\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"/** @param {number} a\\n\" +\n        \"  * @return {string} */\\n\" +\n        \"var a = function(a) { return '' };\\n\" +\n        \"\\n\" +\n        \"new Class().foo(a);\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Replaces goog.provide calls, removes goog.require calls, verifies that\n * goog.require has a corresponding goog.provide and some closure specific\n * simplifications.\n *\n */\nclass ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final List<Node> defineCalls = Lists.newArrayList();\n  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Replaces goog.provide calls, removes goog.require calls, verifies that\n * goog.require has a corresponding goog.provide and some closure specific\n * simplifications.\n *\n */\nclass ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final List<Node> defineCalls = Lists.newArrayList();\n  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testDependentModules(String code1, String code2,\n                                    DiagnosticType error) {\n    testDependentModules(code1, code2, error, null);\n  }\n  private void testDependentModules(String code1, String code2,\n                                    DiagnosticType error,\n                                    DiagnosticType warning) {\n    testTwoModules(code1, code2, true, error, warning);\n  }\n  private void testIndependentModules(String code1, String code2,\n                                      DiagnosticType error,\n                                      DiagnosticType warning) {\n    testTwoModules(code1, code2, false, error, warning);\n  }\n  private void testTwoModules(String code1, String code2, boolean m2DependsOnm1,\n                              DiagnosticType error, DiagnosticType warning) {\n    JSModule m1 = new JSModule(\"m1\");\n    m1.add(SourceFile.fromCode(\"input1\", code1));\n    JSModule m2 = new JSModule(\"m2\");\n    m2.add(SourceFile.fromCode(\"input2\", code2));\n    if (m2DependsOnm1) {\n      m2.addDependency(m1);\n    }\n    test(new JSModule[] { m1, m2 },\n         new String[] { code1, code2 }, error, warning);\n  }\n  public void testNoUndeclaredVarWhenUsingClosurePass() {\n    enableClosurePass();\n    // We don't want to get goog as an undeclared var here.\n    test(\"goog.require('namespace.Class1');\\n\", null,\n        ProcessClosurePrimitives.MISSING_PROVIDE_ERROR);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code referenceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n  private static final String WINDOW = \"window\";\n  private static final String FUNCTION = \"Function\";\n  private final boolean removeUnreferenced;\n  private final Set<String> globalNames;\n  private final AstChangeProxy changeProxy;\n  private final Set<String> externalNames = Sets.newHashSet();\n  private final List<RefNode> refNodes = Lists.newArrayList();\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code referenceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n  private static final String WINDOW = \"window\";\n  private static final String FUNCTION = \"Function\";\n  private final boolean removeUnreferenced;\n  private final Set<String> globalNames;\n  private final AstChangeProxy changeProxy;\n  private final Set<String> externalNames = Sets.newHashSet();\n  private final List<RefNode> refNodes = Lists.newArrayList();\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testAssignWithCall() {\n    test(\"var fun, x; (fun = function(){ x; })();\",\n        \"var x; (function(){ x; })();\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testBug4944818() {\n    test(\n        \"var getDomServices_ = function(self) {\\n\" +\n        \"  if (!self.domServices_) {\\n\" +\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n        \"        self.appContext_);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return self.domServices_;\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"var getOwnerWin_ = function(self) {\\n\" +\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n        \"  var self = a.b;\\n\" +\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n        \"};\",\n        \"HangoutStarter.prototype.launchHangout = function() { \" +\n        \"  var self$$2 = a.b;\" +\n        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n        \"  var JSCompiler_inline_result$$1;\" +\n        \"  {\" +\n        \"  var self$$inline_2 = self$$2;\" +\n        \"  if (!self$$inline_2.domServices_) {\" +\n        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n        \"        self$$inline_2.appContext_);\" +\n        \"  }\" +\n        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n        \"  }\" +\n        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n        \"          getWindow().location.href)\" +\n        \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private FunctionInjector getInjector() {\n    Compiler compiler = new Compiler();\n    return new FunctionInjector(\n        compiler, compiler.getUniqueNameIdSupplier(), true,\n        assumeStrictThis, assumeMinimumCapture);\n  }\n  private void validateSourceInfo(Compiler compiler, Node subtree) {\n    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n    // Source information problems are reported as compiler errors.\n    if (compiler.getErrorCount() != 0) {\n      String msg = \"Error encountered: \";\n      for (JSError err : compiler.getErrors()) {\n        msg += err.toString() + \"\\n\";\n      }\n      assertTrue(msg, compiler.getErrorCount() == 0);\n    }\n  }\n  private static Node findFunction(Node n, String name) {\n    if (n.isFunction()) {\n      if (n.getFirstChild().getString().equals(name)) {\n        return n;\n      }\n    }\n\n    for (Node c : n.children()) {\n      Node result = findFunction(c, name);\n      if (result != null) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n  private static Node prep(String js) {\n    Compiler compiler = new Compiler();\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n.getFirstChild();\n  }\n  private static Node parse(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private static Node parseExpected(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    String message = \"Unexpected errors: \";\n    JSError[] errs = compiler.getErrors();\n    for (int i = 0; i < errs.length; i++){\n      message += \"\\n\" + errs[i].toString();\n    }\n    assertEquals(message, 0, compiler.getErrorCount());\n    return n;\n  }\n  private static String toSource(Node n) {\n    return new CodePrinter.Builder(n)\n        .setPrettyPrint(false)\n        .setLineBreak(false)\n        .setSourceMap(null)\n        .build();\n  }\n  public void testIssue1101a() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n        INLINE_DIRECT);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  /**\n   * Formats a found/required error message.\n   */\n  private String formatFoundRequired(String description, JSType found,\n      JSType required);\n  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  /**\n   * Formats a found/required error message.\n   */\n  private String formatFoundRequired(String description, JSType found,\n      JSType required);\n  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1047() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C2() {}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C3(c2) {\\n\" +\n        \"  /**\\n\" +\n        \"   * @type {C2} \\n\" +\n        \"   * @private\\n\" +\n        \"   */\\n\" +\n        \"  this.c2_;\\n\" +\n        \"\\n\" +\n        \"  var x = this.c2_.prop;\\n\" +\n        \"}\",\n        \"Property prop never defined on C2\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * DisambiguateProperties renames properties to disambiguate between unrelated\n * fields with the same name. Two properties are considered related if they\n * share a definition on their prototype chains, or if they are potentially\n * referenced together via union types.\n *\n * <p> Renamimg only occurs if there are two or more distinct properties with\n * the same name.\n *\n * <p> This pass allows other passes, such as inlining and code removal to take\n * advantage of type information implicitly.\n *\n * <pre>\n *   Foo.a;\n *   Bar.a;\n * </pre>\n *\n * <p> will become\n *\n * <pre>\n *   Foo.a$Foo;\n *   Bar.a$Bar;\n * </pre>\n *\n */\nclass DisambiguateProperties<T> implements CompilerPass {\n  private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;\n  /** Public for testing. */\n  T getTypeWithProperty(String field, T type);\n  /** Returns a map from field name to types for which it will be renamed. */\n  Multimap<String, Collection<T>> getRenamedTypesForTesting();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * DisambiguateProperties renames properties to disambiguate between unrelated\n * fields with the same name. Two properties are considered related if they\n * share a definition on their prototype chains, or if they are potentially\n * referenced together via union types.\n *\n * <p> Renamimg only occurs if there are two or more distinct properties with\n * the same name.\n *\n * <p> This pass allows other passes, such as inlining and code removal to take\n * advantage of type information implicitly.\n *\n * <pre>\n *   Foo.a;\n *   Bar.a;\n * </pre>\n *\n * <p> will become\n *\n * <pre>\n *   Foo.a$Foo;\n *   Bar.a$Bar;\n * </pre>\n *\n */\nclass DisambiguateProperties<T> implements CompilerPass {\n  private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;\n  /** Public for testing. */\n  T getTypeWithProperty(String field, T type);\n  /** Returns a map from field name to types for which it will be renamed. */\n  Multimap<String, Collection<T>> getRenamedTypesForTesting();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSets(boolean runTightenTypes, String js, String expected,\n      String fieldTypes) {\n    this.runTightenTypes = runTightenTypes;\n    test(js, expected);\n    assertEquals(\n        fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n  }\n  private void testSets(boolean runTightenTypes, String externs, String js,\n       String expected, String fieldTypes) {\n    testSets(runTightenTypes, externs, js, expected, fieldTypes, null, null);\n  }\n  private void testSets(boolean runTightenTypes, String externs, String js,\n       String expected, String fieldTypes, DiagnosticType warning,\n       String description) {\n    this.runTightenTypes = runTightenTypes;\n    test(externs, js, expected, null, warning, description);\n    assertEquals(\n        fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n  }\n  private void testSets(boolean runTightenTypes, String js, String fieldTypes) {\n    this.runTightenTypes = runTightenTypes;\n    test(js, null, null, null);\n    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n  }\n  private void testSets(boolean runTightenTypes, String js, String fieldTypes,\n      DiagnosticType warning) {\n    this.runTightenTypes = runTightenTypes;\n    test(js, null, null, warning);\n    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n  }\n  private <T> String mapToString(Multimap<String, Collection<T>> map) {\n    TreeMap<String, String> retMap = Maps.newTreeMap();\n    for (String key : map.keySet()) {\n      TreeSet<String> treeSet = Sets.newTreeSet();\n      for (Collection<T> collection : map.get(key)) {\n        Set<String> subSet = Sets.newTreeSet();\n        for (T type : collection) {\n          subSet.add(type.toString());\n        }\n        treeSet.add(subSet.toString());\n      }\n      retMap.put(key, treeSet.toString());\n    }\n    return retMap.toString();\n  }\n  public void testOneType4() {\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"Foo.prototype = {'a': 0};\\n\"\n        + \"/** @type Foo */\\n\"\n        + \"var F = new Foo;\\n\"\n        + \"F['a'] = 0;\";\n    String expected = \"{}\";\n    testSets(false, js, js, expected);\n    testSets(true, js, js, expected);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n */\nclass GlobalNamespace\n    implements StaticScope<JSType>,\n    StaticSymbolTable<GlobalNamespace.Name, GlobalNamespace.Ref> {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private int currentPreOrderIndex = 0;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n */\nclass GlobalNamespace\n    implements StaticScope<JSType>,\n    StaticSymbolTable<GlobalNamespace.Name, GlobalNamespace.Ref> {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private int currentPreOrderIndex = 0;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testGlobalCatch() throws Exception {\n    testSame(\n        \"try {\" +\n        \"  throw Error();\" +\n        \"} catch (e) {\" +\n        \"  console.log(e.name)\" +\n        \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Computes \"may be\" reaching use for all definitions of each variables.\n *\n * A use of {@code A} in {@code alert(A)} is a \"may be\" reaching use of\n * the definition of {@code A} at {@code A = foo()} if at least one path from\n * the use node reaches that definition and it is the last definition before\n * the use on that path.\n *\n */\nclass MaybeReachingVariableUse extends\n    DataFlowAnalysis<Node, MaybeReachingVariableUse.ReachingUses> {\n  private final Scope jsScope;\n  private final Set<Var> escaped;\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Computes \"may be\" reaching use for all definitions of each variables.\n *\n * A use of {@code A} in {@code alert(A)} is a \"may be\" reaching use of\n * the definition of {@code A} at {@code A = foo()} if at least one path from\n * the use node reaches that definition and it is the last definition before\n * the use on that path.\n *\n */\nclass MaybeReachingVariableUse extends\n    DataFlowAnalysis<Node, MaybeReachingVariableUse.ReachingUses> {\n  private final Scope jsScope;\n  private final Set<Var> escaped;\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void noInline(String input) {\n    inline(input, input);\n  }\n  private void inline(String input, String expected) {\n    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n        \"function _func() {\" + expected + \"}\", null, null);\n  }\n  public void testIssue794b() {\n    noInline(\n        \"var x = 1; \" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"x = x + 1;\" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"return x;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback,\n    HotSwapCompilerPass,\n    StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback,\n    HotSwapCompilerPass,\n    StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private final Node templateNode;\n  private Node transformBlock(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private final Node templateNode;\n  private Node transformBlock(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLinenoCharnoBinop(String binop) {\n    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n        getFirstChild().getFirstChild();\n\n    assertEquals(1, op.getLineno());\n    assertEquals(8, op.getCharno());\n  }\n  private void assertNodeEquality(Node expected, Node found) {\n    String message = expected.checkTreeEquals(found);\n    if (message != null) {\n      fail(message);\n    }\n  }\n  private Node createScript(Node n) {\n    Node script = new Node(Token.SCRIPT);\n    script.addChildToBack(n);\n    return script;\n  }\n  private Node parseError(String string, String... errors) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n    Node script = null;\n    try {\n      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n      script = ParserRunner.parse(\n          file, string, ParserRunner.createConfig(isIdeMode, mode, false),\n          testErrorReporter, Logger.getAnonymousLogger()).ast;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  private Node parse(String string, String... warnings) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    Node script = null;\n    try {\n      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n      script = ParserRunner.parse(\n          file, string, ParserRunner.createConfig(true, mode, false),\n          testErrorReporter, Logger.getAnonymousLogger()).ast;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  public void testSuspiciousBlockCommentWarning3() {\n    parse(\"/* \\n *@type {number} */ var x = 3;\", SUSPICIOUS_COMMENT_WARNING);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> escapedJsStrings = Maps.newHashMap();\n  void add(Node n, Context context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> escapedJsStrings = Maps.newHashMap();\n  void add(Node n, Context context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid JS\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrintSame(String js) {\n    assertPrint(js, js);\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreakAtEndOfFile(String js,\n      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {\n    assertEquals(expectedWithoutBreakAtEnd,\n        parsePrint(js, false, false, false, 30));\n    assertEquals(expectedWithBreakAtEnd,\n        parsePrint(js, false, false, true, 30));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testPrintInOperatorInForLoop() {\n    // Check for in expression in for's init expression.\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n    // and with conditional.\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a); i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a);i;);\");\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) ? 0 : 1; i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a)?0:1;i;);\");\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) + 1; i;) {}\",\n        \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n    assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n        \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n        \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n\n    // Test works with unary operators and calls.\n    assertPrint(\"var a={}; for (var i = -(\\\"length\\\" in a); i;) {}\",\n        \"var a={};for(var i=-(\\\"length\\\"in a);i;);\");\n    assertPrint(\"var a={};function b_(p){ return p;};\" +\n        \"for(var i=1,j=b_(\\\"length\\\" in a);;) {}\",\n        \"var a={};function b_(p){return p}\" +\n            \"for(var i=1,j=b_(\\\"length\\\"in a);;);\");\n\n    // Test we correctly handle an in operator in the test clause.\n    assertPrint(\"var a={}; for (;(\\\"length\\\" in a);) {}\",\n        \"var a={};for(;\\\"length\\\"in a;);\");\n\n    // Test we correctly handle an in operator inside a comma.\n    assertPrintSame(\"for(x,(y in z);;)foo()\");\n    assertPrintSame(\"for(var x,w=(y in z);;)foo()\");\n\n    // And in operator inside a hook.\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Tries to chain assignments together.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author acleung@google.com (Alan Leung)\n *\n */\nclass ExploitAssigns extends AbstractPeepholeOptimization {\n  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Tries to chain assignments together.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author acleung@google.com (Alan Leung)\n *\n */\nclass ExploitAssigns extends AbstractPeepholeOptimization {\n  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue1017() {\n    testSame(\"x = x.parentNode.parentNode; x = x.parentNode.parentNode;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private MemoizedScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final boolean reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  private Method editDistance;\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private MemoizedScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final boolean reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  private Method editDistance;\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1002() throws Exception {\n    testTypes(\n        \"/** @interface */\" +\n        \"var I = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var A = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var B = function() {};\" +\n        \"var f = function() {\" +\n        \"  if (A === B) {\" +\n        \"    new B();\" +\n        \"  }\" +\n        \"};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Transform the structure of the AST so that the number of explicit exits\n * are minimized.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass MinimizeExitPoints\n    extends AbstractPostOrderCallback\n    implements CompilerPass {\n  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Transform the structure of the AST so that the number of explicit exits\n * are minimized.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass MinimizeExitPoints\n    extends AbstractPostOrderCallback\n    implements CompilerPass {\n  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testDontRemoveBreakInTryFinally() throws Exception {\n    foldSame(\"function f() {b:try{throw 9} finally {break b} return 1;}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Removes dead code from a parse tree. The kinds of dead code that this pass\n * removes are:\n *  - Any code following a return statement, such as the <code>alert</code>\n *    call in: <code>if (x) { return; alert('unreachable'); }</code>.\n *  - Statements that have no side effects, such as:\n *    <code>a.b.MyClass.prototype.propertyName;</code> or <code>true;</code>.\n *    That first kind of statement sometimes appears intentionally, so that\n *    prototype properties can be annotated using JSDoc without actually\n *    being initialized.\n *\n */\nclass UnreachableCodeElimination implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean removeNoOpStatements;\n  private boolean codeChanged;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Removes dead code from a parse tree. The kinds of dead code that this pass\n * removes are:\n *  - Any code following a return statement, such as the <code>alert</code>\n *    call in: <code>if (x) { return; alert('unreachable'); }</code>.\n *  - Statements that have no side effects, such as:\n *    <code>a.b.MyClass.prototype.propertyName;</code> or <code>true;</code>.\n *    That first kind of statement sometimes appears intentionally, so that\n *    prototype properties can be annotated using JSDoc without actually\n *    being initialized.\n *\n */\nclass UnreachableCodeElimination implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean removeNoOpStatements;\n  private boolean codeChanged;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue4177428_return() {\n    test(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  alert(action)\\n\" + // and remove this.\n        \"};\",\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\"\n        );\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid JS\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrintSame(String js) {\n    assertPrint(js, js);\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreakAtEndOfFile(String js,\n      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {\n    assertEquals(expectedWithoutBreakAtEnd,\n        parsePrint(js, false, false, false, 30));\n    assertEquals(expectedWithBreakAtEnd,\n        parsePrint(js, false, false, true, 30));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testIssue942() {\n    assertPrint(\"var x = {0: 1};\", \"var x={0:1}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Prepare the AST before we do any checks or optimizations on it.\n *\n * This pass must run. It should bring the AST into a consistent state,\n * and add annotations where necessary. It should not make any transformations\n * on the tree that would lose source information, since we need that source\n * information for checks.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass PrepareAst implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean checkOnly;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Prepare the AST before we do any checks or optimizations on it.\n *\n * This pass must run. It should bring the AST into a consistent state,\n * and add annotations where necessary. It should not make any transformations\n * on the tree that would lose source information, since we need that source\n * information for checks.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass PrepareAst implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean checkOnly;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue937() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"console.log(\" +\n            \"/** @type {function():!string} */ ((new x())['abc'])() );\";\n    String result = \"\" +\n        \"console.log((new x()).abc());\";\n    test(options, code, result);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A compiler pass to run various peephole optimizations (e.g. constant folding,\n * some useless code removal, some minimizations).\n *\n * @author dcc@google.com (Devin Coughlin)\n * @author acleung@google.com (Alan Leung)(\n */\nclass PeepholeOptimizationsPass\n    implements CompilerPass {\n  private AbstractCompiler compiler;\n  private final AbstractPeepholeOptimization[] peepholeOptimizations;\n  private StateStack traversalState = new StateStack();\n  private void traverse(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A compiler pass to run various peephole optimizations (e.g. constant folding,\n * some useless code removal, some minimizations).\n *\n * @author dcc@google.com (Devin Coughlin)\n * @author acleung@google.com (Alan Leung)(\n */\nclass PeepholeOptimizationsPass\n    implements CompilerPass {\n  private AbstractCompiler compiler;\n  private final AbstractPeepholeOptimization[] peepholeOptimizations;\n  private StateStack traversalState = new StateStack();\n  private void traverse(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue787() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var fn1;\\n\" +\n        \"  var fn2;\\n\" +\n        \"\\n\" +\n        \"  if (any_expression) {\\n\" +\n        \"    fn2 = external_ref;\\n\" +\n        \"    fn1 = function (content) {\\n\" +\n        \"      return fn2();\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return {\\n\" +\n        \"    method1: function () {\\n\" +\n        \"      if (fn1) fn1();\\n\" +\n        \"      return true;\\n\" +\n        \"    },\\n\" +\n        \"    method2: function () {\\n\" +\n        \"      return false;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"}\";\n\n    String result = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var a, b;\\n\" +\n        \"  any_expression && (b = external_ref, a = function() {\\n\" +\n        \"    return b()\\n\" +\n        \"  });\\n\" +\n        \"  return{method1:function() {\\n\" +\n        \"    a && a();\\n\" +\n        \"    return !0\\n\" +\n        \"  }, method2:function() {\\n\" +\n        \"    return !1\\n\" +\n        \"  }}\\n\" +\n        \"}\\n\" +\n        \"\";\n\n    test(options, code, result);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue931() {\n    collapsePropertiesOnExternTypes = true;\n    testSame(\n      \"function f() {\\n\" +\n      \"  return function () {\\n\" +\n      \"    var args = arguments;\\n\" +\n      \"    setTimeout(function() { alert(args); }, 0);\\n\" +\n      \"  }\\n\" +\n      \"};\\n\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class implements the JavaScript scanner.\n *\n * It is based on the C source files jsscan.c and jsscan.h\n * in the jsref package.\n *\n */\npublic class TokenStream {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class implements the JavaScript scanner.\n *\n * It is based on the C source files jsscan.c and jsscan.h\n * in the jsref package.\n *\n */\npublic class TokenStream {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testQuotedProps() {\n    testSame(\"({'':0})\");\n    testSame(\"({'1.0':0})\");\n    testSame(\"({'\\u1d17A':0})\");\n    testSame(\"({'a\\u0004b':0})\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n  private final boolean late;\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n  private final boolean late;\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  public void testIssue925() {\n    test(\n        \"if (x[--y] === 1) {\\n\" +\n        \"    x[y] = 0;\\n\" +\n        \"} else {\\n\" +\n        \"    x[y] = 1;\\n\" +\n        \"}\",\n        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\");\n\n    test(\n        \"if (x[--y]) {\\n\" +\n        \"    a = 0;\\n\" +\n        \"} else {\\n\" +\n        \"    a = 1;\\n\" +\n        \"}\",\n        \"a = (x[--y]) ? 0 : 1;\");\n\n    test(\"if (x++) { x += 2 } else { x += 3 }\",\n         \"x++ ? x += 2 : x += 3\");\n\n    test(\"if (x++) { x = x + 2 } else { x = x + 3 }\",\n        \"x = x++ ? x + 2 : x + 3\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  /**\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   */\n  private void skipEOLs();\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  @SuppressWarnings(\"incomplete-switch\")\n  boolean parse();\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  /**\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   */\n  private void skipEOLs();\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  @SuppressWarnings(\"incomplete-switch\")\n  boolean parse();\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private JSType testParseType(String type) throws Exception {\n    return testParseType(type, type);\n  }\n  private JSType testParseType(\n      String type, String typeExpected) throws Exception {\n    JSDocInfo info = parse(\"@type {\" + type + \"}*/\");\n\n    assertNotNull(info);\n    assertTrue(info.hasType());\n\n    JSType actual = resolve(info.getType());\n    assertEquals(typeExpected, actual.toString());\n    return actual;\n  }\n  private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker,\n                                                       String description,\n                                                       int startCharno,\n                                                       int endLineno,\n                                                       int endCharno) {\n    assertTrue(marker.getDescription() != null);\n    assertEquals(description, marker.getDescription().getItem());\n\n    // Match positional information.\n    assertEquals(marker.getAnnotation().getStartLine(),\n                 marker.getDescription().getStartLine());\n    assertEquals(startCharno, marker.getDescription().getPositionOnStartLine());\n    assertEquals(endLineno, marker.getDescription().getEndLine());\n    assertEquals(endCharno, marker.getDescription().getPositionOnEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertTypeInMarker(\n      JSDocInfo.Marker marker, String typeName,\n      int startLineno, int startCharno, int endLineno, int endCharno,\n      boolean hasBrackets) {\n\n    assertTrue(marker.getType() != null);\n    assertTrue(marker.getType().getItem().isString());\n\n    // Match the name and brackets information.\n    String foundName = marker.getType().getItem().getString();\n\n    assertEquals(typeName, foundName);\n    assertEquals(hasBrackets, marker.getType().hasBrackets());\n\n    // Match position information.\n    assertEquals(startCharno, marker.getType().getPositionOnStartLine());\n    assertEquals(endCharno, marker.getType().getPositionOnEndLine());\n    assertEquals(startLineno, marker.getType().getStartLine());\n    assertEquals(endLineno, marker.getType().getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n      String name, int startLine, int startCharno) {\n    assertTrue(marker.getName() != null);\n    assertEquals(name, marker.getName().getItem());\n\n    assertEquals(startCharno, marker.getName().getPositionOnStartLine());\n    assertEquals(startCharno + name.length(),\n                 marker.getName().getPositionOnEndLine());\n\n    assertEquals(startLine, marker.getName().getStartLine());\n    assertEquals(startLine, marker.getName().getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno) {\n    return assertAnnotationMarker(jsdoc, annotationName, startLineno,\n                                  startCharno, 0);\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno,\n                                                  int index) {\n\n    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();\n\n    assertTrue(markers.size() > 0);\n\n    int counter = 0;\n\n    for (JSDocInfo.Marker marker : markers) {\n      if (marker.getAnnotation() != null) {\n        if (annotationName.equals(marker.getAnnotation().getItem())) {\n\n          if (counter == index) {\n            assertEquals(startLineno, marker.getAnnotation().getStartLine());\n            assertEquals(startCharno,\n                         marker.getAnnotation().getPositionOnStartLine());\n            assertEquals(startLineno, marker.getAnnotation().getEndLine());\n            assertEquals(startCharno + annotationName.length(),\n                         marker.getAnnotation().getPositionOnEndLine());\n\n            return marker;\n          }\n\n          counter++;\n        }\n      }\n    }\n\n    fail(\"No marker found\");\n    return null;\n  }\n  private <T> void assertContains(Collection<T> collection, T item) {\n    assertTrue(collection.contains(item));\n  }\n  private void parseFull(String code, String... warnings) {\n    CompilerEnvirons environment = new CompilerEnvirons();\n\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    environment.setErrorReporter(testErrorReporter);\n\n    environment.setRecordingComments(true);\n    environment.setRecordingLocalJsDocComments(true);\n\n    Parser p = new Parser(environment, testErrorReporter);\n    AstRoot script = p.parse(code, null, 0);\n\n    Config config =\n        new Config(extraAnnotations, extraSuppressions,\n            true, LanguageMode.ECMASCRIPT3, false);\n    for (Comment comment : script.getComments()) {\n      JsDocInfoParser jsdocParser =\n        new JsDocInfoParser(\n            new JsDocTokenStream(comment.getValue().substring(3),\n                comment.getLineno()),\n            comment,\n            null,\n            config,\n            testErrorReporter);\n      jsdocParser.parse();\n      jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n\n    assertTrue(\"some expected warnings were not reported\",\n        testErrorReporter.hasEncounteredAllWarnings());\n  }\n  private JSDocInfo parseFileOverviewWithoutDoc(String comment,\n                                                String... warnings) {\n    return parse(comment, false, true, warnings);\n  }\n  private JSDocInfo parseFileOverview(String comment, String... warnings) {\n    return parse(comment, true, true, warnings);\n  }\n  private JSDocInfo parse(String comment, String... warnings) {\n    return parse(comment, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n                          String... warnings) {\n    return parse(comment, parseDocumentation, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n      boolean parseFileOverview, String... warnings) {\n    TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n\n    Config config = new Config(extraAnnotations, extraSuppressions,\n        parseDocumentation, LanguageMode.ECMASCRIPT3, false);\n    StaticSourceFile file = new SimpleSourceFile(\"testcode\", false);\n    Node associatedNode = new Node(Token.SCRIPT);\n    associatedNode.setInputId(new InputId(file.getName()));\n    associatedNode.setStaticSourceFile(file);\n    JsDocInfoParser jsdocParser = new JsDocInfoParser(\n        stream(comment),\n        new Comment(0, 0, CommentType.JSDOC, comment),\n        associatedNode,\n        config, errorReporter);\n\n    if (fileLevelJsDocBuilder != null) {\n      jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    }\n\n    jsdocParser.parse();\n\n    assertTrue(\"expected warnings were not reported\",\n        errorReporter.hasEncounteredAllWarnings());\n\n    if (parseFileOverview) {\n      return jsdocParser.getFileOverviewJSDocInfo();\n    } else {\n      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n  }\n  private Node parseType(String typeComment) {\n    return JsDocInfoParser.parseTypeString(typeComment);\n  }\n  private JsDocTokenStream stream(String source) {\n    return new JsDocTokenStream(source, 0);\n  }\n  private void assertTemplatizedTypeEquals(String key, JSType expected,\n                                           JSTypeExpression te) {\n    assertEquals(\n        expected, resolve(te).getTemplateTypeMap().getTemplateType(key));\n  }\n  public void testTextExtents() {\n    parse(\"@return {@code foo} bar \\n *    baz. */\",\n        true, \"Bad type annotation. type not recognized due to syntax error\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Renames unrelated properties to the same name, using type information.\n * This allows better compression as more properties can be given short names.\n *\n * <p>Properties are considered unrelated if they are never referenced from the\n * same type or from a subtype of each others' types, thus this pass is only\n * effective if type checking is enabled.\n *\n * Example:\n * <code>\n *   Foo.fooprop = 0;\n *   Foo.fooprop2 = 0;\n *   Bar.barprop = 0;\n * </code>\n *\n * becomes:\n *\n * <code>\n *   Foo.a = 0;\n *   Foo.b = 0;\n *   Bar.a = 0;\n * </code>\n *\n*\n */\nclass AmbiguateProperties implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final List<Node> stringNodesToRename = Lists.newArrayList();\n  private final char[] reservedCharacters;\n  private final Map<String, Property> propertyMap = Maps.newHashMap();\n  private final Set<String> externedNames = Sets.newHashSet();\n  private final Set<String> quotedNames = Sets.newHashSet();\n  private final Map<String, String> renamingMap = Maps.newHashMap();\n  private final Map<Integer, String> colorMap = Maps.newHashMap();\n  /** Add supertypes of the type to its JSTypeBitSet of related types. */\n  private void computeRelatedTypes(JSType type);\n  public void process(Node externs, Node root);\n}\n/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Renames unrelated properties to the same name, using type information.\n * This allows better compression as more properties can be given short names.\n *\n * <p>Properties are considered unrelated if they are never referenced from the\n * same type or from a subtype of each others' types, thus this pass is only\n * effective if type checking is enabled.\n *\n * Example:\n * <code>\n *   Foo.fooprop = 0;\n *   Foo.fooprop2 = 0;\n *   Bar.barprop = 0;\n * </code>\n *\n * becomes:\n *\n * <code>\n *   Foo.a = 0;\n *   Foo.b = 0;\n *   Bar.a = 0;\n * </code>\n *\n*\n */\nclass AmbiguateProperties implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final List<Node> stringNodesToRename = Lists.newArrayList();\n  private final char[] reservedCharacters;\n  private final Map<String, Property> propertyMap = Maps.newHashMap();\n  private final Set<String> externedNames = Sets.newHashSet();\n  private final Set<String> quotedNames = Sets.newHashSet();\n  private final Map<String, String> renamingMap = Maps.newHashMap();\n  private final Map<Integer, String> colorMap = Maps.newHashMap();\n  /** Add supertypes of the type to its JSTypeBitSet of related types. */\n  private void computeRelatedTypes(JSType type);\n  public void process(Node externs, Node root);\n}\n/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testImplementsAndExtends() {\n    String js = \"\"\n        + \"/** @interface */ function Foo() {}\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" */\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.y = function() { return 3; };\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" * @extends {Bar}\\n\"\n        + \" * @implements {Foo}\\n\"\n        + \" */\\n\"\n        + \"function SubBar(){ }\\n\"\n        + \"/** @param {Foo} x */ function f(x) { x.z = 3; }\\n\"\n        + \"/** @param {SubBar} x */ function g(x) { x.z = 3; }\";\n    String output = \"\"\n        + \"function Foo(){}\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.b = function() { return 3; };\\n\"\n        + \"function SubBar(){}\\n\"\n        + \"function f(x) { x.a = 3; }\\n\"\n        + \"function g(x) { x.a = 3; }\";\n    test(js, output);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n*\n*\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean hasProperty(String name);\n  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns);\n}\n/**\n * Rewrites prototyped methods calls as static calls that take \"this\"\n * as their first argument.  This tranformation simplifies the call\n * graph so smart name removal, cross module code motion and other\n * passes can do more.\n *\n * <p>This pass should only be used in production code if property\n * and variable renaming are turned on.  Resulting code may also\n * benefit from --collapse_anonymous_functions and\n * --collapse_variable_declarations\n *\n * <p>This pass only rewrites functions that are part of an objects\n * prototype.  Functions that access the \"arguments\" variable\n * arguments object are not eligible for this optimization.\n *\n * <p>For example:\n * <pre>\n *     A.prototype.accumulate = function(value) {\n *       this.total += value; return this.total\n *     }\n *     var total = a.accumulate(2)\n * </pre>\n *\n * <p>will be rewritten as:\n *\n * <pre>\n *     var accumulate = function(self, value) {\n *       self.total += value; return self.total\n *     }\n *     var total = accumulate(a, 2)\n * </pre>\n *\n*\n */\nclass DevirtualizePrototypeMethods implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n*\n*\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean hasProperty(String name);\n  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns);\n}\n/**\n * Rewrites prototyped methods calls as static calls that take \"this\"\n * as their first argument.  This tranformation simplifies the call\n * graph so smart name removal, cross module code motion and other\n * passes can do more.\n *\n * <p>This pass should only be used in production code if property\n * and variable renaming are turned on.  Resulting code may also\n * benefit from --collapse_anonymous_functions and\n * --collapse_variable_declarations\n *\n * <p>This pass only rewrites functions that are part of an objects\n * prototype.  Functions that access the \"arguments\" variable\n * arguments object are not eligible for this optimization.\n *\n * <p>For example:\n * <pre>\n *     A.prototype.accumulate = function(value) {\n *       this.total += value; return this.total\n *     }\n *     var total = a.accumulate(2)\n * </pre>\n *\n * <p>will be rewritten as:\n *\n * <pre>\n *     var accumulate = function(self, value) {\n *       self.total += value; return self.total\n *     }\n *     var total = accumulate(a, 2)\n * </pre>\n *\n*\n */\nclass DevirtualizePrototypeMethods implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static String newlineJoin(String ... parts) {\n    return Joiner.on(\"\\n\").join(parts);\n  }\n  private static String semicolonJoin(String ... parts) {\n    return Joiner.on(\";\").join(parts);\n  }\n  private void checkTypes(String source,\n                          String expected,\n                          List<String> expectedTypes) {\n    typeInformation.clear();\n    test(source, expected);\n    assertEquals(expectedTypes, typeInformation);\n  }\n  public void testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * RenameVars renames all the variables names into short names, to reduce\n * code size and also to obfuscate the code.\n *\n*\n*\n */\nfinal class RenameVars implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final ArrayList<Node> globalNameNodes = new ArrayList<Node>();\n  private final ArrayList<Node> localNameNodes = new ArrayList<Node>();\n  private final ArrayList<String> localTempNames = new ArrayList<String>();\n  private final Set<String> externNames = new HashSet<String>();\n  private final Set<String> reservedNames;\n  private final Map<String, String> renameMap = new HashMap<String, String>();\n  private final VariableMap prevUsedRenameMap;\n  private final String prefix;\n  private int assignmentCount = 0;\n  private StringBuilder assignmentLog;\n  /**\n   * {@inheritDoc}\n   */\n  public void process(Node externs, Node root);\n}\n/**\n * Finds all method declarations and pulls them into data structures\n * for use during cleanups such as arity checks or inlining.\n *\n*\n*\n */\nabstract class MethodCompilerPass implements CompilerPass {\n  /**\n   * Subclasses should return a SignatureStore for storing discovered\n   * signatures.\n   */\n  abstract SignatureStore getSignatureStore();\n\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n  private void addPossibleSignature(String name, Node node, NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * RenameVars renames all the variables names into short names, to reduce\n * code size and also to obfuscate the code.\n *\n*\n*\n */\nfinal class RenameVars implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final ArrayList<Node> globalNameNodes = new ArrayList<Node>();\n  private final ArrayList<Node> localNameNodes = new ArrayList<Node>();\n  private final ArrayList<String> localTempNames = new ArrayList<String>();\n  private final Set<String> externNames = new HashSet<String>();\n  private final Set<String> reservedNames;\n  private final Map<String, String> renameMap = new HashMap<String, String>();\n  private final VariableMap prevUsedRenameMap;\n  private final String prefix;\n  private int assignmentCount = 0;\n  private StringBuilder assignmentLog;\n  /**\n   * {@inheritDoc}\n   */\n  public void process(Node externs, Node root);\n}\n/**\n * Finds all method declarations and pulls them into data structures\n * for use during cleanups such as arity checks or inlining.\n *\n*\n*\n */\nabstract class MethodCompilerPass implements CompilerPass {\n  /**\n   * Subclasses should return a SignatureStore for storing discovered\n   * signatures.\n   */\n  abstract SignatureStore getSignatureStore();\n\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n  private void addPossibleSignature(String name, Node node, NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testWithPrefix(String definitions, String js, String expected) {\n    test(definitions + js, definitions + expected);\n  }\n  public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n *  Find all Functions, VARs, and Exception names and make them\n *  unique.  Specifically, it will not modify object properties.\n *  @author johnlenz@google.com (John Lenz)\n *  TODO(johnlenz): Try to merge this with the ScopeCreator.\n */\nclass MakeDeclaredNamesUnique\n    implements NodeTraversal.ScopedCallback {\n  private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n  private final Renamer rootRenamer;\n  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler);\n}\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 3) Removes duplicate variable declarations.\n * 4) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n*\n*\n */\npublic final class NodeUtil {\n  public static final String CONSTANT_MARKER = \"$$constant\";\n  /** Whether the node is part of a switch statement. */\n  static boolean isSwitchCase(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n *  Find all Functions, VARs, and Exception names and make them\n *  unique.  Specifically, it will not modify object properties.\n *  @author johnlenz@google.com (John Lenz)\n *  TODO(johnlenz): Try to merge this with the ScopeCreator.\n */\nclass MakeDeclaredNamesUnique\n    implements NodeTraversal.ScopedCallback {\n  private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n  private final Renamer rootRenamer;\n  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler);\n}\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 3) Removes duplicate variable declarations.\n * 4) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n*\n*\n */\npublic final class NodeUtil {\n  public static final String CONSTANT_MARKER = \"$$constant\";\n  /** Whether the node is part of a switch statement. */\n  static boolean isSwitchCase(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private String wrapInFunction(String s) {\n    return \"function f(){\" + s + \"}\";\n  }\n  public void testOnlyInversion3() {\n    invert = true;\n    test(\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a$$2;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a$$3;\" +\n        \"  }\" +\n        \"}\",\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A reverse abstract interpreter (RAI) for specific closure patterns such as\n * {@code goog.isDef}.\n *\n*\n */\nclass ClosureReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome);\n}\n/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n*\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Set<String> unflowableVarNames = Sets.newHashSet();\n  @Override\n  FlowScope createEntryLattice();\n  private FlowScope traverseName(Node n, FlowScope scope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A reverse abstract interpreter (RAI) for specific closure patterns such as\n * {@code goog.isDef}.\n *\n*\n */\nclass ClosureReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  @Override\n  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome);\n}\n/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n*\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Set<String> unflowableVarNames = Sets.newHashSet();\n  @Override\n  FlowScope createEntryLattice();\n  private FlowScope traverseName(Node n, FlowScope scope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    CompilerTypeTestCase {\n  private void testClosureFunction(String function, JSType type,\n      JSType trueType, JSType falseType) {\n    // function(a) where a : type\n    Node n = compiler.parseTestCode(\"var a; \" + function + \"(a)\");\n    Node call = n.getLastChild().getLastChild();\n    Node name = call.getLastChild();\n\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null);\n    FlowScope flowScope = LinkedFlowScope.createEntryLattice(scope);\n\n    assertEquals(Token.CALL, call.getType());\n    assertEquals(Token.NAME, name.getType());\n\n    GoogleCodingConvention convention = new GoogleCodingConvention();\n    flowScope.inferSlotType(\"a\", type);\n    ClosureReverseAbstractInterpreter rai =\n        new ClosureReverseAbstractInterpreter(convention, registry);\n\n    // trueScope\n    assertEquals(trueType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, true)\n        .getSlot(\"a\").getType());\n\n    // falseScope\n    assertEquals(falseType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, false)\n        .getSlot(\"a\").getType());\n  }\n  public void testGoogIsArrayOnNull() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        null,\n        ARRAY_TYPE,\n        null);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private String inFunction(String code) {\n    return \"(function(){\" + code + \"})\";\n  }\n  private void testSameInFunction(String code) {\n    testSame(inFunction(code));\n  }\n  private void testInFunction(String code, String expected) {\n    test(inFunction(code), inFunction(expected));\n  }\n    private void testConstantProperties() {\n      test(\"var a={}; a.ACONST = 4;var b = a.ACONST;\",\n            \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;\",\n           \"var a$b$ACONST = 4;var b = a$b$ACONST;\");\n\n      test(\"var a = {FOO: 1};var b = a.FOO;\",\n           \"var a$FOO = 1; var b = a$FOO;\");\n\n      test(\"var EXTERN; var ext; ext.FOO;\", \"var b = EXTERN; var c = ext.FOO\",\n           \"var b = EXTERN; var c = ext.FOO\", null, null);\n\n      test(\"var a={}; a.ACONST = 4; var b = a.ACONST;\",\n           \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a = {}; function foo() { var d = a.CONST; };\" +\n           \"(function(){a.CONST=4})();\",\n           \"var a$CONST;function foo(){var d = a$CONST;};\" +\n           \"(function(){a$CONST = 4})();\");\n\n      test(\"var a = {}; a.ACONST = new Foo(); var b = a.ACONST;\",\n           \"var a$ACONST = new Foo(); var b = a$ACONST;\");\n    }\n  public void testNormalizeFunctionDeclarations() throws Exception {\n    testSame(\"function f() {}\");\n    testSame(\"var f = function () {}\");\n    test(\"var f = function f() {}\",\n         \"var f = function f$$1() {}\");\n    testSame(\"var f = function g() {}\");\n    test(\"a:function g() {}\",\n         \"a:{ var g = function () {} }\");\n    test(\"{function g() {}}\",\n         \"{var g = function () {}}\");\n    testSame(\"if (function g() {}) {}\");\n    test(\"if (true) {function g() {}}\",\n         \"if (true) {var g = function () {}}\");\n    test(\"if (true) {} else {function g() {}}\",\n         \"if (true) {} else {var g = function () {}}\");\n    testSame(\"switch (function g() {}) {}\");\n    test(\"switch (1) { case 1: function g() {}}\",\n         \"switch (1) { case 1: var g = function () {}}\");\n\n\n    testSameInFunction(\"function f() {}\");\n    testInFunction(\"f(); a:function g() {}\",\n                   \"f(); a:{ var g = function () {} }\");\n    testInFunction(\"f(); {function g() {}}\",\n                   \"f(); {var g = function () {}}\");\n    testInFunction(\"f(); if (true) {function g() {}}\",\n                   \"f(); if (true) {var g = function () {}}\");\n    testInFunction(\"if (true) {} else {function g() {}}\",\n                   \"if (true) {} else {var g = function () {}}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private Map<Node, Integer> astPosition;\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private Map<Node, Integer> astPosition;\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static String createFunction(String returnType, String body) {\n    return \"/** @return {\" + returnType + \"} */ function foo() {\" + body + \"}\";\n  }\n  private void testMissing(String returnType, String body) {\n    String js = createFunction(returnType, body);\n    test(js, js, CheckMissingReturn.MISSING_RETURN_STATEMENT);\n  }\n  private void testNotMissing(String returnType, String body) {\n    testSame(createFunction(returnType, body));\n  }\n  private void testNotMissing(String body) {\n    testNotMissing(\"number\", body);\n  }\n  private void testMissing(String body) {\n    testMissing(\"number\", body);\n  }\n  public void testIssue779() {\n    testNotMissing(\n        \"var a = f(); try { alert(); if (a > 0) return 1; }\" +\n        \"finally { a = 5; } return 2;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n*\n*\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private CompilerInput[] externs;\n  private JSModule[] modules;\n  private JSModuleGraph moduleGraph;\n  private CompilerInput[] inputs;\n  private ErrorManager errorManager;\n  private SymbolTable symbolTable = null;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean normalized = false;\n  private boolean useThreads = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private final TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(JSModule[] modules);\n  @Override\n  Node getNodeForCodeInsertion(JSModule module);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n*\n*\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private CompilerInput[] externs;\n  private JSModule[] modules;\n  private JSModuleGraph moduleGraph;\n  private CompilerInput[] inputs;\n  private ErrorManager errorManager;\n  private SymbolTable symbolTable = null;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean normalized = false;\n  private boolean useThreads = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private final TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(JSModule[] modules);\n  @Override\n  Node getNodeForCodeInsertion(JSModule module);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testEmptyModule() {\n    // When the dest module is empty, it might try to move the code to the\n    // one of the modules that the empty module depends on. In some cases\n    // this might ended up to be the same module as the definition of the code.\n    // When that happens, CrossMooduleCodeMotion might report a code change\n    // while nothing is moved. This should not be a problem if we know all\n    // modules are non-empty.\n    JSModule m1 = new JSModule(\"m1\");\n    m1.add(JSSourceFile.fromCode(\"m1\", \"function x() {}\"));\n    \n    JSModule empty = new JSModule(\"empty\");\n    empty.addDependency(m1);\n    \n    JSModule m2 = new JSModule(\"m2\");\n    m2.add(JSSourceFile.fromCode(\"m2\", \"x()\"));\n    m2.addDependency(empty);\n    \n    JSModule m3 = new JSModule(\"m3\");\n    m3.add(JSSourceFile.fromCode(\"m3\", \"x()\"));\n    m3.addDependency(empty);\n    \n    test(new JSModule[] {m1,empty,m2,m3},\n        new String[] {\n          \"\",\n          \"function x() {}\",\n          \"x()\",\n          \"x()\"\n    });\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n*\n*\n */\npublic final class NodeUtil {\n  public static final String CONSTANT_MARKER = \"$$constant\";\n  /**\n   * @param knownConstants A set of names known to be constant value at\n   * node 'n' (such as locals that are last written before n can execute).\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n, Set<String> knownConstants);\n}\n/**\n * Compiler pass that computes function purity.  A function is pure if\n * it has no outside visible side effects, and the result of the\n * computation does not depend on external factors that are beyond the\n * control of the application; repeated calls to the function should\n * return the same value as long as global state hasn't changed.\n *\n * Date.now is an example of a function that has no side effects but\n * is not pure.\n *\n*\n *\n * We will prevail, in peace and freedom from fear, and in true\n * health, through the purity and essence of our natural... fluids.\n *                                    - General Turgidson\n */\nclass PureFunctionIdentifier implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final DefinitionProvider definitionProvider;\n  private final Map<Node, FunctionInformation> functionSideEffectMap;\n  private final List<Node> allFunctionCalls;\n  private Node externs;\n  private Node root;\n  /**\n   * Compute debug report that includes:\n   *  - List of all pure functions.\n   *  - Reasons we think the remaining functions have side effects.\n   */\n  String getDebugReport();\n  /**\n   * Query the DefinitionProvider for the list of definitions that\n   * correspond to a given qualified name subtree.  Return null if\n   * DefinitionProvider does not contain an entry for a given name,\n   * one or more of the values returned by getDeclarations is not\n   * callable, or the \"name\" node is not a GETPROP or NAME.\n   *\n   * @param definitionProvider The name reference graph\n   * @param name Query node\n   * @return non-empty definition list or null\n   */\n  private static Collection<Definition> getCallableDefinitions(\n      DefinitionProvider definitionProvider, Node name);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n*\n*\n */\npublic final class NodeUtil {\n  public static final String CONSTANT_MARKER = \"$$constant\";\n  /**\n   * @param knownConstants A set of names known to be constant value at\n   * node 'n' (such as locals that are last written before n can execute).\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n, Set<String> knownConstants);\n}\n/**\n * Compiler pass that computes function purity.  A function is pure if\n * it has no outside visible side effects, and the result of the\n * computation does not depend on external factors that are beyond the\n * control of the application; repeated calls to the function should\n * return the same value as long as global state hasn't changed.\n *\n * Date.now is an example of a function that has no side effects but\n * is not pure.\n *\n*\n *\n * We will prevail, in peace and freedom from fear, and in true\n * health, through the purity and essence of our natural... fluids.\n *                                    - General Turgidson\n */\nclass PureFunctionIdentifier implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final DefinitionProvider definitionProvider;\n  private final Map<Node, FunctionInformation> functionSideEffectMap;\n  private final List<Node> allFunctionCalls;\n  private Node externs;\n  private Node root;\n  /**\n   * Compute debug report that includes:\n   *  - List of all pure functions.\n   *  - Reasons we think the remaining functions have side effects.\n   */\n  String getDebugReport();\n  /**\n   * Query the DefinitionProvider for the list of definitions that\n   * correspond to a given qualified name subtree.  Return null if\n   * DefinitionProvider does not contain an entry for a given name,\n   * one or more of the values returned by getDeclarations is not\n   * callable, or the \"name\" node is not a GETPROP or NAME.\n   *\n   * @param definitionProvider The name reference graph\n   * @param name Query node\n   * @return non-empty definition list or null\n   */\n  private static Collection<Definition> getCallableDefinitions(\n      DefinitionProvider definitionProvider, Node name);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void helperCanExposeExpression(\n      DecompositionType expectedResult,\n      String code,\n      String fnName\n      ) {\n    helperCanExposeExpression(expectedResult, code, fnName, null);\n  }\n  private void helperCanExposeAnonymousFunctionExpression(\n      DecompositionType expectedResult, String code, int call) {\n    Compiler compiler = new Compiler();\n    Set<String> knownConstants = Sets.newHashSet();\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n    Node tree = parse(compiler, code);\n    assertNotNull(tree);\n\n    Node externsRoot = parse(compiler,\n        \"function goo() {}\" +\n        \"function foo() {}\");\n    assertNotNull(externsRoot);\n    Node mainRoot = tree;\n\n    Node callSite = findCall(tree, null, 2);\n    assertNotNull(\"Call \" + call + \" was not found.\", callSite);\n\n    compiler.resetUniqueNameId();\n    DecompositionType result = decomposer.canExposeExpression(\n        callSite);\n    assertEquals(expectedResult, result);\n  }\n  private void helperCanExposeExpression(\n      DecompositionType expectedResult,\n      String code,\n      String fnName,\n      Set<String> knownConstants\n      ) {\n    Compiler compiler = new Compiler();\n    if (knownConstants == null) {\n      knownConstants = Sets.newHashSet();\n    }\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n    Node tree = parse(compiler, code);\n    assertNotNull(tree);\n\n    Node externsRoot = parse(compiler,\n        \"function goo() {}\" +\n        \"function foo() {}\");\n    assertNotNull(externsRoot);\n    Node mainRoot = tree;\n\n    Node callSite = findCall(tree, fnName);\n    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n\n    compiler.resetUniqueNameId();\n    DecompositionType result = decomposer.canExposeExpression(\n        callSite);\n    assertEquals(expectedResult, result);\n  }\n  private void helperExposeExpression(\n      String code,\n      String fnName,\n      String expectedResult\n      ) {\n    helperExposeExpression(\n        code, fnName, expectedResult, null);\n  }\n  private void helperExposeExpression(\n      String code,\n      String fnName,\n      String expectedResult,\n      Set<String> knownConstants\n      ) {\n    Compiler compiler = new Compiler();\n    if (knownConstants == null) {\n      knownConstants = Sets.newHashSet();\n    }\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n    decomposer.setTempNamePrefix(\"temp_\");\n    Node expectedRoot = parse(compiler, expectedResult);\n    Node tree = parse(compiler, code);\n    assertNotNull(tree);\n\n    Node externsRoot = new Node(Token.EMPTY);\n    Node mainRoot = tree;\n\n    Node callSite = findCall(tree, fnName);\n    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n\n    DecompositionType result = decomposer.canExposeExpression(callSite);\n    assertTrue(result == DecompositionType.DECOMPOSABLE);\n\n    compiler.resetUniqueNameId();\n    decomposer.exposeExpression(callSite);\n    String explanation = expectedRoot.checkTreeEquals(tree);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(tree) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void helperMoveExpression(\n      String code,\n      String fnName,\n      String expectedResult\n      ) {\n    helperMoveExpression(\n        code, fnName, expectedResult, null);\n  }\n  private void helperMoveExpression(\n      String code,\n      String fnName,\n      String expectedResult,\n      Set<String> knownConstants\n      ) {\n    Compiler compiler = new Compiler();\n    if (knownConstants == null) {\n      knownConstants = Sets.newHashSet();\n    }\n\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n    decomposer.setTempNamePrefix(\"temp_\");\n    Node expectedRoot = parse(compiler, expectedResult);\n    Node tree = parse(compiler, code);\n    assertNotNull(tree);\n\n    Node externsRoot = new Node(Token.EMPTY);\n    Node mainRoot = tree;\n\n    Node callSite = findCall(tree, fnName);\n    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n\n    compiler.resetUniqueNameId();\n    decomposer.moveExpression(callSite);\n    String explanation = expectedRoot.checkTreeEquals(tree);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(tree) +\n        \"\\n\" + explanation, explanation);\n  }\n  private static Node findCall(Node n, String name) {\n    return findCall(n, name, 1);\n  }\n  private static Node findCall(\n      Node root, @Nullable final String name, final int call) {\n    class Find {\n      int found = 0;\n      Node find(Node n) {\n        if (n.getType() == Token.CALL) {\n          Node callee = n.getFirstChild();\n          if (name == null || (callee.getType() == Token.NAME\n              && callee.getString().equals(name))) {\n            found++;\n            if (found == call) {\n              return n;\n            }\n          }\n        }\n\n        for (Node c : n.children()) {\n          Node result = find(c);\n          if (result != null) {\n            return result;\n          }\n        }\n\n        return null;\n      }\n    }\n\n    return (new Find()).find(root);\n  }\n  private static Node parse(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  public void testCanExposeExpression2() {\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"var x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"if(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"function (){ return foo();}\", \"foo\");\n\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() && 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() || 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() ? 0 : 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"(function(a){b = a})(foo())\", \"foo\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Reuse variable names if possible.\n *\n * <p>For example, from <code>var x = 1; print(x); var y = 2; print(y); </code>\n * to <code>var x = 1; print(x); x = 2; print(x)</code>. The benefits are\n * slightly shorter code because of the removed <code>var<code> declaration,\n * less unique variables in hope for better renaming, and finally better gzip\n * compression.\n *\n * <p>The pass operates similar to a typical register allocator found in an\n * optimizing compiler by first computing live ranges with\n * {@link LiveVariablesAnalysis} and a variable interference graph. Then it uses\n * graph coloring in {@link GraphColoring} to determine which two variables can\n * be merge together safely.\n *\n*\n */\nclass CoalesceVariableNames extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Deque<GraphColoring<Var, Void>> colorings;\n  private final boolean usePseudoNames;\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n/**\n * A parser for JSDoc comments.\n *\n*\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSTypeRegistry typeRegistry;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Reuse variable names if possible.\n *\n * <p>For example, from <code>var x = 1; print(x); var y = 2; print(y); </code>\n * to <code>var x = 1; print(x); x = 2; print(x)</code>. The benefits are\n * slightly shorter code because of the removed <code>var<code> declaration,\n * less unique variables in hope for better renaming, and finally better gzip\n * compression.\n *\n * <p>The pass operates similar to a typical register allocator found in an\n * optimizing compiler by first computing live ranges with\n * {@link LiveVariablesAnalysis} and a variable interference graph. Then it uses\n * graph coloring in {@link GraphColoring} to determine which two variables can\n * be merge together safely.\n *\n*\n */\nclass CoalesceVariableNames extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Deque<GraphColoring<Var, Void>> colorings;\n  private final boolean usePseudoNames;\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n/**\n * A parser for JSDoc comments.\n *\n*\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSTypeRegistry typeRegistry;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void inFunction(String src) {\n    inFunction(src, src);\n  }\n  private void inFunction(String src, String expected) {\n    test(\"function FUNC(){\" + src + \"}\",\n         \"function FUNC(){\" + expected + \"}\");\n  }\n  private void test(String src) {\n    test(src, src);\n  }\n  public void testParameter4() {\n    // Make sure that we do not merge two-arg functions because of the\n    // IE sort bug (see comments in computeEscaped)\n    test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Pass that simplifies expression statements by replacing the\n * expression with the portions that have side effects.\n *\n * <p>This pass will rewrite:\n * <pre>\n *   1 + foo() + bar()\n * </pre>\n * as:\n * <pre>\n *   foo();bar()\n * </pre>\n *\n*\n */\nfinal class RemoveConstantExpressions implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private PrintStream out;\n  private final PrintStream err;\n  private A compiler;\n  private static Charset inputCharset;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  final protected void setRunOptions(B options)\n      throws IOException, FlagUsageException;\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n  /**\n   * Returns the instance of the Options to use when {@link #run()} is called.\n   * createCompiler() is called before createOptions(), so getCompiler()\n   * will not return null when createOptions() is called.\n   */\n  protected abstract B createOptions();\n\n  protected DiagnosticGroups getDiagnosticGroups();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Pass that simplifies expression statements by replacing the\n * expression with the portions that have side effects.\n *\n * <p>This pass will rewrite:\n * <pre>\n *   1 + foo() + bar()\n * </pre>\n * as:\n * <pre>\n *   foo();bar()\n * </pre>\n *\n*\n */\nfinal class RemoveConstantExpressions implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private PrintStream out;\n  private final PrintStream err;\n  private A compiler;\n  private static Charset inputCharset;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  final protected void setRunOptions(B options)\n      throws IOException, FlagUsageException;\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n  /**\n   * Returns the instance of the Options to use when {@link #run()} is called.\n   * createCompiler() is called before createOptions(), so getCompiler()\n   * will not return null when createOptions() is called.\n   */\n  protected abstract B createOptions();\n\n  protected DiagnosticGroups getDiagnosticGroups();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n  }\n  private Compiler compile(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = null;\n    try {\n      runner = new CommandLineRunner(argStrings);\n    } catch (CmdLineException e) {\n      throw new RuntimeException(e);\n    }\n    Compiler compiler = runner.createCompiler();\n    lastCompiler = compiler;\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    CompilerOptions options = runner.createOptions();\n    try {\n      runner.setRunOptions(options);\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n      fail(\"Unexpected exception \" + e);\n    } catch (IOException e) {\n      assert(false);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = null;\n    try {\n      runner = new CommandLineRunner(argStrings);\n    } catch (CmdLineException e) {\n      throw new RuntimeException(e);\n    }\n    Compiler compiler = runner.createCompiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testDefineFlag3() {\n    args.add(\"--define=FOO=\\\"x'\\\"\");\n    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n         \"var FOO = \\\"x'\\\";\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n*\n*\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private JSType supAndInfHelper(JSType that, boolean leastSuper);\n}\n/**\n * A builder class for function and arrow types.\n *\n * If you need to build an interface constructor,\n * use {@link JSTypeRegistry#createInterfaceType}.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic final class FunctionBuilder {\n  private final JSTypeRegistry registry;\n  private String name = null;\n  private Node sourceNode = null;\n  private Node parametersNode = null;\n  private JSType returnType = null;\n  private ObjectType typeOfThis = null;\n  private String templateTypeName = null;\n  private boolean inferredReturnType = false;\n  private boolean isConstructor = false;\n  private boolean isNativeType = false;\n  /** Construct a new function type. */\n  public FunctionType build();\n  /** Set the return type. */\n  public FunctionBuilder withReturnType(JSType returnType);\n}\n/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n*\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private JSType returnType = null;\n  private List<ObjectType> implementedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private Node sourceNode = null;\n  private String templateTypeName = null;\n  /**\n   * Infer the return type from JSDocInfo.\n   */\n  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info);\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      FunctionType oldType, @Nullable Node paramsParent);\n  /**\n   * Builds the function type, and puts it in the registry.\n   */\n  FunctionType buildAndRegister();\n  private void maybeSetBaseType(FunctionType fnType);\n  /**\n   * Sets the FUNCTION node of this function.\n   */\n  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n*\n*\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private JSType supAndInfHelper(JSType that, boolean leastSuper);\n}\n/**\n * A builder class for function and arrow types.\n *\n * If you need to build an interface constructor,\n * use {@link JSTypeRegistry#createInterfaceType}.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic final class FunctionBuilder {\n  private final JSTypeRegistry registry;\n  private String name = null;\n  private Node sourceNode = null;\n  private Node parametersNode = null;\n  private JSType returnType = null;\n  private ObjectType typeOfThis = null;\n  private String templateTypeName = null;\n  private boolean inferredReturnType = false;\n  private boolean isConstructor = false;\n  private boolean isNativeType = false;\n  /** Construct a new function type. */\n  public FunctionType build();\n  /** Set the return type. */\n  public FunctionBuilder withReturnType(JSType returnType);\n}\n/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n*\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private JSType returnType = null;\n  private List<ObjectType> implementedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private Node sourceNode = null;\n  private String templateTypeName = null;\n  /**\n   * Infer the return type from JSDocInfo.\n   */\n  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info);\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      FunctionType oldType, @Nullable Node paramsParent);\n  /**\n   * Builds the function type, and puts it in the registry.\n   */\n  FunctionType buildAndRegister();\n  private void maybeSetBaseType(FunctionType fnType);\n  /**\n   * Sets the FUNCTION node of this function.\n   */\n  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    assertTrue(code, parse1.checkTreeEqualsSilent(parse2));\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testTypeAnnotationsAssign() {\n    assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"var Foo = function() {\\n}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n*\n*\n */\nclass CodeGenerator {\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n   * @param n The node to print.\n   * @param context The context to determine how the node should be printed.\n   */\n  private void addNonEmptyExpression(\n      Node n, Context context, boolean allowNonBlockChild);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n*\n*\n */\nclass CodeGenerator {\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n   * @param n The node to print.\n   * @param context The context to determine how the node should be printed.\n   */\n  private void addNonEmptyExpression(\n      Node n, Context context, boolean allowNonBlockChild);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    assertTrue(code, parse1.checkTreeEqualsSilent(parse2));\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testFunctionSafariCompatiblity() {\n    // Functions within IFs cause syntax errors on Safari.\n    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n    assertPrint(\"if(e1){function goo(){return true}}\",\n        \"if(e1){function goo(){return true}}\");\n\n    assertPrint(\"if(e1)function goo(){return true}\",\n        \"if(e1){function goo(){return true}}\");\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n        \"if(e1){A:function goo(){return true}}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n*\n*\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n*\n*\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends CompilerTypeTestCase {\n  private void testBinop(FlowScope blind, int binop, Node left, Node right,\n      Collection<TypedName> trueOutcome,\n      Collection<TypedName> falseOutcome) {\n    Node condition = new Node(binop);\n    condition.addChildToBack(left);\n    condition.addChildToBack(right);\n\n    // true outcome.\n    FlowScope informedTrue = interpreter.\n        getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n    for (TypedName p : trueOutcome) {\n      assertEquals(p.name, p.type, getVarType(informedTrue, p.name));\n    }\n\n    // false outcome.\n    FlowScope informedFalse = interpreter.\n        getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n    for (TypedName p : falseOutcome) {\n      assertEquals(p.type, getVarType(informedFalse, p.name));\n    }\n  }\n  private Node createNull() {\n    Node n = new Node(Token.NULL);\n    n.setJSType(NULL_TYPE);\n    return n;\n  }\n  private Node createNumber(int n) {\n    Node number = createUntypedNumber(n);\n    number.setJSType(NUMBER_TYPE);\n    return number;\n  }\n  private Node createUntypedNumber(int n) {\n    return Node.newNumber(n);\n  }\n  private JSType getVarType(FlowScope scope, String name) {\n    return scope.getSlot(name).getType();\n  }\n  private Node createVar(FlowScope scope, String name, JSType type) {\n    Node n = Node.newString(Token.NAME, name);\n    functionScope.declare(name, n, null, null);\n    ((LinkedFlowScope) scope).inferSlotType(name, type);\n    n.setJSType(type);\n    return n;\n  }\n  public void testEqCondition4() throws Exception {\n    FlowScope blind = newScope();\n    testBinop(blind,\n        Token.EQ,\n        createVar(blind, \"a\", VOID_TYPE),\n        createVar(blind, \"b\", VOID_TYPE),\n        Sets.newHashSet(\n            new TypedName(\"a\", VOID_TYPE),\n            new TypedName(\"b\", VOID_TYPE)),\n        Sets.newHashSet(\n            new TypedName(\"a\", NO_TYPE),\n            new TypedName(\"b\", NO_TYPE)));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n/**\n * Inserts runtime type assertions.\n *\n * <p>We add markers to user-defined interfaces and classes in order to check if\n * an object conforms to that type.\n *\n * <p>For each function, we insert a runtime type assertion for each parameter\n * and return value for which the compiler has a type.\n *\n * <p>The JavaScript code which implements the type assertions is in\n * js/runtime-type-check.js.\n *\n*\n*\n */\nclass RuntimeTypeCheck implements CompilerPass {\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n/**\n * Inserts runtime type assertions.\n *\n * <p>We add markers to user-defined interfaces and classes in order to check if\n * an object conforms to that type.\n *\n * <p>For each function, we insert a runtime type assertion for each parameter\n * and return value for which the compiler has a type.\n *\n * <p>The JavaScript code which implements the type assertions is in\n * js/runtime-type-check.js.\n *\n*\n*\n */\nclass RuntimeTypeCheck implements CompilerPass {\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFailure(String js) {\n    test(js, null, CheckGlobalThis.GLOBAL_THIS);\n  }\n  public void testIssue182a() {\n    testFailure(\"var NS = {read: function() { return this.foo; }};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Collects information mapping the generated (compiled) source back to\n * its original source for debugging purposes.\n *\n * @see CodeConsumer\n * @see CodeGenerator\n * @see CodePrinter\n *\n*\n * @author johnlenz@google.com (John Lenz)\n */\npublic class SourceMap {\n  /**\n   * Escapes the given string for JSON.\n   */\n  private static String escapeString(String value);\n  /**\n   * Resets the source map for reuse for the generation of a new source file.\n   */\n  void reset();\n  /**\n   * Sets the prefix used for wrapping the generated source file before\n   * it is output. This ensures that the source map is adjusted as\n   * needed.\n   *\n   * @param prefix The prefix that is added before the generated source code.\n   */\n  void setWrapperPrefix(String prefix);\n  /**\n   * Adds a mapping for the given node.  Mappings must be added in order.\n   *\n   * @param node The node that the new mapping represents.\n   * @param startPosition The position on the starting line\n   * @param endPosition The position on the ending line.\n   */\n  void addMapping(Node node, Position startPosition, Position endPosition);\n}\n/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n*\n*\n */\npublic class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  /**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */\n  private Node tryFoldTypeof(Node originalTypeofNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Collects information mapping the generated (compiled) source back to\n * its original source for debugging purposes.\n *\n * @see CodeConsumer\n * @see CodeGenerator\n * @see CodePrinter\n *\n*\n * @author johnlenz@google.com (John Lenz)\n */\npublic class SourceMap {\n  /**\n   * Escapes the given string for JSON.\n   */\n  private static String escapeString(String value);\n  /**\n   * Resets the source map for reuse for the generation of a new source file.\n   */\n  void reset();\n  /**\n   * Sets the prefix used for wrapping the generated source file before\n   * it is output. This ensures that the source map is adjusted as\n   * needed.\n   *\n   * @param prefix The prefix that is added before the generated source code.\n   */\n  void setWrapperPrefix(String prefix);\n  /**\n   * Adds a mapping for the given node.  Mappings must be added in order.\n   *\n   * @param node The node that the new mapping represents.\n   * @param startPosition The position on the starting line\n   * @param endPosition The position on the ending line.\n   */\n  void addMapping(Node node, Position startPosition, Position endPosition);\n}\n/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n*\n*\n */\npublic class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  /**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */\n  private Node tryFoldTypeof(Node originalTypeofNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  public void testFoldTypeof() {\n    fold(\"x = typeof 1\", \"x = \\\"number\\\"\");\n    fold(\"x = typeof 'foo'\", \"x = \\\"string\\\"\");\n    fold(\"x = typeof true\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof false\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof null\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof undefined\", \"x = \\\"undefined\\\"\");\n    fold(\"x = typeof void 0\", \"x = \\\"undefined\\\"\");\n    fold(\"x = typeof []\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof [1]\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof [1,[]]\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof {}\", \"x = \\\"object\\\"\");\n\n    foldSame(\"x = typeof[1,[foo()]]\");\n    foldSame(\"x = typeof{bathwater:baby()}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n*\n*\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean normalized = false;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  public Node parse(JSSourceFile file);\n  CompilerOptions getOptions();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Returns the root node of the AST, which includes both externs and source.\n   */\n  public Node getRoot();\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n}\n/**\n * Compiler options\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class CompilerOptions implements Serializable, Cloneable {\n  private static final long serialVersionUID = 7L;\n  public boolean ideMode;\n  public transient MessageBundle messageBundle = null;\n  public boolean checkSymbols;\n  public CheckLevel checkShadowVars;\n  public CheckLevel aggressiveVarCheck;\n  public CheckLevel checkFunctions;\n  public CheckLevel checkMethods;\n  public boolean checkDuplicateMessages;\n  public boolean allowLegacyJsMessages;\n  public boolean strictMessageReplacement;\n  public boolean checkSuspiciousCode;\n  public boolean checkControlStructures;\n  public CheckLevel checkUndefinedProperties;\n  public boolean checkUnusedPropertiesEarly;\n  public boolean checkTypes;\n  public boolean tightenTypes;\n  public boolean inferTypesInGlobalScope;\n  public boolean checkTypedPropertyCalls;\n  public CheckLevel reportMissingOverride;\n  public CheckLevel reportUnknownTypes;\n  public CheckLevel checkRequires;\n  public CheckLevel checkProvides;\n  public CheckLevel checkGlobalNamesLevel;\n  public CheckLevel brokenClosureRequiresLevel;\n  public CheckLevel checkGlobalThisLevel;\n  public CheckLevel checkMissingGetCssNameLevel;\n  public String checkMissingGetCssNameBlacklist;\n  public boolean checkEs5Strict;\n  public boolean checkCaja;\n  public boolean foldConstants;\n  public boolean removeConstantExpressions;\n  public boolean deadAssignmentElimination;\n  public boolean inlineConstantVars;\n  public boolean inlineFunctions;\n  public boolean decomposeExpressions;\n  public boolean inlineAnonymousFunctionExpressions;\n  public boolean inlineLocalFunctions;\n  public boolean crossModuleCodeMotion;\n  public boolean coalesceVariableNames;\n  public boolean crossModuleMethodMotion;\n  public boolean inlineGetters;\n  public boolean inlineVariables;\n  public boolean inlineLocalVariables;\n  public boolean flowSensitiveInlineVariables;\n  public boolean smartNameRemoval;\n  public boolean removeDeadCode;\n  public CheckLevel checkUnreachableCode;\n  public CheckLevel checkMissingReturn;\n  public boolean extractPrototypeMemberDeclarations;\n  public boolean removeEmptyFunctions;\n  public boolean removeUnusedPrototypeProperties;\n  public boolean removeUnusedPrototypePropertiesInExterns;\n  public boolean removeUnusedVars;\n  public boolean removeUnusedVarsInGlobalScope;\n  public boolean aliasExternals;\n  public String aliasableGlobals;\n  public String unaliasableGlobals;\n  public boolean collapseVariableDeclarations;\n  public boolean groupVariableDeclarations;\n  public boolean collapseAnonymousFunctions;\n  public Set<String> aliasableStrings;\n  public String aliasStringsBlacklist;\n  public boolean aliasAllStrings;\n  public boolean convertToDottedProperties;\n  public boolean rewriteFunctionExpressions;\n  public boolean optimizeParameters;\n  public boolean optimizeArgumentsArray;\n  public VariableRenamingPolicy variableRenaming;\n  public PropertyRenamingPolicy propertyRenaming;\n  public boolean labelRenaming;\n  public boolean reserveRawExports;\n  public boolean generatePseudoNames;\n  public String renamePrefix;\n  public boolean aliasKeywords;\n  public boolean collapseProperties;\n  public boolean devirtualizePrototypeMethods;\n  public boolean computeFunctionSideEffects;\n  public String debugFunctionSideEffectsPath;\n  public boolean disambiguateProperties;\n  public boolean ambiguateProperties;\n  public AnonymousFunctionNamingPolicy anonymousFunctionNaming;\n  public byte[] inputVariableMapSerialized;\n  public byte[] inputPropertyMapSerialized;\n  public boolean exportTestFunctions;\n  private CodingConvention codingConvention;\n  public boolean instrumentForCoverage;\n  public boolean instrumentForCoverageOnly;\n  public boolean ignoreCajaProperties;\n  public String syntheticBlockStartMarker;\n  public String syntheticBlockEndMarker;\n  public String locale;\n  public boolean markAsCompiled;\n  public boolean removeTryCatchFinally;\n  public boolean closurePass;\n  public boolean gatherCssNames;\n  public Set<String> stripTypes;\n  public Set<String> stripNameSuffixes;\n  public Set<String> stripNamePrefixes;\n  public Set<String> stripTypePrefixes;\n  public boolean markNoSideEffectCalls;\n  private Map<String, Object> defineReplacements;\n  public boolean moveFunctionDeclarations;\n  public String instrumentationTemplate;\n  public String appNameStr;\n  public boolean recordFunctionInformation;\n  public boolean generateExports;\n  public CssRenamingMap cssRenamingMap;\n  public boolean prettyPrint;\n  public boolean lineBreak;\n  public boolean printInputDelimiter;\n  public String inputDelimiter = \"// Input %num%\";\n  public String reportPath;\n  public TracerMode tracer;\n  private boolean colorizeErrorOutput;\n  public ErrorFormat errorFormat;\n  public String jsOutputFile;\n  private transient ComposeWarningsGuard warningsGuard;\n  private boolean externExports;\n  public String nameReferenceReportPath;\n  public String nameReferenceGraphPath;\n  public String sourceMapOutputPath;\n  public Charset outputCharset;\n  /**\n   * Returns the map of define replacements.\n   */\n  public Map<String, Node> getDefineReplacements();\n  public boolean isExternExportsEnabled();\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private Appendable out;\n  private final PrintStream err;\n  private A compiler;\n  private static Charset inputCharset;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  /**\n   * Returns the instance of the Options to use when {@link #run()} is called.\n   * createCompiler() is called before createOptions(), so getCompiler()\n   * will not return null when createOptions() is called.\n   */\n  protected abstract B createOptions();\n\n  protected DiagnosticGroups getDiagnosticGroups();\n  /**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */\n  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException;\n  /**\n   * Parses command-line arguments and runs the compiler.\n   *\n   * @return system exit status\n   */\n  protected int doRun() throws FlagUsageException, IOException;\n  /**\n   * Query the flag for the input charset, and return a Charset object\n   * representing the selection.\n   *\n   * @return Charset to use when reading inputs\n   * @throws FlagUsageException if flag is not a valid Charset name.\n   */\n  private Charset getInputCharset() throws FlagUsageException;\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n}\n/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n*\n*\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean normalized = false;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  public Node parse(JSSourceFile file);\n  CompilerOptions getOptions();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Returns the root node of the AST, which includes both externs and source.\n   */\n  public Node getRoot();\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n}\n/**\n * Compiler options\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class CompilerOptions implements Serializable, Cloneable {\n  private static final long serialVersionUID = 7L;\n  public boolean ideMode;\n  public transient MessageBundle messageBundle = null;\n  public boolean checkSymbols;\n  public CheckLevel checkShadowVars;\n  public CheckLevel aggressiveVarCheck;\n  public CheckLevel checkFunctions;\n  public CheckLevel checkMethods;\n  public boolean checkDuplicateMessages;\n  public boolean allowLegacyJsMessages;\n  public boolean strictMessageReplacement;\n  public boolean checkSuspiciousCode;\n  public boolean checkControlStructures;\n  public CheckLevel checkUndefinedProperties;\n  public boolean checkUnusedPropertiesEarly;\n  public boolean checkTypes;\n  public boolean tightenTypes;\n  public boolean inferTypesInGlobalScope;\n  public boolean checkTypedPropertyCalls;\n  public CheckLevel reportMissingOverride;\n  public CheckLevel reportUnknownTypes;\n  public CheckLevel checkRequires;\n  public CheckLevel checkProvides;\n  public CheckLevel checkGlobalNamesLevel;\n  public CheckLevel brokenClosureRequiresLevel;\n  public CheckLevel checkGlobalThisLevel;\n  public CheckLevel checkMissingGetCssNameLevel;\n  public String checkMissingGetCssNameBlacklist;\n  public boolean checkEs5Strict;\n  public boolean checkCaja;\n  public boolean foldConstants;\n  public boolean removeConstantExpressions;\n  public boolean deadAssignmentElimination;\n  public boolean inlineConstantVars;\n  public boolean inlineFunctions;\n  public boolean decomposeExpressions;\n  public boolean inlineAnonymousFunctionExpressions;\n  public boolean inlineLocalFunctions;\n  public boolean crossModuleCodeMotion;\n  public boolean coalesceVariableNames;\n  public boolean crossModuleMethodMotion;\n  public boolean inlineGetters;\n  public boolean inlineVariables;\n  public boolean inlineLocalVariables;\n  public boolean flowSensitiveInlineVariables;\n  public boolean smartNameRemoval;\n  public boolean removeDeadCode;\n  public CheckLevel checkUnreachableCode;\n  public CheckLevel checkMissingReturn;\n  public boolean extractPrototypeMemberDeclarations;\n  public boolean removeEmptyFunctions;\n  public boolean removeUnusedPrototypeProperties;\n  public boolean removeUnusedPrototypePropertiesInExterns;\n  public boolean removeUnusedVars;\n  public boolean removeUnusedVarsInGlobalScope;\n  public boolean aliasExternals;\n  public String aliasableGlobals;\n  public String unaliasableGlobals;\n  public boolean collapseVariableDeclarations;\n  public boolean groupVariableDeclarations;\n  public boolean collapseAnonymousFunctions;\n  public Set<String> aliasableStrings;\n  public String aliasStringsBlacklist;\n  public boolean aliasAllStrings;\n  public boolean convertToDottedProperties;\n  public boolean rewriteFunctionExpressions;\n  public boolean optimizeParameters;\n  public boolean optimizeArgumentsArray;\n  public VariableRenamingPolicy variableRenaming;\n  public PropertyRenamingPolicy propertyRenaming;\n  public boolean labelRenaming;\n  public boolean reserveRawExports;\n  public boolean generatePseudoNames;\n  public String renamePrefix;\n  public boolean aliasKeywords;\n  public boolean collapseProperties;\n  public boolean devirtualizePrototypeMethods;\n  public boolean computeFunctionSideEffects;\n  public String debugFunctionSideEffectsPath;\n  public boolean disambiguateProperties;\n  public boolean ambiguateProperties;\n  public AnonymousFunctionNamingPolicy anonymousFunctionNaming;\n  public byte[] inputVariableMapSerialized;\n  public byte[] inputPropertyMapSerialized;\n  public boolean exportTestFunctions;\n  private CodingConvention codingConvention;\n  public boolean instrumentForCoverage;\n  public boolean instrumentForCoverageOnly;\n  public boolean ignoreCajaProperties;\n  public String syntheticBlockStartMarker;\n  public String syntheticBlockEndMarker;\n  public String locale;\n  public boolean markAsCompiled;\n  public boolean removeTryCatchFinally;\n  public boolean closurePass;\n  public boolean gatherCssNames;\n  public Set<String> stripTypes;\n  public Set<String> stripNameSuffixes;\n  public Set<String> stripNamePrefixes;\n  public Set<String> stripTypePrefixes;\n  public boolean markNoSideEffectCalls;\n  private Map<String, Object> defineReplacements;\n  public boolean moveFunctionDeclarations;\n  public String instrumentationTemplate;\n  public String appNameStr;\n  public boolean recordFunctionInformation;\n  public boolean generateExports;\n  public CssRenamingMap cssRenamingMap;\n  public boolean prettyPrint;\n  public boolean lineBreak;\n  public boolean printInputDelimiter;\n  public String inputDelimiter = \"// Input %num%\";\n  public String reportPath;\n  public TracerMode tracer;\n  private boolean colorizeErrorOutput;\n  public ErrorFormat errorFormat;\n  public String jsOutputFile;\n  private transient ComposeWarningsGuard warningsGuard;\n  private boolean externExports;\n  public String nameReferenceReportPath;\n  public String nameReferenceGraphPath;\n  public String sourceMapOutputPath;\n  public Charset outputCharset;\n  /**\n   * Returns the map of define replacements.\n   */\n  public Map<String, Node> getDefineReplacements();\n  public boolean isExternExportsEnabled();\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private Appendable out;\n  private final PrintStream err;\n  private A compiler;\n  private static Charset inputCharset;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  /**\n   * Returns the instance of the Options to use when {@link #run()} is called.\n   * createCompiler() is called before createOptions(), so getCompiler()\n   * will not return null when createOptions() is called.\n   */\n  protected abstract B createOptions();\n\n  protected DiagnosticGroups getDiagnosticGroups();\n  /**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */\n  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException;\n  /**\n   * Parses command-line arguments and runs the compiler.\n   *\n   * @return system exit status\n   */\n  protected int doRun() throws FlagUsageException, IOException;\n  /**\n   * Query the flag for the input charset, and return a Charset object\n   * representing the selection.\n   *\n   * @return Charset to use when reading inputs\n   * @throws FlagUsageException if flag is not a valid Charset name.\n   */\n  private Charset getInputCharset() throws FlagUsageException;\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n}\n/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  @Override\n  protected CompilerOptions createOptions();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n  }\n  private Compiler compile(String[] original) {\n    args.add(\"--js_output_file\");\n    args.add(\"/path/to/out.js\");\n\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    lastCommandLineRunner = runner;\n    lastCompiler = compiler;\n    CompilerOptions options = runner.createOptions();\n    try {\n      runner.setRunOptions(options);\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n      fail(\"Unexpected exception \" + e);\n    } catch (IOException e) {\n      assert(false);\n    }\n    if (useModules != ModulePattern.NONE) {\n      compiler.compile(\n          externs,\n          useModules == ModulePattern.STAR ?\n              CompilerTestCase.createModuleStar(original) :\n              CompilerTestCase.createModuleChain(original),\n          options);\n    } else {\n      JSSourceFile[] inputs = new JSSourceFile[original.length];\n      for (int i = 0; i < original.length; i++) {\n        inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n      }\n      compiler.compile(\n          externs,\n          inputs,\n          options);\n    }\n    return compiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testCharSetExpansion() {\n    testSame(\"\");\n    assertEquals(\"US-ASCII\", lastCompiler.getOptions().outputCharset);\n    args.add(\"--charset=UTF-8\");\n    testSame(\"\");\n    assertEquals(\"UTF-8\", lastCompiler.getOptions().outputCharset);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void noInline(String input) {\n    inline(input, input);\n  }\n  private void inline(String input, String expected) {\n    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n        \"function _func() {\" + expected + \"}\", null, null);\n  }\n  public void testSimpleForIn() {\n    inline(\"var a,b,x = a in b; x\",\n           \"var a,b,x; a in b\");\n    noInline(\"var a, b; var x = a in b; print(1); x\");\n    noInline(\"var a,b,x = a in b; delete a[b]; x\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private JSType findNameType(final String name, Scope scope) {\n    return findTypeOnMatchedNode(new Predicate<Node>() {\n      @Override public boolean apply(Node n) {\n        return name.equals(n.getQualifiedName());\n      }\n    }, scope);\n  }\n  private JSType findTokenType(final int type, Scope scope) {\n    return findTypeOnMatchedNode(new Predicate<Node>() {\n      @Override public boolean apply(Node n) {\n        return type == n.getType();\n      }\n    }, scope);\n  }\n  private JSType findTypeOnMatchedNode(Predicate<Node> matcher, Scope scope) {\n    Node root = scope.getRootNode();\n    Deque<Node> queue = Lists.newLinkedList();\n    queue.push(root);\n    while (!queue.isEmpty()) {\n      Node current = queue.pop();\n      if (matcher.apply(current) &&\n          current.getJSType() != null) {\n        return current.getJSType();\n      }\n\n      for (Node child : current.children()) {\n        queue.push(child);\n      }\n    }\n    return null;\n  }\n  private JSType getNativeType(JSTypeNative type) {\n    return registry.getNativeType(type);\n  }\n  private ObjectType getNativeObjectType(JSTypeNative type) {\n    return (ObjectType) registry.getNativeType(type);\n  }\n  private void assertTypeEquals(String s, JSType type) {\n    assertEquals(s, type.toString());\n  }\n  public void testNamespacedFunctionStubLocal() {\n    testSame(\n        \"(function() {\" +\n        \"var goog = {};\" +\n        \"/** @param {number} x */ goog.foo;\" +\n        \"});\");\n\n    ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope);\n    assertTrue(goog.hasProperty(\"foo\"));\n    assertEquals(\"function (number): ?\", goog.getPropertyType(\"foo\").toString());\n    assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n\n    assertEquals(lastLocalScope.getVar(\"goog.foo\").getType(), goog.getPropertyType(\"foo\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  private void initConfigFromFlags(String[] args, PrintStream err);\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  private void initConfigFromFlags(String[] args, PrintStream err);\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected Compiler createCompiler();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    args.add(\"--js_output_file\");\n    args.add(\"/path/to/out.js\");\n\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testVersionFlag() {\n    args.add(\"--version\");\n    testSame(\"\");\n    assertEquals( 0, new String(errReader.toByteArray()).indexOf( \"Closure Compiler (http://code.google.com/p/closure/compiler)\\n\" + \"Version: HEAD\\n\" + \"Built on:\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean hasProperty(String name);\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public JSType getPropertyType(String name);\n  @Override\n  public boolean isConstructor();\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public boolean hasProperty(String name);\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public JSType getPropertyType(String name);\n  @Override\n  public boolean isConstructor();\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testBackwardsTypedefUse1() throws Exception {\n    testTypes(\n        \"/** @this {MyTypedef} */ function f() {}\" +\n        \"/** @typedef {string} */ var MyTypedef;\",\n        \"@this type of a function must be an object\\n\" +\n        \"Actual type: string\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n}\n/**\n * <p>The syntactic scope creator scans the parse tree to create a Scope object\n * containing all the variable declarations in that scope.</p>\n *\n * <p>This implementation is not thread-safe.</p>\n *\n */\nclass SyntacticScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private Scope scope;\n  private String sourceName;\n  private final RedeclarationHandler redeclarationHandler;\n  private static final String ARGUMENTS = \"arguments\";\n  public Scope createScope(Node n, Scope parent);\n  /**\n   * Scans and gather variables declarations under a Node\n   */\n  private void scanVars(Node n, Node parent);\n  private void scanRoot(Node n, Scope parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n}\n/**\n * <p>The syntactic scope creator scans the parse tree to create a Scope object\n * containing all the variable declarations in that scope.</p>\n *\n * <p>This implementation is not thread-safe.</p>\n *\n */\nclass SyntacticScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private Scope scope;\n  private String sourceName;\n  private final RedeclarationHandler redeclarationHandler;\n  private static final String ARGUMENTS = \"arguments\";\n  public Scope createScope(Node n, Scope parent);\n  /**\n   * Scans and gather variables declarations under a Node\n   */\n  private void scanVars(Node n, Node parent);\n  private void scanRoot(Node n, Scope parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private String inFunction(String code) {\n    return \"(function(){\" + code + \"})\";\n  }\n  private void testSameInFunction(String code) {\n    testSame(inFunction(code));\n  }\n  private void testInFunction(String code, String expected) {\n    test(inFunction(code), inFunction(expected));\n  }\n  private Set<Node> findNodesWithProperty(Node root, final int prop) {\n    final Set<Node> set = Sets.newHashSet();\n    NodeTraversal.traverse(\n        getLastCompiler(), root, new AbstractPostOrderCallback() {\n        public void visit(NodeTraversal t, Node node, Node parent) {\n          if (node.getBooleanProp(prop)) {\n            set.add(node);\n          }\n        }\n      });\n    return set;\n  }\n    private void testConstantProperties() {\n      test(\"var a={}; a.ACONST = 4;var b = a.ACONST;\",\n           \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;\",\n           \"var a$b$ACONST = 4;var b = a$b$ACONST;\");\n\n      test(\"var a = {FOO: 1};var b = a.FOO;\",\n           \"var a$FOO = 1; var b = a$FOO;\");\n\n      test(\"var EXTERN; var ext; ext.FOO;\", \"var b = EXTERN; var c = ext.FOO\",\n           \"var b = EXTERN; var c = ext.FOO\", null, null);\n\n      test(\"var a={}; a.ACONST = 4; var b = a.ACONST;\",\n           \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a = {}; function foo() { var d = a.CONST; };\" +\n           \"(function(){a.CONST=4})();\",\n           \"var a$CONST;function foo(){var d = a$CONST;};\" +\n           \"(function(){a$CONST = 4})();\");\n\n      test(\"var a = {}; a.ACONST = new Foo(); var b = a.ACONST;\",\n           \"var a$ACONST = new Foo(); var b = a$ACONST;\");\n    }\n  public void testDuplicateVarInExterns() {\n    test(\"var extern;\",\n         \"/** @suppress {duplicate} */ var extern = 3;\", \"var extern = 3;\",\n         null, null);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop);\n  /**\n   * Gets a list of type violations.\n   *\n   * For each violation, one element is the expected type and the other is\n   * the type that is actually found. Order is not signficant.\n   */\n  Iterable<TypeMismatch> getMismatches();\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /** Turn on the missing property check. Returns this for easy chaining. */\n  TypeCheck reportMissingProperties(boolean report);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   */\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType);\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop);\n  /**\n   * Gets a list of type violations.\n   *\n   * For each violation, one element is the expected type and the other is\n   * the type that is actually found. Order is not signficant.\n   */\n  Iterable<TypeMismatch> getMismatches();\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /** Turn on the missing property check. Returns this for easy chaining. */\n  TypeCheck reportMissingProperties(boolean report);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   */\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType);\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testInterfaceInheritanceCheck12() throws Exception {\n    testTypes(\n        \"/** @interface */ function I() {};\\n\" +\n        \"/** @type {string} */ I.prototype.foobar;\\n\" +\n        \"/** \\n * @constructor \\n * @implements {I} */\\n\" +\n        \"function C() {\\n\" +\n        \"/** \\n * @type {number} */ this.foobar = 2;};\\n\" +\n        \"/** @type {I} */ \\n var test = new C(); alert(test.foobar);\",\n        \"mismatch of the foobar property type and the type of the property\" +\n        \" it overrides from interface I\\n\" +\n        \"original: string\\n\" +\n        \"override: number\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n/**\n * Scope contains information about a variable scope in javascript.\n * Scopes can be nested, a scope points back to its parent scope.\n * A Scope contains information about variables defined in that scope.\n * <p>\n * A Scope is also used as a lattice element for flow-sensitive type inference.\n * As a lattice element, a Scope is viewed as a map from names to types. A name\n * not in the map is considered to have the bottom type. The join of two maps m1\n * and m2 is the map of the union of names with {@link JSType#getLeastSupertype}\n * to meet the m1 type and m2 type.\n *\n * @see NodeTraversal\n * @see DataFlowAnalysis\n *\n */\npublic class Scope implements StaticScope<JSType> {\n  private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n  private final Scope parent;\n  private final int depth;\n  private final Node rootNode;\n  private final ObjectType thisType;\n  private final boolean isBottom;\n  /**\n   * Return an iterator over all of the variables declared in this scope.\n   */\n  public Iterator<Var> getVars();\n  /**\n   * Returns the variable, may be null\n   */\n  public Var getVar(String name);\n  /** The depth of the scope. The global scope has depth 0. */\n  int getDepth();\n}\n/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n  /**\n   * Gets the reference collection for the given variable.\n   */\n  public ReferenceCollection getReferenceCollection(Var v);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n}\n/**\n * Scope contains information about a variable scope in javascript.\n * Scopes can be nested, a scope points back to its parent scope.\n * A Scope contains information about variables defined in that scope.\n * <p>\n * A Scope is also used as a lattice element for flow-sensitive type inference.\n * As a lattice element, a Scope is viewed as a map from names to types. A name\n * not in the map is considered to have the bottom type. The join of two maps m1\n * and m2 is the map of the union of names with {@link JSType#getLeastSupertype}\n * to meet the m1 type and m2 type.\n *\n * @see NodeTraversal\n * @see DataFlowAnalysis\n *\n */\npublic class Scope implements StaticScope<JSType> {\n  private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n  private final Scope parent;\n  private final int depth;\n  private final Node rootNode;\n  private final ObjectType thisType;\n  private final boolean isBottom;\n  /**\n   * Return an iterator over all of the variables declared in this scope.\n   */\n  public Iterator<Var> getVars();\n  /**\n   * Returns the variable, may be null\n   */\n  public Var getVar(String name);\n  /** The depth of the scope. The global scope has depth 0. */\n  int getDepth();\n}\n/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n  /**\n   * Gets the reference collection for the given variable.\n   */\n  public ReferenceCollection getReferenceCollection(Var v);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testArgumentsModifiedInInnerFunction() {\n    test(\n      \"function g(callback) {\\n\" +\n      \"  var f = callback;\\n\" +\n      \"  f.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\",\n      \"function g(callback) {\\n\" +\n      \"  callback.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a FUNCTION node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateFunctionDeclarationAtFunctionNode(Name n);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at an ASSIGN node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias);\n  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref);\n  /**\n   * Warns about any references to \"this\" in the given FUNCTION. The function\n   * is getting collapsed, so the references will change.\n   */\n  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name.\n   * This involves flattening the global name (if it's not just a global\n   * variable name already), collapsing object literal keys into global\n   * variables, declaring stub global variables for properties added later\n   * in a local scope.\n   *\n   * It may seem odd that this function also takes care of declaring stubs\n   * for direct children. The ultimate goal of this function is to eliminate\n   * the global name entirely (when possible), so that \"middlemen\" namespaces\n   * disappear, and to do that we need to make sure that all the direct children\n   * will be collapsed as well.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   * @param canCollapseChildNames Whether it's possible to collapse children of\n   *     this name. (This is mostly passed for convenience; it's equivalent to\n   *     n.canCollapseChildNames()).\n   */\n  private void updateObjLitOrFunctionDeclaration(Name n, String alias);\n  /**\n   * Collapses definitions of the collapsible properties of a global name.\n   * Recurses on subnames that also represent JavaScript objects with\n   * collapsible properties.\n   *\n   * @param n A node representing a global name\n   * @param alias The flattened name for {@code n}\n   */\n  private void collapseDeclarationOfNameAndDescendants(Name n, String alias);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a VAR node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a FUNCTION node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateFunctionDeclarationAtFunctionNode(Name n);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at an ASSIGN node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias);\n  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref);\n  /**\n   * Warns about any references to \"this\" in the given FUNCTION. The function\n   * is getting collapsed, so the references will change.\n   */\n  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name.\n   * This involves flattening the global name (if it's not just a global\n   * variable name already), collapsing object literal keys into global\n   * variables, declaring stub global variables for properties added later\n   * in a local scope.\n   *\n   * It may seem odd that this function also takes care of declaring stubs\n   * for direct children. The ultimate goal of this function is to eliminate\n   * the global name entirely (when possible), so that \"middlemen\" namespaces\n   * disappear, and to do that we need to make sure that all the direct children\n   * will be collapsed as well.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   * @param canCollapseChildNames Whether it's possible to collapse children of\n   *     this name. (This is mostly passed for convenience; it's equivalent to\n   *     n.canCollapseChildNames()).\n   */\n  private void updateObjLitOrFunctionDeclaration(Name n, String alias);\n  /**\n   * Collapses definitions of the collapsible properties of a global name.\n   * Recurses on subnames that also represent JavaScript objects with\n   * collapsible properties.\n   *\n   * @param n A node representing a global name\n   * @param alias The flattened name for {@code n}\n   */\n  private void collapseDeclarationOfNameAndDescendants(Name n, String alias);\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a VAR node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testAliasedTopLevelEnum() {\n    test(\n        \"function alias() {}\" +\n        \"var dojo = {};\" +\n        \"dojo.gfx = {};\" +\n        \"dojo.declare = function() {};\" +\n        \"/** @enum {number} */\" +\n        \"dojo.gfx.Shape = {SQUARE: 2};\" +\n        \"dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');\" +\n        \"alias(dojo);\" +\n        \"alias(dojo.gfx.Shape.SQUARE);\",\n        \"function alias() {}\" +\n        \"var dojo = {};\" +\n        \"dojo.gfx = {};\" +\n        \"dojo.declare = function() {};\" +\n        \"/** @constructor */\" +\n        \"var dojo$gfx$Shape = {SQUARE: 2};\" +\n        \"dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');\" +\n        \"alias(dojo);\" +\n        \"alias(dojo$gfx$Shape.SQUARE);\",\n        null,\n        CollapseProperties.UNSAFE_NAMESPACE_WARNING);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n  private Node transformNameAsString(Name node);\n}\n/**\n * RenamePrototypes renames custom properties (including methods) of custom\n * prototypes and object literals. Externed property names are never renamed.\n *\n * To ensure that a prototype property or object literal property gets renamed,\n * end it with an underscore.\n *\n * To ensure that a prototype property is not renamed, give it a leading\n * underscore.\n *\n * For custom prototype property names that lack leading and trailing\n * underscores:\n * - To always rename these, use aggressive renaming.\n * - If aggresive renaming is off, we use a heuristic to decide whether to\n *   rename (to avoid most built-in js methods). We rename if the original name\n *   contains at least one character that is not a lowercase letter.\n *\n * When a property name is used both in a prototype definition and as an object\n * literal key, we rename it only if it satisifies both renaming policies.\n *\n */\nclass RenamePrototypes implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean aggressiveRenaming;\n  private final char[] reservedCharacters;\n  private final VariableMap prevUsedRenameMap;\n  /**\n   * Runs through the list of properties and tries to rename as many as possible\n   * with names that were used for them in the previous compilation.\n   * {@code reservedNames} is updated with the set of reused names.\n   * @param properties The set of properties to attempt to rename.\n   */\n  private void reusePrototypeNames(Set<Property> properties);\n}\n/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  void add(Node n, Context context);\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n  private Node transformNameAsString(Name node);\n}\n/**\n * RenamePrototypes renames custom properties (including methods) of custom\n * prototypes and object literals. Externed property names are never renamed.\n *\n * To ensure that a prototype property or object literal property gets renamed,\n * end it with an underscore.\n *\n * To ensure that a prototype property is not renamed, give it a leading\n * underscore.\n *\n * For custom prototype property names that lack leading and trailing\n * underscores:\n * - To always rename these, use aggressive renaming.\n * - If aggresive renaming is off, we use a heuristic to decide whether to\n *   rename (to avoid most built-in js methods). We rename if the original name\n *   contains at least one character that is not a lowercase letter.\n *\n * When a property name is used both in a prototype definition and as an object\n * literal key, we rename it only if it satisifies both renaming policies.\n *\n */\nclass RenamePrototypes implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean aggressiveRenaming;\n  private final char[] reservedCharacters;\n  private final VariableMap prevUsedRenameMap;\n  /**\n   * Runs through the list of properties and tries to rename as many as possible\n   * with names that were used for them in the previous compilation.\n   * {@code reservedNames} is updated with the set of reused names.\n   * @param properties The set of properties to attempt to rename.\n   */\n  private void reusePrototypeNames(Set<Property> properties);\n}\n/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  void add(Node n, Context context);\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testObjectLit2() {\n    assertPrint(\"var x={1:1}\", \"var x={1:1}\");\n    assertPrint(\"var x={'1':1}\", \"var x={1:1}\");\n    assertPrint(\"var x={'1.0':1}\", \"var x={\\\"1.0\\\":1}\");\n    assertPrint(\"var x={1.5:1}\", \"var x={\\\"1.5\\\":1}\");\n\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Named groups of DiagnosticTypes exposed by Compiler.\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class DiagnosticGroups {\n  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group);\n  /** Find the diagnostic group registered under the given name. */\n  protected DiagnosticGroup forName(String name);\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private Appendable out;\n  private final PrintStream err;\n  private A compiler;\n  private Charset inputCharset;\n  private String outputCharset;\n  private boolean testMode = false;\n  private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;\n  private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null;\n  private Supplier<List<JSModule>> modulesSupplierForTesting = null;\n  private Function<Integer, Boolean> exitCodeReceiverForTesting = null;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private static final String OUTPUT_WRAPPER_MARKER = \"%output%\";\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  /**\n   * Runs the Compiler and calls System.exit() with the exit status of the\n   * compiler.\n   */\n  final public void run();\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n  /**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */\n  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException;\n  /**\n   * Put the command line runner into test mode. In test mode,\n   * all outputs will be blackholed.\n   * @param externsSupplier A provider for externs.\n   * @param inputsSupplier A provider for source inputs.\n   * @param modulesSupplier A provider for modules. Only one of inputsSupplier\n   *     and modulesSupplier may be non-null.\n   * @param exitCodeReceiver A receiver for the status code that would\n   *     have been passed to System.exit in non-test mode.\n   */\n  @VisibleForTesting\n  void enableTestMode(\n      Supplier<List<JSSourceFile>> externsSupplier,\n      Supplier<List<JSSourceFile>> inputsSupplier,\n      Supplier<List<JSModule>> modulesSupplier,\n      Function<Integer, Boolean> exitCodeReceiver);\n  final protected A getCompiler();\n}\n/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class\n * directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n *\n * This class is totally not thread-safe.\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  private void initConfigFromFlags(String[] args, PrintStream err);\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n      IOException;\n  @Override\n  protected Compiler createCompiler();\n  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException;\n  private List<String> processArgs(String[] args);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Named groups of DiagnosticTypes exposed by Compiler.\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class DiagnosticGroups {\n  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group);\n  /** Find the diagnostic group registered under the given name. */\n  protected DiagnosticGroup forName(String name);\n}\n/**\n * Implementations of AbstractCommandLineRunner translate flags into Java\n * API calls on the Compiler. AbstractCompiler contains common flags and logic\n * to make that happen.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. Example:\n *\n * <pre>\n * class MyCommandLineRunner extends\n *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   &#064;Override\n *   protected MyOptions createOptions() {\n *     MyOptions options = new MyOptions();\n *     CompilerFlagTranslator.setOptionsFromFlags(options);\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   &#064;Override\n *   protected MyCompiler createCompiler() {\n *     return new MyCompiler();\n *   }\n *\n *   public static void main(String[] args) {\n *     (new MyCommandLineRunner(args)).run();\n *   }\n * }\n * </pre>\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\nabstract class AbstractCommandLineRunner<A extends Compiler,\n    B extends CompilerOptions> {\n  private final CommandLineConfig config;\n  private Appendable out;\n  private final PrintStream err;\n  private A compiler;\n  private Charset inputCharset;\n  private String outputCharset;\n  private boolean testMode = false;\n  private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;\n  private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null;\n  private Supplier<List<JSModule>> modulesSupplierForTesting = null;\n  private Function<Integer, Boolean> exitCodeReceiverForTesting = null;\n  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n  private static final String OUTPUT_WRAPPER_MARKER = \"%output%\";\n  private final RunTimeStats runTimeStats = new RunTimeStats();\n  /**\n   * Runs the Compiler and calls System.exit() with the exit status of the\n   * compiler.\n   */\n  final public void run();\n  /**\n   * Returns the instance of the Compiler to use when {@link #run()} is\n   * called.\n   */\n  protected abstract A createCompiler();\n\n  /**\n   * Returns the instance of the Options to use when @link #run()} is called.;\n  /**\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or intepret flags your own way,\n   * then you should override this method.\n   */\n  final protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException;\n  /**\n   * Put the command line runner into test mode. In test mode,\n   * all outputs will be blackholed.\n   * @param externsSupplier A provider for externs.\n   * @param inputsSupplier A provider for source inputs.\n   * @param modulesSupplier A provider for modules. Only one of inputsSupplier\n   *     and modulesSupplier may be non-null.\n   * @param exitCodeReceiver A receiver for the status code that would\n   *     have been passed to System.exit in non-test mode.\n   */\n  @VisibleForTesting\n  void enableTestMode(\n      Supplier<List<JSSourceFile>> externsSupplier,\n      Supplier<List<JSSourceFile>> inputsSupplier,\n      Supplier<List<JSModule>> modulesSupplier,\n      Function<Integer, Boolean> exitCodeReceiver);\n  final protected A getCompiler();\n}\n/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class\n * directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n *\n * This class is totally not thread-safe.\n *\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  private void initConfigFromFlags(String[] args, PrintStream err);\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n      IOException;\n  @Override\n  protected Compiler createCompiler();\n  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException;\n  private List<String> processArgs(String[] args);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testWarningGuardOrdering2() {\n    args.add(\"--jscomp_off=globalThis\");\n    args.add(\"--jscomp_error=globalThis\");\n    test(\"function f() { this.a = 3; }\", CheckGlobalThis.GLOBAL_THIS);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Inlines functions that are divided into two types: \"direct call node\n * replacement\" (aka \"direct\") and as a block of statements (aka block).\n * Function that can be inlined \"directly\" functions consist of a single\n * return statement, everything else is must be inlined as a \"block\". These\n * functions must meet these general requirements:\n * - it is not recursive\n * - the function does not contain another function -- these may be\n *   intentional to to limit the scope of closures.\n * - function is called only once OR the size of the inline function is smaller\n *   than the call itself.\n * - the function name is not referenced in any other manner\n *\n * \"directly\" inlined functions must meet these additional requirements:\n * - consists of a single return statement\n *\n */\nclass InlineFunctions implements SpecializationAwareCompilerPass {\n  private final Map<String, FunctionState> fns = Maps.newHashMap();\n  private final Map<Node, String> anonFns = Maps.newHashMap();\n  private final AbstractCompiler compiler;\n  private final FunctionInjector injector;\n  private final boolean blockFunctionInliningEnabled;\n  private final boolean inlineGlobalFunctions;\n  private final boolean inlineLocalFunctions;\n  private SpecializeModule.SpecializationState specializationState;\n  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Inlines functions that are divided into two types: \"direct call node\n * replacement\" (aka \"direct\") and as a block of statements (aka block).\n * Function that can be inlined \"directly\" functions consist of a single\n * return statement, everything else is must be inlined as a \"block\". These\n * functions must meet these general requirements:\n * - it is not recursive\n * - the function does not contain another function -- these may be\n *   intentional to to limit the scope of closures.\n * - function is called only once OR the size of the inline function is smaller\n *   than the call itself.\n * - the function name is not referenced in any other manner\n *\n * \"directly\" inlined functions must meet these additional requirements:\n * - consists of a single return statement\n *\n */\nclass InlineFunctions implements SpecializationAwareCompilerPass {\n  private final Map<String, FunctionState> fns = Maps.newHashMap();\n  private final Map<Node, String> anonFns = Maps.newHashMap();\n  private final AbstractCompiler compiler;\n  private final FunctionInjector injector;\n  private final boolean blockFunctionInliningEnabled;\n  private final boolean inlineGlobalFunctions;\n  private final boolean inlineLocalFunctions;\n  private SpecializeModule.SpecializationState specializationState;\n  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue423() {\n    test(\n        \"(function($) {\\n\" +\n        \"  $.fn.multicheck = function(options) {\\n\" +\n        \"    initialize.call(this, options);\\n\" +\n        \"  };\\n\" +\n        \"\\n\" +\n        \"  function initialize(options) {\\n\" +\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n        \"    preload_check_all.call(this);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  function preload_check_all() {\\n\" +\n        \"    $(this).data('checkboxes');\\n\" +\n        \"  }\\n\" +\n        \"})(jQuery)\",\n        \"(function($){\" +\n        \"  $.fn.multicheck=function(options$$1){\" +\n        \"    {\" +\n        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n        \"     {\" +\n        \"       $(this).data(\\\"checkboxes\\\")\" +\n        \"     }\" +\n        \"    }\" +\n        \"  }\" +\n        \"})(jQuery)\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue772() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.closurePass = true;\n    options.checkTypes = true;\n    test(\n        options,\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"goog.scope(function() {\" +\n        \"  var b = a.b;\" +\n        \"  var c = b.c;\" +\n        \"  /** @typedef {string} */\" +\n        \"  c.MyType;\" +\n        \"  /** @param {c.MyType} x The variable. */\" +\n        \"  c.myFunc = function(x) {};\" +\n        \"});\",\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"a.b.c.MyType;\" +\n        \"a.b.c.myFunc = function(x) {};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  private Result compile();\n  public void parse();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  @Override\n  public Node getRoot();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  public Node parse(JSSourceFile file);\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  private Result compile();\n  public void parse();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  @Override\n  public Node getRoot();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  public Node parse(JSSourceFile file);\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testCheckSymbolsOverrideForQuiet() {\n    args.add(\"--warning_level=QUIET\");\n    args.add(\"--jscomp_error=undefinedVars\");\n    test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private Node tryFoldArrayAccess(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private Node tryFoldArrayAccess(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);  // TODO: why is nothing done with this?\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        new JSSourceFile[] {},\n        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testIssue522() {\n    testSame(\"[][1] = 1;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Scope contains information about a variable scope in javascript.\n * Scopes can be nested, a scope points back to its parent scope.\n * A Scope contains information about variables defined in that scope.\n * <p>\n * A Scope is also used as a lattice element for flow-sensitive type inference.\n * As a lattice element, a Scope is viewed as a map from names to types. A name\n * not in the map is considered to have the bottom type. The join of two maps m1\n * and m2 is the map of the union of names with {@link JSType#getLeastSupertype}\n * to meet the m1 type and m2 type.\n *\n * @see NodeTraversal\n * @see DataFlowAnalysis\n *\n */\npublic class Scope\n    implements StaticScope<JSType>, StaticSymbolTable<Scope.Var, Scope.Var> {\n  private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n  private final Scope parent;\n  private final int depth;\n  private final Node rootNode;\n  private final ObjectType thisType;\n  private final boolean isBottom;\n  private Var arguments;\n  /**\n   * Return an iterator over all of the variables declared in this scope.\n   */\n  public Iterator<Var> getVars();\n}\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Scope contains information about a variable scope in javascript.\n * Scopes can be nested, a scope points back to its parent scope.\n * A Scope contains information about variables defined in that scope.\n * <p>\n * A Scope is also used as a lattice element for flow-sensitive type inference.\n * As a lattice element, a Scope is viewed as a map from names to types. A name\n * not in the map is considered to have the bottom type. The join of two maps m1\n * and m2 is the map of the union of names with {@link JSType#getLeastSupertype}\n * to meet the m1 type and m2 type.\n *\n * @see NodeTraversal\n * @see DataFlowAnalysis\n *\n */\npublic class Scope\n    implements StaticScope<JSType>, StaticSymbolTable<Scope.Var, Scope.Var> {\n  private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n  private final Scope parent;\n  private final int depth;\n  private final Node rootNode;\n  private final ObjectType thisType;\n  private final boolean isBottom;\n  private Var arguments;\n  /**\n   * Return an iterator over all of the variables declared in this scope.\n   */\n  public Iterator<Var> getVars();\n}\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testScoped(String code, String expected) {\n    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n  }\n  private void testScopedNoChanges(String aliases, String code) {\n    testScoped(aliases + code, code);\n  }\n  private void testTypes(String aliases, String code) {\n    testScopedNoChanges(aliases, code);\n    verifyTypes();\n  }\n  private void verifyTypes() {\n    Compiler lastCompiler = getLastCompiler();\n    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n        lastCompiler.jsRoot);\n  }\n  private void testFailure(String code, DiagnosticType expectedError) {\n    test(code, null, expectedError);\n  }\n  private void testScopedFailure(String code, DiagnosticType expectedError) {\n    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n  }\n  private void verifyAliasTransformationPosition(int startLine, int startChar,\n      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n    assertEquals(startLine, pos.getStartLine());\n    assertEquals(startChar, pos.getPositionOnStartLine());\n    assertTrue(\n        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n        pos.getEndLine() >= endLine);\n    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n  }\n  public void testForwardJsDoc() {\n    testScoped(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {Foo.Bar} x */ function actual(x) {3}\" +\n        \"var Foo = foo.Foo;\" +\n        \"/** @constructor */ Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\",\n\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"foo.Foo = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function actual(x) {3}\" +\n        \"/** @constructor */ foo.Foo.Bar = function() {};\" +\n        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\");\n    verifyTypes();\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Move prototype methods into later modules.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass CrossModuleMethodMotion implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final IdGenerator idGenerator;\n  private final AnalyzePrototypeProperties analyzer;\n  private final JSModuleGraph moduleGraph;\n}\n/**\n * Analyzes properties on prototypes.\n *\n * Uses a reference graph to analyze prototype properties. Each unique property\n * name is represented by a node in this graph. An edge from property A to\n * property B means that there's a GETPROP access of a property B on some\n * object inside of a method named A.\n *\n * Global functions are also represented by nodes in this graph, with\n * similar semantics.\n *\n */\nclass AnalyzePrototypeProperties implements CompilerPass {\n  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n  private final SymbolType VAR = SymbolType.VAR;\n  private final AbstractCompiler compiler;\n  private final boolean canModifyExterns;\n  private final boolean anchorUnusedVars;\n  private final JSModuleGraph moduleGraph;\n  private final JSModule firstModule;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Move prototype methods into later modules.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass CrossModuleMethodMotion implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final IdGenerator idGenerator;\n  private final AnalyzePrototypeProperties analyzer;\n  private final JSModuleGraph moduleGraph;\n}\n/**\n * Analyzes properties on prototypes.\n *\n * Uses a reference graph to analyze prototype properties. Each unique property\n * name is represented by a node in this graph. An edge from property A to\n * property B means that there's a GETPROP access of a property B on some\n * object inside of a method named A.\n *\n * Global functions are also represented by nodes in this graph, with\n * similar semantics.\n *\n */\nclass AnalyzePrototypeProperties implements CompilerPass {\n  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n  private final SymbolType VAR = SymbolType.VAR;\n  private final AbstractCompiler compiler;\n  private final boolean canModifyExterns;\n  private final boolean anchorUnusedVars;\n  private final JSModuleGraph moduleGraph;\n  private final JSModule firstModule;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue600b() {\n    testSame(\n        createModuleChain(\n            \"var jQuery1 = (function() {\\n\" +\n            \"  var jQuery2 = function() {};\\n\" +\n            \"  jQuery2.prototype = {\\n\" +\n            \"    size: function() {\\n\" +\n            \"      return 1;\\n\" +\n            \"    }\\n\" +\n            \"  };\\n\" +\n            \"  return jQuery2;\\n\" +\n            \"})();\\n\",\n\n            \"(function() {\" +\n            \"  var div = jQuery1('div');\" +\n            \"  div.size();\" +\n            \"})();\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The arrow type is an internal type that models the functional arrow type\n * seen in typical functional programming languages.  It is used soley for\n * separating the management of the arrow type from the complex\n * {@link FunctionType} that models JavaScript's notion of functions.\n */\nfinal class ArrowType extends JSType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   */\n  boolean hasEqualParameters(ArrowType that);\n  @Override\n  public boolean isSubtype(JSType other);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The arrow type is an internal type that models the functional arrow type\n * seen in typical functional programming languages.  It is used soley for\n * separating the management of the arrow type from the complex\n * {@link FunctionType} that models JavaScript's notion of functions.\n */\nfinal class ArrowType extends JSType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   */\n  boolean hasEqualParameters(ArrowType that);\n  @Override\n  public boolean isSubtype(JSType other);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry);\n  }\n  public void testMethodInference7() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"F.prototype.foo = function() { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n        \"mismatch of the foo property type and the type of the property \" +\n        \"it overrides from superclass F\\n\" +\n        \"original: function (this:F): undefined\\n\" +\n        \"override: function (this:G, ?, ?): undefined\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The type registry is used to resolve named types.\n *\n * <p>This class is not thread-safe.\n *\n */\npublic class JSTypeRegistry implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private static final int PROPERTY_CHECKING_UNION_SIZE = 3000;\n  private final transient ErrorReporter reporter;\n  private final JSType[] nativeTypes;\n  private final Map<String, JSType> namesToTypes;\n  private final Set<String> namespaces = new HashSet<String>();\n  private final Set<String> nonNullableTypeNames = new HashSet<String>();\n  private final Set<String> forwardDeclaredTypes = new HashSet<String>();\n  private boolean lastGeneration = true;\n  private String templateTypeName;\n  private TemplateType templateType;\n  private final boolean tolerateUndefinedValues;\n  /**\n   * Looks up a type by name.\n   *\n   * @param jsTypeName The name string.\n   * @return the corresponding JSType object or {@code null} it cannot be found\n   */\n  public JSType getType(String jsTypeName);\n  /**\n   * Looks up a type by name. To allow for forward references to types, an\n   * unrecognized string has to be bound to a NamedType object that will be\n   * resolved later.\n   *\n   * @param scope A scope for doing type name resolution.\n   * @param jsTypeName The name string.\n   * @param sourceName The name of the source file where this reference appears.\n   * @param lineno The line number of the reference.\n   * @return a NamedType if the string argument is not one of the known types,\n   *     otherwise the corresponding JSType object.\n   */\n  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno);\n  /**\n   * Returns whether the given property can possibly be set on the given type.\n   */\n  public boolean canPropertyBeDefined(JSType type, String propertyName);\n}\n/**\n * A builder for record types.\n *\n */\npublic class RecordTypeBuilder {\n  private boolean isEmpty = true;\n  private final JSTypeRegistry registry;\n  private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n  /**\n   * Adds a property with the given name and type to the record type.\n   * @param name the name of the new property\n   * @param type the JSType of the new property\n   * @param propertyNode the node that holds this property definition\n   * @return The builder itself for chaining purposes, or null if there's\n   *          a duplicate.\n   */\n  public RecordTypeBuilder addProperty(String name, JSType type, Node\n      propertyNode);\n}\n/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private boolean isFrozen = false;\n  JSType getGreatestSubtypeHelper(JSType that);\n  /** @return Is this synthesized for internal bookkeeping? */\n\n  @Override\n  public boolean isEquivalentTo(JSType other);\n}\n/**\n * Object type.\n *\n * In JavaScript, all object types have properties, and each of those\n * properties has a type. Property types may be DECLARED, INFERRED, or\n * UNKNOWN.\n *\n * DECLARED properties have an explicit type annotation, as in:\n * <code>\n * /xx @type {number} x/\n * Foo.prototype.bar = 1;\n * </code>\n * This property may only hold number values, and an assignment to any\n * other type of value is an error.\n *\n * INFERRED properties do not have an explicit type annotation. Rather,\n * we try to find all the possible types that this property can hold.\n * <code>\n * Foo.prototype.bar = 1;\n * </code>\n * If the programmer assigns other types of values to this property,\n * the property will take on the union of all these types.\n *\n * UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN\n * type has all properties, but we do not know whether they are\n * declared or inferred.\n *\n */\npublic abstract class ObjectType extends JSType implements StaticScope<JSType> {\n  private boolean visited;\n  private JSDocInfo docInfo = null;\n  private boolean unknown = true;\n  /**\n   * Gets the number of properties of this object.\n   */\n  public abstract int getPropertiesCount();\n\n  /**\n   * Returns a list of properties defined or inferred on this type and any of\n   * its supertypes.\n   */\n  public Set<String> getPropertyNames();\n  /**\n   * Defines a property whose type is explicitly declared by the programmer.\n   * @param propertyName the property's name\n   * @param type the type\n   * @param propertyNode the node corresponding to the declaration of property\n   *        which might later be accessed using {@code getPropertyNode}.\n   */\n  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode);\n  /**\n   * Checks whether the property whose name is given is present on the\n   * object.\n   */\n  public abstract boolean hasProperty(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   */\n  public boolean hasOwnProperty(String propertyName);\n  /**\n   * Gets the reference name for this object. This includes named types\n   * like constructors, prototypes, and enums. It notably does not include\n   * literal types like strings and booleans and structural types.\n   * @return the object's name or {@code null} if this is an anonymous\n   *         object\n   */\n  public abstract String getReferenceName();\n\n  /**\n   * Due to the complexity of some of our internal type systems, sometimes\n   * we have different types constructed by the same constructor.\n   * In other parts of the type system, these are called delegates.\n   * We construct these types by appending suffixes to the constructor name.\n   *\n   * The normalized reference name does not have these suffixes, and as such,\n   * recollapses these implicit types back to their real type.\n   */\n  public String getNormalizedReferenceName();\n  /**\n   * Gets the property type of the property whose name is given. If the\n   * underlying object does not have this property, the Unknown type is\n   * returned to indicate that no information is available on this property.\n   *\n   * @return the property's type or {@link UnknownType}. This method never\n   *         returns {@code null}.\n   */\n  public abstract JSType getPropertyType(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present on the\n   * object.\n   */\n  public abstract boolean hasProperty(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   */\n  public boolean hasOwnProperty(String propertyName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The type registry is used to resolve named types.\n *\n * <p>This class is not thread-safe.\n *\n */\npublic class JSTypeRegistry implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private static final int PROPERTY_CHECKING_UNION_SIZE = 3000;\n  private final transient ErrorReporter reporter;\n  private final JSType[] nativeTypes;\n  private final Map<String, JSType> namesToTypes;\n  private final Set<String> namespaces = new HashSet<String>();\n  private final Set<String> nonNullableTypeNames = new HashSet<String>();\n  private final Set<String> forwardDeclaredTypes = new HashSet<String>();\n  private boolean lastGeneration = true;\n  private String templateTypeName;\n  private TemplateType templateType;\n  private final boolean tolerateUndefinedValues;\n  /**\n   * Looks up a type by name.\n   *\n   * @param jsTypeName The name string.\n   * @return the corresponding JSType object or {@code null} it cannot be found\n   */\n  public JSType getType(String jsTypeName);\n  /**\n   * Looks up a type by name. To allow for forward references to types, an\n   * unrecognized string has to be bound to a NamedType object that will be\n   * resolved later.\n   *\n   * @param scope A scope for doing type name resolution.\n   * @param jsTypeName The name string.\n   * @param sourceName The name of the source file where this reference appears.\n   * @param lineno The line number of the reference.\n   * @return a NamedType if the string argument is not one of the known types,\n   *     otherwise the corresponding JSType object.\n   */\n  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno);\n  /**\n   * Returns whether the given property can possibly be set on the given type.\n   */\n  public boolean canPropertyBeDefined(JSType type, String propertyName);\n}\n/**\n * A builder for record types.\n *\n */\npublic class RecordTypeBuilder {\n  private boolean isEmpty = true;\n  private final JSTypeRegistry registry;\n  private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n  /**\n   * Adds a property with the given name and type to the record type.\n   * @param name the name of the new property\n   * @param type the JSType of the new property\n   * @param propertyNode the node that holds this property definition\n   * @return The builder itself for chaining purposes, or null if there's\n   *          a duplicate.\n   */\n  public RecordTypeBuilder addProperty(String name, JSType type, Node\n      propertyNode);\n}\n/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private boolean isFrozen = false;\n  JSType getGreatestSubtypeHelper(JSType that);\n  /** @return Is this synthesized for internal bookkeeping? */\n\n  @Override\n  public boolean isEquivalentTo(JSType other);\n}\n/**\n * Object type.\n *\n * In JavaScript, all object types have properties, and each of those\n * properties has a type. Property types may be DECLARED, INFERRED, or\n * UNKNOWN.\n *\n * DECLARED properties have an explicit type annotation, as in:\n * <code>\n * /xx @type {number} x/\n * Foo.prototype.bar = 1;\n * </code>\n * This property may only hold number values, and an assignment to any\n * other type of value is an error.\n *\n * INFERRED properties do not have an explicit type annotation. Rather,\n * we try to find all the possible types that this property can hold.\n * <code>\n * Foo.prototype.bar = 1;\n * </code>\n * If the programmer assigns other types of values to this property,\n * the property will take on the union of all these types.\n *\n * UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN\n * type has all properties, but we do not know whether they are\n * declared or inferred.\n *\n */\npublic abstract class ObjectType extends JSType implements StaticScope<JSType> {\n  private boolean visited;\n  private JSDocInfo docInfo = null;\n  private boolean unknown = true;\n  /**\n   * Gets the number of properties of this object.\n   */\n  public abstract int getPropertiesCount();\n\n  /**\n   * Returns a list of properties defined or inferred on this type and any of\n   * its supertypes.\n   */\n  public Set<String> getPropertyNames();\n  /**\n   * Defines a property whose type is explicitly declared by the programmer.\n   * @param propertyName the property's name\n   * @param type the type\n   * @param propertyNode the node corresponding to the declaration of property\n   *        which might later be accessed using {@code getPropertyNode}.\n   */\n  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode);\n  /**\n   * Checks whether the property whose name is given is present on the\n   * object.\n   */\n  public abstract boolean hasProperty(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   */\n  public boolean hasOwnProperty(String propertyName);\n  /**\n   * Gets the reference name for this object. This includes named types\n   * like constructors, prototypes, and enums. It notably does not include\n   * literal types like strings and booleans and structural types.\n   * @return the object's name or {@code null} if this is an anonymous\n   *         object\n   */\n  public abstract String getReferenceName();\n\n  /**\n   * Due to the complexity of some of our internal type systems, sometimes\n   * we have different types constructed by the same constructor.\n   * In other parts of the type system, these are called delegates.\n   * We construct these types by appending suffixes to the constructor name.\n   *\n   * The normalized reference name does not have these suffixes, and as such,\n   * recollapses these implicit types back to their real type.\n   */\n  public String getNormalizedReferenceName();\n  /**\n   * Gets the property type of the property whose name is given. If the\n   * underlying object does not have this property, the Unknown type is\n   * returned to indicate that no information is available on this property.\n   *\n   * @return the property's type or {@link UnknownType}. This method never\n   *         returns {@code null}.\n   */\n  public abstract JSType getPropertyType(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present on the\n   * object.\n   */\n  public abstract boolean hasProperty(String propertyName);\n\n  /**\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   */\n  public boolean hasOwnProperty(String propertyName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue725() throws Exception {\n    testTypes(\n        \"/** @typedef {{name: string}} */ var RecordType1;\" +\n        \"/** @typedef {{name2: string}} */ var RecordType2;\" +\n        \"/** @param {RecordType1} rec */ function f(rec) {\" +\n        \"  alert(rec.name2);\" +\n        \"}\",\n        \"Property name2 never defined on rec\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  @Override\n  public Property getSlot(String name);\n  @Override\n  public void matchConstraint(JSType constraint);\n  @Override\n  public boolean isSubtype(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  @Override\n  public Property getSlot(String name);\n  @Override\n  public void matchConstraint(JSType constraint);\n  @Override\n  public boolean isSubtype(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assumingThisType(JSType type) {\n    assumedThisType = type;\n  }\n  private void assuming(String name, JSType type) {\n    assumptions.put(name, type);\n  }\n  private void assuming(String name, JSTypeNative type) {\n    assuming(name, registry.getNativeType(type));\n  }\n  private void inFunction(String js) {\n    // Parse the body of the function.\n    String thisBlock = assumedThisType == null\n        ? \"\"\n        : \"/** @this {\" + assumedThisType + \"} */\";\n    Node root = compiler.parseTestCode(\n        \"(\" + thisBlock + \" function() {\" + js + \"});\");\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Node n = root.getFirstChild().getFirstChild();\n    // Create the scope with the assumptions.\n    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n    Scope assumedScope = scopeCreator.createScope(\n        n, scopeCreator.createScope(root, null));\n    for (Map.Entry<String,JSType> entry : assumptions.entrySet()) {\n      assumedScope.declare(entry.getKey(), null, entry.getValue(), null, false);\n    }\n    // Create the control graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    ControlFlowGraph<Node> cfg = cfa.getCfg();\n    // Create a simple reverse abstract interpreter.\n    ReverseAbstractInterpreter rai = compiler.getReverseAbstractInterpreter();\n    // Do the type inference by data-flow analysis.\n    TypeInference dfa = new TypeInference(compiler, cfg, rai, assumedScope,\n        ASSERTION_FUNCTION_MAP);\n    dfa.analyze();\n    // Get the scope of the implicit return.\n    BranchedFlowState<FlowScope> rtnState =\n        cfg.getImplicitReturn().getAnnotation();\n    returnScope = rtnState.getIn();\n  }\n  private JSType getType(String name) {\n    assertTrue(\"The return scope should not be null.\", returnScope != null);\n    StaticSlot<JSType> var = returnScope.getSlot(name);\n    assertTrue(\"The variable \" + name + \" is missing from the scope.\",\n        var != null);\n    return var.getType();\n  }\n  private void verify(String name, JSType type) {\n    Asserts.assertTypeEquals(type, getType(name));\n  }\n  private void verify(String name, JSTypeNative type) {\n    verify(name, registry.getNativeType(type));\n  }\n  private void verifySubtypeOf(String name, JSType type) {\n    JSType varType = getType(name);\n    assertTrue(\"The variable \" + name + \" is missing a type.\", varType != null);\n    assertTrue(\"The type \" + varType + \" of variable \" + name +\n        \" is not a subtype of \" + type +\".\",  varType.isSubtype(type));\n  }\n  private void verifySubtypeOf(String name, JSTypeNative type) {\n    verifySubtypeOf(name, registry.getNativeType(type));\n  }\n  private EnumType createEnumType(String name, JSTypeNative elemType) {\n    return createEnumType(name, registry.getNativeType(elemType));\n  }\n  private EnumType createEnumType(String name, JSType elemType) {\n    return registry.createEnumType(name, null, elemType);\n  }\n  private JSType createUndefinableType(JSTypeNative type) {\n    return registry.createUnionType(\n        registry.getNativeType(type), registry.getNativeType(VOID_TYPE));\n  }\n  private JSType createNullableType(JSTypeNative type) {\n    return createNullableType(registry.getNativeType(type));\n  }\n  private JSType createNullableType(JSType type) {\n    return registry.createNullableType(type);\n  }\n  private JSType createUnionType(JSTypeNative type1, JSTypeNative type2) {\n    return registry.createUnionType(\n        registry.getNativeType(type1), registry.getNativeType(type2));\n  }\n  public void testRecordInference() {\n    inFunction(\n        \"/** @param {{a: (boolean|undefined)}|{b: (string|undefined)}} x */\" +\n        \"function f(x) {}\" +\n        \"var out = {};\" +\n        \"f(out);\");\n    assertEquals(\"{a: (boolean|undefined), b: (string|undefined)}\", getType(\"out\").toString());\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A reverse abstract interpreter using the semantics of the JavaScript\n * language as a means to reverse interpret computations. This interpreter\n * expects the parse tree inputs to be typed.\n *\n */\npublic class SemanticReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,\n      FlowScope blindScope, boolean condition);\n  private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome);\n  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition);\n  /**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.\n   */\n  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType);\n  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging);\n}\n/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  private boolean inTemplatedCheckVisit = false;\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n  /**\n   * When computing infima, we may get a situation like\n   * inf(Type1, Type2)\n   * where both types are unresolved, so they're technically\n   * subtypes of one another.\n   *\n   * If this happens, filter them down to NoResolvedType.\n   */\n  static JSType filterNoResolvedType(JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A reverse abstract interpreter using the semantics of the JavaScript\n * language as a means to reverse interpret computations. This interpreter\n * expects the parse tree inputs to be typed.\n *\n */\npublic class SemanticReverseAbstractInterpreter\n    extends ChainableReverseAbstractInterpreter {\n  private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,\n      FlowScope blindScope, boolean condition);\n  private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n      boolean outcome);\n  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n        FlowScope blindScope, boolean condition);\n  /**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.\n   */\n  private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType);\n  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n      Function<TypePair, TypePair> merging);\n}\n/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  private boolean inTemplatedCheckVisit = false;\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n  /**\n   * When computing infima, we may get a situation like\n   * inf(Type1, Type2)\n   * where both types are unresolved, so they're technically\n   * subtypes of one another.\n   *\n   * If this happens, filter them down to NoResolvedType.\n   */\n  static JSType filterNoResolvedType(JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue783() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var Type = function () {\" +\n        \"  /** @type {Type} */\" +\n        \"  this.me_ = this;\" +\n        \"};\" +\n        \"Type.prototype.doIt = function() {\" +\n        \"  var me = this.me_;\" +\n        \"  for (var i = 0; i < me.unknownProp; i++) {}\" +\n        \"};\",\n        \"Property unknownProp never defined on Type\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue726() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n        \"/** @return {!Function} */ \" +\n        \"Foo.prototype.getDeferredBar = function() { \" +\n        \"  var self = this;\" +\n        \"  return function() {\" +\n        \"    self.bar(true);\" +\n        \"  };\" +\n        \"};\",\n        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public JSType getPropertyType(String name);\n  public ObjectType getTopMostDefiningType(String propertyName);\n  /**\n   * Two function types are equal if their signatures match. Since they don't\n   * have signatures, two interfaces are equal if their names match.\n   */\n  boolean checkFunctionEquivalenceHelper(\n      FunctionType that, boolean tolerateUnknowns);\n  @Override\n  public int hashCode();\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public boolean isConstructor();\n  /**\n   * Try to get the sup/inf of two functions by looking at the\n   * piecewise components.\n   */\n  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper);\n}\n/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private final boolean declared;\n  private boolean isFrozen = false;\n  /** @return Is this synthesized for internal bookkeeping? */\n  boolean isSynthetic();\n  /** Determines if typeA is a subtype of typeB */\n  static boolean isSubtype(ObjectType typeA, RecordType typeB);\n  JSType getGreatestSubtypeHelper(JSType that);\n  boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, boolean tolerateUnknowns);\n}\n/**\n * The {@code UnionType} implements a common JavaScript idiom in which the\n * code is specifically designed to work with multiple input types.  Because\n * JavaScript always knows the run-time type of an object value, this is safer\n * than a C union.<p>\n *\n * For instance, values of the union type {@code (String,boolean)} can be of\n * type {@code String} or of type {@code boolean}. The commutativity of the\n * statement is captured by making {@code (String,boolean)} and\n * {@code (boolean,String)} equal.<p>\n *\n * The implementation of this class prevents the creation of nested\n * unions.<p>\n */\npublic class UnionType extends JSType {\n  private static final long serialVersionUID = 1L;\n  private final int hashcode;\n  JSType meet(JSType that);\n  @Override\n  public boolean hasProperty(String pname);\n}\n/**\n * The arrow type is an internal type that models the functional arrow type\n * seen in typical functional programming languages.  It is used solely for\n * separating the management of the arrow type from the complex\n * {@link FunctionType} that models JavaScript's notion of functions.\n */\nfinal class ArrowType extends JSType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   */\n  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns);\n  @Override\n  public boolean isSubtype(JSType other);\n}\n/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  private boolean inTemplatedCheckVisit = false;\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns);\n  /**\n   * Whether this type is a {@link FunctionType} that is an ordinary function or\n   * a named type that points to such a type.\n   */\n  public boolean isOrdinaryFunction();\n  /**\n   * Checks if two types are equivalent.\n   */\n  public final boolean isEquivalentTo(JSType that);\n  /**\n   * Checks if two types are invariant.\n   * @see EquivalenceMethod\n   */\n  public final boolean isInvariant(JSType that);\n  /** Checks whether the property pname is present on the object. */\n  public boolean hasProperty(String pname);\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public JSType getPropertyType(String name);\n  public ObjectType getTopMostDefiningType(String propertyName);\n  /**\n   * Two function types are equal if their signatures match. Since they don't\n   * have signatures, two interfaces are equal if their names match.\n   */\n  boolean checkFunctionEquivalenceHelper(\n      FunctionType that, boolean tolerateUnknowns);\n  @Override\n  public int hashCode();\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public boolean isConstructor();\n  /**\n   * Try to get the sup/inf of two functions by looking at the\n   * piecewise components.\n   */\n  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper);\n}\n/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private final boolean declared;\n  private boolean isFrozen = false;\n  /** @return Is this synthesized for internal bookkeeping? */\n  boolean isSynthetic();\n  /** Determines if typeA is a subtype of typeB */\n  static boolean isSubtype(ObjectType typeA, RecordType typeB);\n  JSType getGreatestSubtypeHelper(JSType that);\n  boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, boolean tolerateUnknowns);\n}\n/**\n * The {@code UnionType} implements a common JavaScript idiom in which the\n * code is specifically designed to work with multiple input types.  Because\n * JavaScript always knows the run-time type of an object value, this is safer\n * than a C union.<p>\n *\n * For instance, values of the union type {@code (String,boolean)} can be of\n * type {@code String} or of type {@code boolean}. The commutativity of the\n * statement is captured by making {@code (String,boolean)} and\n * {@code (boolean,String)} equal.<p>\n *\n * The implementation of this class prevents the creation of nested\n * unions.<p>\n */\npublic class UnionType extends JSType {\n  private static final long serialVersionUID = 1L;\n  private final int hashcode;\n  JSType meet(JSType that);\n  @Override\n  public boolean hasProperty(String pname);\n}\n/**\n * The arrow type is an internal type that models the functional arrow type\n * seen in typical functional programming languages.  It is used solely for\n * separating the management of the arrow type from the complex\n * {@link FunctionType} that models JavaScript's notion of functions.\n */\nfinal class ArrowType extends JSType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   */\n  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns);\n  @Override\n  public boolean isSubtype(JSType other);\n}\n/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  private boolean inTemplatedCheckVisit = false;\n  /**\n   * An equivalence visitor.\n   */\n  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns);\n  /**\n   * Whether this type is a {@link FunctionType} that is an ordinary function or\n   * a named type that points to such a type.\n   */\n  public boolean isOrdinaryFunction();\n  /**\n   * Checks if two types are equivalent.\n   */\n  public final boolean isEquivalentTo(JSType that);\n  /**\n   * Checks if two types are invariant.\n   * @see EquivalenceMethod\n   */\n  public final boolean isInvariant(JSType that);\n  /** Checks whether the property pname is present on the object. */\n  public boolean hasProperty(String pname);\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue791() throws Exception {\n    testTypes(\n        \"/** @param {{func: function()}} obj */\" +\n        \"function test1(obj) {}\" +\n        \"var fnStruc1 = {};\" +\n        \"fnStruc1.func = function() {};\" +\n        \"test1(fnStruc1);\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue688() throws Exception {\n    testTypes(\n        \"/** @const */ var SOME_DEFAULT =\\n\" +\n        \"    /** @type {TwoNumbers} */ ({first: 1, second: 2});\\n\" +\n        \"/**\\n\" +\n        \"* Class defining an interface with two numbers.\\n\" +\n        \"* @interface\\n\" +\n        \"*/\\n\" +\n        \"function TwoNumbers() {}\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.first;\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.second;\\n\" +\n        \"/** @return {number} */ function f() { return SOME_DEFAULT; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : (TwoNumbers|null)\\n\" +\n        \"required: number\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void noInline(String input) {\n    inline(input, input);\n  }\n  private void inline(String input, String expected) {\n    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n        \"function _func() {\" + expected + \"}\", null, null);\n  }\n  public void testVarAssinInsideHookIssue965() {\n    noInline(\"var i = 0; return 1 ? (i = 5) : 0, i;\");\n    noInline(\"var i = 0; return (1 ? (i = 5) : 0) ? i : 0;\");\n    noInline(\"var i = 0; return (1 ? (i = 5) : 0) || i;\");\n    noInline(\"var i = 0; return (1 ? (i = 5) : 0) * i;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private final ObjectType unknownType;\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  private FlowScope traverseObjectLiteral(Node n, FlowScope scope);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private final ObjectType unknownType;\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  private FlowScope traverseObjectLiteral(Node n, FlowScope scope);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1023() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"(function () {\" +\n        \"  F.prototype = {\" +\n        \"    /** @param {string} x */\" +\n        \"    bar: function (x) {  }\" +\n        \"  };\" +\n        \"})();\" +\n        \"(new F()).bar(true)\",\n        \"actual parameter 1 of F.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: string\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private final ObjectType unknownType;\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private final ObjectType unknownType;\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1024() throws Exception {\n     testTypes(\n        \"/** @param {Object} a */\\n\" +\n        \"function f(a) {\\n\" +\n        \"  a.prototype = '__proto'\\n\" +\n        \"}\\n\" +\n        \"/** @param {Object} b\\n\" +\n        \" *  @return {!Object}\\n\" +\n        \" */\\n\" +\n        \"function g(b) {\\n\" +\n        \"  return b.prototype\\n\" +\n        \"}\\n\");\n     /* TODO(blickly): Make this warning go away.\n      * This is old behavior, but it doesn't make sense to warn about since\n      * both assignments are inferred.\n      */\n     testTypes(\n        \"/** @param {Object} a */\\n\" +\n        \"function f(a) {\\n\" +\n        \"  a.prototype = {foo:3};\\n\" +\n        \"}\\n\" +\n        \"/** @param {Object} b\\n\" +\n        \" */\\n\" +\n        \"function g(b) {\\n\" +\n        \"  b.prototype = function(){};\\n\" +\n        \"}\\n\",\n        \"assignment to property prototype of Object\\n\" +\n        \"found   : {foo: number}\\n\" +\n        \"required: function (): undefined\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> escapedJsStrings = Maps.newHashMap();\n  void add(Node n, Context context);\n}\n/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private final boolean late;\n  private static final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n  private final Map<String, String> escapedJsStrings = Maps.newHashMap();\n  void add(Node n, Context context);\n}\n/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private final boolean late;\n  private static final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid JS\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrintSame(String js) {\n    assertPrint(js, js);\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreakAtEndOfFile(String js,\n      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {\n    assertEquals(expectedWithoutBreakAtEnd,\n        parsePrint(js, false, false, false, 30));\n    assertEquals(expectedWithBreakAtEnd,\n        parsePrint(js, false, false, true, 30));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testPrint() {\n    assertPrint(\"10 + a + b\", \"10+a+b\");\n    assertPrint(\"10 + (30*50)\", \"10+30*50\");\n    assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");\n    assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");\n    assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");\n    assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");\n    assertPrint(\"a instanceof b\", \"a instanceof b\");\n    assertPrint(\"typeof(a)\", \"typeof a\");\n    assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");\n\n    // Safari: needs ';' at the end of a throw statement\n    assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");\n    // Safari 3 needs a \"{\" around a single function\n    assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");\n\n    assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");\n\n    assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");\n    assertPrint(\"x-- >> 1\", \"x-- >>1\");\n\n    assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");\n\n    // Associativity\n    assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");\n    assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");\n    assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");\n\n    // Nested assignments\n    assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");\n    assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");\n    assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");\n    assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");\n\n    // Precedence\n    assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");\n    assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");\n\n    // optional '()' for new\n\n    // simple new\n    assertPrint(\"new A\", \"new A\");\n    assertPrint(\"new A()\", \"new A\");\n    assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");\n\n    // calling instance method directly after new\n    assertPrint(\"new A().a()\", \"(new A).a()\");\n    assertPrint(\"(new A).a()\", \"(new A).a()\");\n\n    // this case should be fixed\n    assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");\n\n    // internal class\n    assertPrint(\"new A.B\", \"new A.B\");\n    assertPrint(\"new A.B()\", \"new A.B\");\n    assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");\n\n    // calling instance method directly after new internal class\n    assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");\n    assertPrint(\"new A.B().a()\", \"(new A.B).a()\");\n    // this case should be fixed\n    assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    assertPrint(\"x + +y\", \"x+ +y\");\n    assertPrint(\"x - (-y)\", \"x- -y\");\n    assertPrint(\"x++ +y\", \"x++ +y\");\n    assertPrint(\"x-- -y\", \"x-- -y\");\n    assertPrint(\"x++ -y\", \"x++-y\");\n\n    // Label\n    assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");\n    assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");\n\n    // Object literals.\n    assertPrint(\"({})\", \"({})\");\n    assertPrint(\"var x = {};\", \"var x={}\");\n    assertPrint(\"({}).x\", \"({}).x\");\n    assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");\n    assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");\n    assertPrint(\"({}) || 1\", \"({})||1\");\n    assertPrint(\"1 || ({})\", \"1||{}\");\n    assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");\n    assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");\n    assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");\n    assertPrint(\"typeof ({})\", \"typeof{}\");\n    assertPrint(\"f({})\", \"f({})\");\n\n    // Anonymous function expressions.\n    assertPrint(\"(function(){})\", \"(function(){})\");\n    assertPrint(\"(function(){})()\", \"(function(){})()\");\n    assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");\n    assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");\n    assertPrint(\"var x = function() { };\", \"var x=function(){}\");\n    assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");\n    assertPrint(\"(function() {}), 2\", \"(function(){}),2\");\n\n    // Name functions expression.\n    assertPrint(\"(function f(){})\", \"(function f(){})\");\n\n    // Function declaration.\n    assertPrint(\"function f(){}\", \"function f(){}\");\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");\n    assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");\n\n    // Test if statement and for statements with single statements in body.\n    assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");\n    assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");\n    assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");\n\n    assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");\n    assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");\n    assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");\n\n    // Test nested var statement\n    assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");\n    assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");\n    assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");\n    assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");\n\n    // Test the right-associative unary operators for spurious parens\n    assertPrint(\"! ! true\", \"!!true\");\n    assertPrint(\"!(!(true))\", \"!!true\");\n    assertPrint(\"typeof(void(0))\", \"typeof void 0\");\n    assertPrint(\"typeof(void(!0))\", \"typeof void!0\");\n    assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\"); // chained unary plus/minus\n    assertPrint(\"+(--x)\", \"+--x\");\n    assertPrint(\"-(++x)\", \"-++x\");\n\n    // needs a space to prevent an ambiguous parse\n    assertPrint(\"-(--x)\", \"- --x\");\n    assertPrint(\"!(~~5)\", \"!~~5\");\n    assertPrint(\"~(a/b)\", \"~(a/b)\");\n\n    // Preserve parens to overcome greedy binding of NEW\n    assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");\n    assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");\n    assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");\n\n    // Make sure that HOOK is right associative\n    assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");\n    assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");\n    assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");\n\n    // Test nested ifs\n    assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");\n\n    // Test comma.\n    assertPrint(\"a,b,c\", \"a,b,c\");\n    assertPrint(\"(a,b),c\", \"a,b,c\");\n    assertPrint(\"a,(b,c)\", \"a,b,c\");\n    assertPrint(\"x=a,b,c\", \"x=a,b,c\");\n    assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");\n    assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");\n    assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");\n    assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");\n    assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");\n    assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");\n    assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");\n    assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");\n    assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");\n    assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");\n    assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");\n    assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");\n    assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");\n    assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");\n    assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");\n    assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");\n    assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");\n    assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");\n\n    // EMPTY nodes\n    assertPrint(\"if (x){}\", \"if(x);\");\n    assertPrint(\"if(x);\", \"if(x);\");\n    assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");\n    assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");\n    assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");\n    assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * NodeUtil contains generally useful AST utilities.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info);\n}\n/**\n * Generates an AST for a JavaScript source file.\n *\n */\npublic class JsAst implements SourceAst {\n  private static final Logger logger_ = Logger.getLogger(JsAst.class.getName());\n  private static final long serialVersionUID = 1L;\n  private transient InputId inputId;\n  private transient SourceFile sourceFile;\n  private String fileName;\n  private Node root;\n  @Override\n  public void setSourceFile(SourceFile file);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * The advantage of using goog.scope is that the compiler will *guarantee*\n * the anonymous function will be inlined, even if it can't prove\n * that it's semantically correct to do so. For example, consider this case:\n *\n * goog.scope(function() {\n *   goog.getBar = function () { return alias; };\n *   ...\n *   var alias = foo.bar;\n * })\n *\n * In theory, the compiler can't inline 'alias' unless it can prove that\n * goog.getBar is called only after 'alias' is defined.\n *\n * In practice, the compiler will inline 'alias' anyway, at the risk of\n * 'fixing' bad code.\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  private Multiset<String> scopedAliasNames = HashMultiset.create();\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * NodeUtil contains generally useful AST utilities.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info);\n}\n/**\n * Generates an AST for a JavaScript source file.\n *\n */\npublic class JsAst implements SourceAst {\n  private static final Logger logger_ = Logger.getLogger(JsAst.class.getName());\n  private static final long serialVersionUID = 1L;\n  private transient InputId inputId;\n  private transient SourceFile sourceFile;\n  private String fileName;\n  private Node root;\n  @Override\n  public void setSourceFile(SourceFile file);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testScoped(String code, String expected) {\n    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n  }\n  private void testScopedNoChanges(String aliases, String code) {\n    testScoped(aliases + code, code);\n  }\n  private void testTypes(String aliases, String code) {\n    testScopedNoChanges(aliases, code);\n    verifyTypes();\n  }\n  private void verifyTypes() {\n    Compiler lastCompiler = getLastCompiler();\n    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n        lastCompiler.jsRoot);\n  }\n  private void testFailure(String code, DiagnosticType expectedError) {\n    test(code, null, expectedError);\n  }\n  private void testScopedFailure(String code, DiagnosticType expectedError) {\n    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n  }\n  private void verifyAliasTransformationPosition(int startLine, int startChar,\n      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n    assertEquals(startLine, pos.getStartLine());\n    assertEquals(startChar, pos.getPositionOnStartLine());\n    assertTrue(\n        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n        pos.getEndLine() >= endLine);\n    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n  }\n  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  private final Supplier<String> safeNameIdSupplier;\n  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions);\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n  /**\n   * @param fnName The name of this function. This either the name of the\n   *  variable to which the function is assigned or the name from the FUNCTION\n   *  node.\n   * @param fnNode The FUNCTION node of the function to inspect.\n   * @return Whether the function node meets the minimum requirements for\n   * inlining.\n   */\n  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode);\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n  private final AbstractCompiler compiler;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n  private final Supplier<String> safeNameIdSupplier;\n  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions);\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode);\n  /**\n   * @param fnName The name of this function. This either the name of the\n   *  variable to which the function is assigned or the name from the FUNCTION\n   *  node.\n   * @param fnNode The FUNCTION node of the function to inspect.\n   * @return Whether the function node meets the minimum requirements for\n   * inlining.\n   */\n  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode);\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private FunctionInjector getInjector() {\n    Compiler compiler = new Compiler();\n    return new FunctionInjector(\n        compiler, compiler.getUniqueNameIdSupplier(), true,\n        assumeStrictThis, assumeMinimumCapture);\n  }\n  private void validateSourceInfo(Compiler compiler, Node subtree) {\n    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n    // Source information problems are reported as compiler errors.\n    if (compiler.getErrorCount() != 0) {\n      String msg = \"Error encountered: \";\n      for (JSError err : compiler.getErrors()) {\n        msg += err.toString() + \"\\n\";\n      }\n      assertTrue(msg, compiler.getErrorCount() == 0);\n    }\n  }\n  private static Node findFunction(Node n, String name) {\n    if (n.isFunction()) {\n      if (n.getFirstChild().getString().equals(name)) {\n        return n;\n      }\n    }\n\n    for (Node c : n.children()) {\n      Node result = findFunction(c, name);\n      if (result != null) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n  private static Node prep(String js) {\n    Compiler compiler = new Compiler();\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n.getFirstChild();\n  }\n  private static Node parse(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private static Node parseExpected(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    String message = \"Unexpected errors: \";\n    JSError[] errs = compiler.getErrors();\n    for (int i = 0; i < errs.length; i++){\n      message += \"\\n\" + errs[i].toString();\n    }\n    assertEquals(message, 0, compiler.getErrorCount());\n    return n;\n  }\n  private static String toSource(Node n) {\n    return new CodePrinter.Builder(n)\n        .setPrettyPrint(false)\n        .setLineBreak(false)\n        .setSourceMap(null)\n        .build();\n  }\n  public void testIssue1101a() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n        INLINE_DIRECT);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private final ObjectType unknownType;\n  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private static ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, false)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides);\n  }\n  public void testIssue1056() throws Exception {\n    testTypes(\n        \"/** @type {Array} */ var x = null;\" +\n        \"x.push('hi');\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact JavaScript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n  private Map<InputId, CompilerInput> inputsById;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  private volatile double progress = 0.0;\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact JavaScript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n  private Map<InputId, CompilerInput> inputsById;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  private volatile double progress = 0.0;\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testDependencySorting() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.setDependencyOptions(\n        new DependencyOptions()\n        .setDependencySorting(true));\n    test(\n        options,\n        new String[] {\n          \"goog.require('x');\",\n          \"goog.provide('x');\",\n        },\n        new String[] {\n          \"goog.provide('x');\",\n          \"goog.require('x');\",\n\n          // For complicated reasons involving modules,\n          // the compiler creates a synthetic source file.\n          \"\",\n        });\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Chainable reverse abstract interpreter providing basic functionality.\n *\n */\npublic abstract class ChainableReverseAbstractInterpreter\n    implements ReverseAbstractInterpreter {\n  private ChainableReverseAbstractInterpreter firstLink;\n  private ChainableReverseAbstractInterpreter nextLink;\n  JSType getNativeType(JSTypeNative typeId);\n  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Chainable reverse abstract interpreter providing basic functionality.\n *\n */\npublic abstract class ChainableReverseAbstractInterpreter\n    implements ReverseAbstractInterpreter {\n  private ChainableReverseAbstractInterpreter firstLink;\n  private ChainableReverseAbstractInterpreter nextLink;\n  JSType getNativeType(JSTypeNative typeId);\n  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assumingThisType(JSType type) {\n    assumedThisType = type;\n  }\n  private void assuming(String name, JSType type) {\n    assumptions.put(name, type);\n  }\n  private void assuming(String name, JSTypeNative type) {\n    assuming(name, registry.getNativeType(type));\n  }\n  private void inFunction(String js) {\n    // Parse the body of the function.\n    String thisBlock = assumedThisType == null\n        ? \"\"\n        : \"/** @this {\" + assumedThisType + \"} */\";\n    Node root = compiler.parseTestCode(\n        \"(\" + thisBlock + \" function() {\" + js + \"});\");\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Node n = root.getFirstChild().getFirstChild();\n    // Create the scope with the assumptions.\n    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n    Scope assumedScope = scopeCreator.createScope(\n        n, scopeCreator.createScope(root, null));\n    for (Map.Entry<String,JSType> entry : assumptions.entrySet()) {\n      assumedScope.declare(entry.getKey(), null, entry.getValue(), null, false);\n    }\n    // Create the control graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    ControlFlowGraph<Node> cfg = cfa.getCfg();\n    // Create a simple reverse abstract interpreter.\n    ReverseAbstractInterpreter rai = compiler.getReverseAbstractInterpreter();\n    // Do the type inference by data-flow analysis.\n    TypeInference dfa = new TypeInference(compiler, cfg, rai, assumedScope,\n        ASSERTION_FUNCTION_MAP);\n    dfa.analyze();\n    // Get the scope of the implicit return.\n    BranchedFlowState<FlowScope> rtnState =\n        cfg.getImplicitReturn().getAnnotation();\n    returnScope = rtnState.getIn();\n  }\n  private JSType getType(String name) {\n    assertTrue(\"The return scope should not be null.\", returnScope != null);\n    StaticSlot<JSType> var = returnScope.getSlot(name);\n    assertTrue(\"The variable \" + name + \" is missing from the scope.\",\n        var != null);\n    return var.getType();\n  }\n  private void verify(String name, JSType type) {\n    Asserts.assertTypeEquals(type, getType(name));\n  }\n  private void verify(String name, JSTypeNative type) {\n    verify(name, registry.getNativeType(type));\n  }\n  private void verifySubtypeOf(String name, JSType type) {\n    JSType varType = getType(name);\n    assertTrue(\"The variable \" + name + \" is missing a type.\", varType != null);\n    assertTrue(\"The type \" + varType + \" of variable \" + name +\n        \" is not a subtype of \" + type +\".\",  varType.isSubtype(type));\n  }\n  private void verifySubtypeOf(String name, JSTypeNative type) {\n    verifySubtypeOf(name, registry.getNativeType(type));\n  }\n  private EnumType createEnumType(String name, JSTypeNative elemType) {\n    return createEnumType(name, registry.getNativeType(elemType));\n  }\n  private EnumType createEnumType(String name, JSType elemType) {\n    return registry.createEnumType(name, null, elemType);\n  }\n  private JSType createUndefinableType(JSTypeNative type) {\n    return registry.createUnionType(\n        registry.getNativeType(type), registry.getNativeType(VOID_TYPE));\n  }\n  private JSType createNullableType(JSTypeNative type) {\n    return createNullableType(registry.getNativeType(type));\n  }\n  private JSType createNullableType(JSType type) {\n    return registry.createNullableType(type);\n  }\n  private JSType createUnionType(JSTypeNative type1, JSTypeNative type2) {\n    return registry.createUnionType(\n        registry.getNativeType(type1), registry.getNativeType(type2));\n  }\n  public void testNoThisInference() {\n    JSType thisType = createNullableType(OBJECT_TYPE);\n    assumingThisType(thisType);\n    inFunction(\"var out = 3; if (goog.isNull(this)) out = this;\");\n    verify(\"out\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private MemoizedScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private MemoizedScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot);\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {\n    String js = \"/** @interface \\n\" +\n        \" * @extends {nonExistent1} \\n\" +\n        \" * @extends {nonExistent2} \\n\" +\n        \" */function A() {}\";\n    String[] expectedWarnings = {\n      \"Bad type annotation. Unknown type nonExistent1\",\n      \"Bad type annotation. Unknown type nonExistent2\"\n    };\n    testTypes(js, expectedWarnings);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n  private final boolean late;\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  private Node tryFoldSimpleFunctionCall(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n  private final boolean late;\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n  private Node tryFoldSimpleFunctionCall(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  public void testSimpleFunctionCall() {\n    test(\"var a = String(23)\", \"var a = '' + 23\");\n    test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n    testSame(\"var a = String('hello', bar());\");\n    testSame(\"var a = String({valueOf: function() { return 1; }});\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for non side effecting statements such as\n * <pre>\n * var s = \"this string is \"\n *         \"continued on the next line but you forgot the +\";\n * x == foo();  // should that be '='?\n * foo();;  // probably just a stray-semicolon. Doesn't hurt to check though\n * </p>\n * and generates warnings.\n *\n */\nfinal class CheckSideEffects extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final CheckLevel level;\n  private final List<Node> problemNodes = Lists.newArrayList();\n  private final AbstractCompiler compiler;\n  private final boolean protectSideEffectFreeCode;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for non side effecting statements such as\n * <pre>\n * var s = \"this string is \"\n *         \"continued on the next line but you forgot the +\";\n * x == foo();  // should that be '='?\n * foo();;  // probably just a stray-semicolon. Doesn't hurt to check though\n * </p>\n * and generates warnings.\n *\n */\nfinal class CheckSideEffects extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final CheckLevel level;\n  private final List<Node> problemNodes = Lists.newArrayList();\n  private final AbstractCompiler compiler;\n  private final boolean protectSideEffectFreeCode;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for non side effecting statements such as\n * <pre>\n * var s = \"this string is \"\n *         \"continued on the next line but you forgot the +\";\n * x == foo();  // should that be '='?\n * foo();;  // probably just a stray-semicolon. Doesn't hurt to check though\n * </p>\n * and generates warnings.\n *\n */\nfinal class CheckSideEffects extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final CheckLevel level;\n  private final List<Node> problemNodes = Lists.newArrayList();\n  private final AbstractCompiler compiler;\n  private final boolean protectSideEffectFreeCode;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for non side effecting statements such as\n * <pre>\n * var s = \"this string is \"\n *         \"continued on the next line but you forgot the +\";\n * x == foo();  // should that be '='?\n * foo();;  // probably just a stray-semicolon. Doesn't hurt to check though\n * </p>\n * and generates warnings.\n *\n */\nfinal class CheckSideEffects extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n  private final CheckLevel level;\n  private final List<Node> problemNodes = Lists.newArrayList();\n  private final AbstractCompiler compiler;\n  private final boolean protectSideEffectFreeCode;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e);\n    test(\"var a, b; a = (bar(), bar(), 7, 8)\",\n         \"var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)\", e);\n    test(\"var a, b; a = (b = 7, 6)\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n         \"function x(){}\\nfunction f(a, b){}\\n\" +\n         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private final boolean late;\n  private Node tryFoldArrayAccess(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private final boolean late;\n  private Node tryFoldArrayAccess(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);  // TODO: why is nothing done with this?\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        ImmutableList.<SourceFile>of(),\n        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testFoldGetElem() {\n    fold(\"x = [,10][0]\", \"x = void 0\");\n    fold(\"x = [10, 20][0]\", \"x = 10\");\n    fold(\"x = [10, 20][1]\", \"x = 20\");\n    fold(\"x = [10, 20][0.5]\", \"\",\n        PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n    fold(\"x = [10, 20][-1]\",    \"\",\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n    fold(\"x = [10, 20][2]\",     \"\",\n        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n\n    foldSame(\"x = [foo(), 0][1]\");\n    fold(\"x = [0, foo()][1]\", \"x = foo()\");\n    foldSame(\"x = [0, foo()][0]\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testScoped(String code, String expected) {\n    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n  }\n  private void testScopedNoChanges(String aliases, String code) {\n    testScoped(aliases + code, code);\n  }\n  private void testTypes(String aliases, String code) {\n    testScopedNoChanges(aliases, code);\n    verifyTypes();\n  }\n  private void verifyTypes() {\n    Compiler lastCompiler = getLastCompiler();\n    new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n        lastCompiler.jsRoot);\n  }\n  private void testFailure(String code, DiagnosticType expectedError) {\n    test(code, null, expectedError);\n  }\n  private void testScopedFailure(String code, DiagnosticType expectedError) {\n    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n  }\n  private void verifyAliasTransformationPosition(int startLine, int startChar,\n      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n    assertEquals(startLine, pos.getStartLine());\n    assertEquals(startChar, pos.getPositionOnStartLine());\n    assertTrue(\n        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n        pos.getEndLine() >= endLine);\n    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n  }\n  public void testNonAliasLocal() {\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom + 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog['dom']\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"function f() {}\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private FlowScope traverseNew(Node n, FlowScope scope);\n  private JSType getNativeType(JSTypeNative typeId);\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private void updateTypeOfThisOnClosure(Node n, FunctionType fnType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  private FlowScope traverseNew(Node n, FlowScope scope);\n  private JSType getNativeType(JSTypeNative typeId);\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private void updateTypeOfThisOnClosure(Node n, FunctionType fnType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assuming(String name, JSType type) {\n    assumptions.put(name, type);\n  }\n  private void assuming(String name, JSTypeNative type) {\n    assuming(name, registry.getNativeType(type));\n  }\n  private void inFunction(String js) {\n    // Parse the body of the function.\n    Node root = compiler.parseTestCode(\"(function() {\" + js + \"});\");\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Node n = root.getFirstChild().getFirstChild();\n    // Create the scope with the assumptions.\n    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n    Scope assumedScope = scopeCreator.createScope(\n        n, scopeCreator.createScope(root, null));\n    for (Map.Entry<String,JSType> entry : assumptions.entrySet()) {\n      assumedScope.declare(entry.getKey(), null, entry.getValue(), null);\n    }\n    // Create the control graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    ControlFlowGraph<Node> cfg = cfa.getCfg();\n    // Create a simple reverse abstract interpreter.\n    ReverseAbstractInterpreter rai = new SemanticReverseAbstractInterpreter(\n        compiler.getCodingConvention(), registry);\n    // Do the type inference by data-flow analysis.\n    TypeInference dfa = new TypeInference(compiler, cfg, rai, assumedScope,\n        ASSERTION_FUNCTION_MAP);\n    dfa.analyze();\n    // Get the scope of the implicit return.\n    BranchedFlowState<FlowScope> rtnState =\n        cfg.getImplicitReturn().getAnnotation();\n    returnScope = rtnState.getIn();\n  }\n  private JSType getType(String name) {\n    assertTrue(\"The return scope should not be null.\", returnScope != null);\n    StaticSlot<JSType> var = returnScope.getSlot(name);\n    assertTrue(\"The variable \" + name + \" is missing from the scope.\",\n        var != null);\n    return var.getType();\n  }\n  private void verify(String name, JSType type) {\n    Asserts.assertTypeEquals(type, getType(name));\n  }\n  private void verify(String name, JSTypeNative type) {\n    verify(name, registry.getNativeType(type));\n  }\n  private void verifySubtypeOf(String name, JSType type) {\n    JSType varType = getType(name);\n    assertTrue(\"The variable \" + name + \" is missing a type.\", varType != null);\n    assertTrue(\"The type \" + varType + \" of variable \" + name +\n        \" is not a subtype of \" + type +\".\",  varType.isSubtype(type));\n  }\n  private void verifySubtypeOf(String name, JSTypeNative type) {\n    verifySubtypeOf(name, registry.getNativeType(type));\n  }\n  private EnumType createEnumType(String name, JSTypeNative elemType) {\n    return createEnumType(name, registry.getNativeType(elemType));\n  }\n  private EnumType createEnumType(String name, JSType elemType) {\n    return registry.createEnumType(name, null, elemType);\n  }\n  private JSType createUndefinableType(JSTypeNative type) {\n    return registry.createUnionType(\n        registry.getNativeType(type), registry.getNativeType(VOID_TYPE));\n  }\n  private JSType createNullableType(JSTypeNative type) {\n    return createNullableType(registry.getNativeType(type));\n  }\n  private JSType createNullableType(JSType type) {\n    return registry.createNullableType(type);\n  }\n  private JSType createUnionType(JSTypeNative type1, JSTypeNative type2) {\n    return registry.createUnionType(\n        registry.getNativeType(type1), registry.getNativeType(type2));\n  }\n  public void testBackwardsInferenceNew() {\n    inFunction(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @param {{foo: (number|undefined)}} x\\n\" +\n        \" */\" +\n        \"function F(x) {}\" +\n        \"var y = {};\" +\n        \"new F(y);\");\n\n    assertEquals(\"{foo: (number|undefined)}\", getType(\"y\").toString());\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n * into a form that can be safely concatenated.\n * Does not add a function around the module body but instead adds suffixes\n * to global variables to avoid conflicts.\n * Calls to require are changed to reference the required module directly.\n * goog.provide and goog.require are emitted for closure compiler automatic\n * ordering.\n */\npublic class ProcessCommonJSModules implements CompilerPass {\n  public static final String DEFAULT_FILENAME_PREFIX = \".\" + File.separator;\n  private static final String MODULE_NAME_SEPARATOR = \"\\\\$\";\n  private static final String MODULE_NAME_PREFIX = \"module$\";\n  private final AbstractCompiler compiler;\n  private final String filenamePrefix;\n  private final boolean reportDependencies;\n  private JSModule module;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n * into a form that can be safely concatenated.\n * Does not add a function around the module body but instead adds suffixes\n * to global variables to avoid conflicts.\n * Calls to require are changed to reference the required module directly.\n * goog.provide and goog.require are emitted for closure compiler automatic\n * ordering.\n */\npublic class ProcessCommonJSModules implements CompilerPass {\n  public static final String DEFAULT_FILENAME_PREFIX = \".\" + File.separator;\n  private static final String MODULE_NAME_SEPARATOR = \"\\\\$\";\n  private static final String MODULE_NAME_PREFIX = \"module$\";\n  private final AbstractCompiler compiler;\n  private final String filenamePrefix;\n  private final boolean reportDependencies;\n  private JSModule module;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? (\":m\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? \":m0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<SourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<SourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<SourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  private void setFilename(int i, String filename) {\n    this.filenames.put(i, filename);\n  }\n  private String getFilename(int i) {\n    if (filenames.isEmpty()) {\n      return \"input\" + i;\n    }\n    return filenames.get(i);\n  }\n  public void testTransformAMDAndProcessCJS() {\n    args.add(\"--transform_amd_modules\");\n    args.add(\"--process_common_js_modules\");\n    args.add(\"--common_js_entry_module=foo/bar\");\n    setFilename(0, \"foo/bar.js\");\n    test(\"define({foo: 1})\",\n        \"var module$foo$bar={}, module$foo$bar={foo:1};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n  public static Node block();\n  public static Node labelName(String name);\n  public static Node block(Node ... stmts);\n  public static Node tryFinally(Node tryBody, Node finallyBody);\n  public static Node block(Node stmt);\n  public static Node tryCatch(Node tryBody, Node catchNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n  public static Node block();\n  public static Node labelName(String name);\n  public static Node block(Node ... stmts);\n  public static Node tryFinally(Node tryBody, Node finallyBody);\n  public static Node block(Node stmt);\n  public static Node tryCatch(Node tryBody, Node catchNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testIR(Node node, String expectedStructure) {\n    assertEquals(expectedStructure, node.toStringTree());\n  }\n  public void testIssue727_1() {\n    testIR(\n        IR.tryFinally(\n            IR.block(),\n            IR.block()),\n        \"TRY\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * For use with CodeGenerator to determine the cost of generated code.\n *\n * @see CodeGenerator\n * @see CodePrinter\n */\nclass InlineCostEstimator {\n  private static final String ESTIMATED_IDENTIFIER = \"ab\";\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * For use with CodeGenerator to determine the cost of generated code.\n *\n * @see CodeGenerator\n * @see CodePrinter\n */\nclass InlineCostEstimator {\n  private static final String ESTIMATED_IDENTIFIER = \"ab\";\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void checkCost(String source, String example) {\n\n    // The example string should have been minified already.\n    assertEquals(minimize(example), example);\n\n    // cost estimate should be the same as the length of the example string.\n    assertEquals(example.length(), cost(source));\n  }\n  public void testCost() {\n    checkCost(\"1\", \"1\");\n    checkCost(\"true\", \"1\");\n    checkCost(\"false\", \"1\");\n    checkCost(\"a\", \"xx\");\n    checkCost(\"a + b\", \"xx+xx\");\n    checkCost(\"foo()\", \"xx()\");\n    checkCost(\"foo(a,b)\", \"xx(xx,xx)\");\n    checkCost(\"10 + foo(a,b)\", \"0+xx(xx,xx)\");\n    checkCost(\"1 + foo(a,b)\", \"1+xx(xx,xx)\");\n    checkCost(\"a ? 1 : 0\", \"xx?1:0\");\n    checkCost(\"a.b\", \"xx.xx\");\n    checkCost(\"new Obj()\", \"new xx\");\n    checkCost(\"function a() {return \\\"monkey\\\"}\",\n              \"function xx(){return\\\"monkey\\\"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLocal(String code, String result) {\n    test(LOCAL_PREFIX + code + LOCAL_POSTFIX,\n         LOCAL_PREFIX + result + LOCAL_POSTFIX);\n  }\n  private void testSameLocal(String code) {\n    testLocal(code, code);\n  }\n  public void testObject10() {\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var b = f();\" +\n         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n         \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n    testLocal(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n         \"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\");\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var JSCompiler_object_inline_c_2;\" +\n         \"var b = f();\" +\n         \"JSCompiler_object_inline_a_0 = a,JSCompiler_object_inline_b_1 = b, \" +\n         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n         \"JSCompiler_object_inline_c_2 = c;\" +\n         \"if (JSCompiler_object_inline_a_0)\" +\n         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2;\");\n    testLocal(\"var x = {a:a}; if (b) x={b:b}; f(x.a||x.b);\",\n         \"var JSCompiler_object_inline_a_0 = a;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"if(b) JSCompiler_object_inline_b_1 = b,\" +\n         \"      JSCompiler_object_inline_a_0 = void 0,\" +\n         \"      true;\" +\n         \"f(JSCompiler_object_inline_a_0 || JSCompiler_object_inline_b_1)\");\n    testLocal(\"var x; var y = 5; x = {a:a, b:b, c:c}; if (b) x={b:b}; f(x.a||x.b);\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var JSCompiler_object_inline_c_2;\" +\n         \"var y=5;\" +\n         \"JSCompiler_object_inline_a_0=a,\" +\n         \"JSCompiler_object_inline_b_1=b,\" +\n         \"JSCompiler_object_inline_c_2=c,\" +\n         \"true;\" +\n         \"if (b) JSCompiler_object_inline_b_1=b,\" +\n         \"       JSCompiler_object_inline_a_0=void 0,\" +\n         \"       JSCompiler_object_inline_c_2=void 0,\" +\n         \"       true;\" +\n         \"f(JSCompiler_object_inline_a_0||JSCompiler_object_inline_b_1)\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void noInline(String input) {\n    inline(input, input);\n  }\n  private void inline(String input, String expected) {\n    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n        \"function _func() {\" + expected + \"}\", null, null);\n  }\n  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void exitScope(NodeTraversal t) };\n}\n/**\n * Computes reaching definition for all use of each variables.\n *\n * A definition of {@code A} in {@code A = foo()} is a reaching definition of\n * the use of {@code A} in {@code alert(A)} if all paths from entry node must\n * reaches that definition and it is the last definition before the use.\n *\n */\nfinal class MustBeReachingVariableDef extends\n    DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> {\n  private final Scope jsScope;\n  private final AbstractCompiler compiler;\n  private final Set<Var> escaped;\n  /**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */\n  private void computeDependence(final Definition def, Node rValue);\n  @Override\n  boolean isForward();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n  @Override\n  public void exitScope(NodeTraversal t) };\n}\n/**\n * Computes reaching definition for all use of each variables.\n *\n * A definition of {@code A} in {@code A = foo()} is a reaching definition of\n * the use of {@code A} in {@code alert(A)} if all paths from entry node must\n * reaches that definition and it is the last definition before the use.\n *\n */\nfinal class MustBeReachingVariableDef extends\n    DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> {\n  private final Scope jsScope;\n  private final AbstractCompiler compiler;\n  private final Set<Var> escaped;\n  /**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */\n  private void computeDependence(final Definition def, Node rValue);\n  @Override\n  boolean isForward();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void noInline(String input) {\n    inline(input, input);\n  }\n  private void inline(String input, String expected) {\n    test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",\n        \"function _func() {\" + expected + \"}\", null, null);\n  }\n  public void testInlineAcrossSideEffect1() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX.\n    //\n    // noSFX must be both const and pure in order to inline it.\n    noInline(\"var y; var x = noSFX(y); print(x)\");\n    //inline(\"var y; var x = noSFX(y); print(x)\", \"var y;var x;print(noSFX(y))\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n  private Map<InputId, CompilerInput> inputsById;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  private volatile double progress = 0.0;\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  @Override\n  public Node getRoot();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  public Node parse(SourceFile file);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  private Result compile();\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options);\n  public void parse();\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n  private Map<InputId, CompilerInput> inputsById;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  private volatile double progress = 0.0;\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  @Override\n  public Node getRoot();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  public Node parse(SourceFile file);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  private Result compile();\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options);\n  public void parse();\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? (\":m\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"m\" + i + \":1\" + (i > 0 ? \":m0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<SourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<SourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<SourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  private void setFilename(int i, String filename) {\n    this.filenames.put(i, filename);\n  }\n  private String getFilename(int i) {\n    if (filenames.isEmpty()) {\n      return \"input\" + i;\n    }\n    return filenames.get(i);\n  }\n  public void testDependencySortingWhitespaceMode() {\n    args.add(\"--manage_closure_dependencies\");\n    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n    test(new String[] {\n          \"goog.require('beer');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.provide('hops');\",\n         },\n         new String[] {\n          \"goog.provide('hops');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.require('beer');\"\n         });\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option);\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option);\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(CompilerOptions options, String original) {\n    testSame(options, new String[] { original });\n  }\n  private void testSame(CompilerOptions options, String[] original) {\n    test(options, original, original);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled) {\n    test(options, new String[] { original }, new String[] { compiled });\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled) {\n    Compiler compiler = compile(options, original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    Node expectedRoot = parse(compiled, options);\n    String explanation = expectedRoot.checkTreeEquals(root);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(root) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void test(CompilerOptions options,\n      String original, DiagnosticType warning) {\n    test(options, new String[] { original }, warning);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled, DiagnosticType warning) {\n    test(options, new String[] { original }, new String[] { compiled },\n         warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, DiagnosticType warning) {\n    test(options, original, null, warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType warning) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, 1);\n    assertEquals(\"Expected exactly one warning or error\",\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType[] warnings) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg,\n        expected, actual);\n    }\n  }\n  private Compiler compile(CompilerOptions options, String original) {\n    return compile(options, new String[] { original });\n  }\n  private Compiler compile(CompilerOptions options, String[] original) {\n    Compiler compiler = lastCompiler = new Compiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.compileModules(\n        externs, Lists.newArrayList(CompilerTestCase.createModuleChain(original)),\n        options);\n    return compiler;\n  }\n  private Node parse(String[] original, CompilerOptions options) {\n    Compiler compiler = new Compiler();\n    List<SourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.init(externs, inputs, options);\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node all = compiler.parseInputs();\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node n = all.getLastChild();\n    Node externs = all.getFirstChild();\n\n    (new CreateSyntheticBlocks(\n        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n    (new Normalize(compiler, false)).process(externs, n);\n    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n        externs, n);\n    (new Denormalize(compiler)).process(externs, n);\n    return n;\n  }\n  private CompilerOptions createCompilerOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new GoogleCodingConvention());\n    return options;\n  }\n  public void testIssue701() {\n    // Check ASCII art in license comments.\n    String ascii = \"/**\\n\" +\n        \" * @preserve\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\";\n    String result = \"/*\\n\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\\n\";\n    testSame(createCompilerOptions(), ascii);\n    assertEquals(result, lastCompiler.toSource());\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  /**\n   * Gets the number of properties of this object.\n   */\n  @Override\n  public int getPropertiesCount();\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n  @Override\n  public String getReferenceName();\n  @Override\n  public boolean hasProperty(String propertyName);\n  @Override\n  public JSType getPropertyType(String property);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  /**\n   * Gets the number of properties of this object.\n   */\n  @Override\n  public int getPropertiesCount();\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n  @Override\n  public String getReferenceName();\n  @Override\n  public boolean hasProperty(String propertyName);\n  @Override\n  public JSType getPropertyType(String property);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue700() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @param {{text: string}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp1(opt_data) {\\n\" +\n        \"  return opt_data.text;\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{activity: (boolean|number|string|null|Object)}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp2(opt_data) {\\n\" +\n        \"  /** @notypecheck */\\n\" +\n        \"  function __inner() {\\n\" +\n        \"    return temp1(opt_data.activity);\\n\" +\n        \"  }\\n\" +\n        \"  return __inner();\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{n: number, text: string, b: boolean}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp3(opt_data) {\\n\" +\n        \"  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"function callee() {\\n\" +\n        \"  var output = temp3({\\n\" +\n        \"    n: 0,\\n\" +\n        \"    text: 'a string',\\n\" +\n        \"    b: true\\n\" +\n        \"  })\\n\" +\n        \"  alert(output);\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"callee();\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint);\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue669() throws Exception {\n    testTypes(\n        \"/** @return {{prop1: (Object|undefined)}} */\" +\n         \"function f(a) {\" +\n         \"  var results;\" +\n         \"  if (a) {\" +\n         \"    results = {};\" +\n         \"    results.prop1 = {a: 3};\" +\n         \"  } else {\" +\n         \"    results = {prop2: 3};\" +\n         \"  }\" +\n         \"  return results;\" +\n         \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by VariableReferencePass, identify\n * variables that are used only once and in a way that is safe to move, and then\n * inline them.\n *\n * This pass has two \"modes.\" One mode only inlines variables declared as\n * constants, for legacy compiler clients. The second mode inlines any\n * variable that we can provably inline. Note that the second mode is a\n * superset of the first mode. We only support the first mode for\n * backwards-compatibility with compiler clients that don't want\n * --inline_variables.\n *\n * The approach of this pass is similar to {@link CrossModuleCodeMotion}\n *\n * @author kushal@google.com (Kushal Dave)\n * @author nicksantos@google.com (Nick Santos)\n */\nclass InlineVariables implements CompilerPass {\n  private final AbstractCompiler compiler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(CompilerOptions options, String original) {\n    testSame(options, new String[] { original });\n  }\n  private void testSame(CompilerOptions options, String[] original) {\n    test(options, original, original);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled) {\n    test(options, new String[] { original }, new String[] { compiled });\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled) {\n    Compiler compiler = compile(options, original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    Node expectedRoot = parse(compiled, options);\n    String explanation = expectedRoot.checkTreeEquals(root);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(root) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void test(CompilerOptions options,\n      String original, DiagnosticType warning) {\n    test(options, new String[] { original }, warning);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled, DiagnosticType warning) {\n    test(options, new String[] { original }, new String[] { compiled },\n         warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, DiagnosticType warning) {\n    test(options, original, null, warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType warning) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, 1);\n    assertEquals(\"Expected exactly one warning or error\",\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType[] warnings) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \"+ msg,\n        expected, actual);\n    }\n  }\n  private Compiler compile(CompilerOptions options, String original) {\n    return compile(options, new String[] { original });\n  }\n  private Compiler compile(CompilerOptions options, String[] original) {\n    Compiler compiler = lastCompiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original, CompilerOptions options) {\n    Compiler compiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, options);\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node all = compiler.parseInputs();\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node n = all.getLastChild();\n    Node externs = all.getFirstChild();\n\n    (new CreateSyntheticBlocks(\n        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n    (new Normalize(compiler, false)).process(externs, n);\n    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n        externs, n);\n    (new Denormalize(compiler)).process(externs, n);\n    return n;\n  }\n  private CompilerOptions createCompilerOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new GoogleCodingConvention());\n    return options;\n  }\n  public void testSingletonGetter1() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n        .setOptionsForCompilationLevel(options);\n    options.setCodingConvention(new ClosureCodingConvention());\n    test(options,\n        \"/** @const */\\n\" +\n        \"var goog = goog || {};\\n\" +\n        \"goog.addSingletonGetter = function(ctor) {\\n\" +\n        \"  ctor.getInstance = function() {\\n\" +\n        \"    return ctor.instance_ || (ctor.instance_ = new ctor());\\n\" +\n        \"  };\\n\" +\n        \"};\" +\n        \"function Foo() {}\\n\" +\n        \"goog.addSingletonGetter(Foo);\" +\n        \"Foo.prototype.bar = 1;\" +\n        \"function Bar() {}\\n\" +\n        \"goog.addSingletonGetter(Bar);\" +\n        \"Bar.prototype.bar = 1;\",\n        \"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n/**\n * Nodetraversal allows an iteration through the nodes in the parse tree,\n * and facilitates the optimizations on the parse tree.\n *\n */\npublic class NodeTraversal {\n  private final AbstractCompiler compiler;\n  private final Callback callback;\n  private Node curNode;\n  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n  private final Deque<Node> scopeRoots = new ArrayDeque<Node>();\n  private String sourceName;\n  private InputId inputId;\n  private ScopeCreator scopeCreator;\n  private ScopedCallback scopeCallback;\n  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n/**\n * Nodetraversal allows an iteration through the nodes in the parse tree,\n * and facilitates the optimizations on the parse tree.\n *\n */\npublic class NodeTraversal {\n  private final AbstractCompiler compiler;\n  private final Callback callback;\n  private Node curNode;\n  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n  private final Deque<Node> scopeRoots = new ArrayDeque<Node>();\n  private String sourceName;\n  private InputId inputId;\n  private ScopeCreator scopeCreator;\n  private ScopedCallback scopeCallback;\n  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(CompilerOptions options, String original) {\n    testSame(options, new String[] { original });\n  }\n  private void testSame(CompilerOptions options, String[] original) {\n    test(options, original, original);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled) {\n    test(options, new String[] { original }, new String[] { compiled });\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled) {\n    Compiler compiler = compile(options, original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    Node expectedRoot = parse(compiled, options);\n    String explanation = expectedRoot.checkTreeEquals(root);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(root) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void test(CompilerOptions options,\n      String original, DiagnosticType warning) {\n    test(options, new String[] { original }, warning);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled, DiagnosticType warning) {\n    test(options, new String[] { original }, new String[] { compiled },\n         warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, DiagnosticType warning) {\n    test(options, original, null, warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType warning) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, 1);\n    assertEquals(\"Expected exactly one warning or error\",\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType[] warnings) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \"+ msg,\n        expected, actual);\n    }\n  }\n  private Compiler compile(CompilerOptions options, String original) {\n    return compile(options, new String[] { original });\n  }\n  private Compiler compile(CompilerOptions options, String[] original) {\n    Compiler compiler = lastCompiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original, CompilerOptions options) {\n    Compiler compiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, options);\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node all = compiler.parseInputs();\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node n = all.getLastChild();\n    Node externs = all.getFirstChild();\n\n    (new CreateSyntheticBlocks(\n        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n    (new Normalize(compiler, false)).process(externs, n);\n    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n        externs, n);\n    (new Denormalize(compiler)).process(externs, n);\n    return n;\n  }\n  private CompilerOptions createCompilerOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new GoogleCodingConvention());\n    return options;\n  }\n  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void addNumber(double x);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void addNumber(double x);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreakAtEndOfFile(String js,\n      String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) {\n    assertEquals(expectedWithoutBreakAtEnd,\n        parsePrint(js, false, false, false, 30));\n    assertEquals(expectedWithBreakAtEnd,\n        parsePrint(js, false, false, true, 30));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testMinusNegativeZero() {\n    // Negative zero is weird, because we have to be able to distinguish\n    // it from positive zero (there are some subtle differences in behavior).\n    assertPrint(\"x- -0\", \"x- -0.0\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  @Override\n  String toStringHelper(boolean forAnnotations);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n  private ObjectType implicitPrototypeFallback;\n  private FunctionType ownerFunction = null;\n  private boolean prettyPrint = false;\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n  @Override\n  String toStringHelper(boolean forAnnotations);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testRecursiveRecord() {\n    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n    JSType record = new RecordTypeBuilder(registry)\n        .addProperty(\"loop\", loop, null)\n        .addProperty(\"number\", NUMBER_TYPE, null)\n        .addProperty(\"string\", STRING_TYPE, null)\n        .build();\n    assertEquals(\"{loop: number, number: number, string: string}\", record.toString());\n\n    loop.setReferencedType(record);\n    assertEquals(\"{loop: {...}, number: number, string: string}\", record.toString());\n    assertEquals(\"{loop: ?, number: number, string: string}\", record.toAnnotationString());\n\n    Asserts.assertEquivalenceOperations(record, loop);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A {@code NamedType} is a named reference to some other type.  This provides\n * a convenient mechanism for implementing forward references to types; a\n * {@code NamedType} can be used as a placeholder until its reference is\n * resolved.  It is also useful for representing type names in JsDoc type\n * annotations, some of which may never be resolved (as they may refer to\n * types in host systems not yet supported by JSCompiler, such as the JVM.)<p>\n *\n * An important distinction: {@code NamedType} is a type name reference,\n * whereas {@link ObjectType} is a named type object, such as an Enum name.\n * The Enum itself is typically used only in a dot operator to name one of its\n * constants, or in a declaration, where its name will appear in a\n * NamedType.<p>\n *\n * A {@code NamedType} is not currently a full-fledged typedef, because it\n * cannot resolve to any JavaScript type.  It can only resolve to a named\n * {@link JSTypeRegistry} type, or to {@link FunctionType} or\n * {@link EnumType}.<p>\n *\n * If full typedefs are to be supported, then each method on each type class\n * needs to be reviewed to make sure that everything works correctly through\n * typedefs.  Alternatively, we would need to walk through the parse tree and\n * unroll each reference to a {@code NamedType} to its resolved type before\n * applying the rest of the analysis.<p>\n *\n * TODO(user): Revisit all of this logic.<p>\n *\n * The existing typing logic is hacky.  Unresolved types should get processed\n * in a more consistent way, but with the Rhino merge coming, there will be\n * much that has to be changed.<p>\n *\n */\nclass NamedType extends ProxyObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String reference;\n  private final String sourceName;\n  private final int lineno;\n  private final int charno;\n  private Predicate<JSType> validator;\n  private List<PropertyContinuation> propertyContinuations = null;\n  @Override\n  public String getReferenceName();\n  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A {@code NamedType} is a named reference to some other type.  This provides\n * a convenient mechanism for implementing forward references to types; a\n * {@code NamedType} can be used as a placeholder until its reference is\n * resolved.  It is also useful for representing type names in JsDoc type\n * annotations, some of which may never be resolved (as they may refer to\n * types in host systems not yet supported by JSCompiler, such as the JVM.)<p>\n *\n * An important distinction: {@code NamedType} is a type name reference,\n * whereas {@link ObjectType} is a named type object, such as an Enum name.\n * The Enum itself is typically used only in a dot operator to name one of its\n * constants, or in a declaration, where its name will appear in a\n * NamedType.<p>\n *\n * A {@code NamedType} is not currently a full-fledged typedef, because it\n * cannot resolve to any JavaScript type.  It can only resolve to a named\n * {@link JSTypeRegistry} type, or to {@link FunctionType} or\n * {@link EnumType}.<p>\n *\n * If full typedefs are to be supported, then each method on each type class\n * needs to be reviewed to make sure that everything works correctly through\n * typedefs.  Alternatively, we would need to walk through the parse tree and\n * unroll each reference to a {@code NamedType} to its resolved type before\n * applying the rest of the analysis.<p>\n *\n * TODO(user): Revisit all of this logic.<p>\n *\n * The existing typing logic is hacky.  Unresolved types should get processed\n * in a more consistent way, but with the Rhino merge coming, there will be\n * much that has to be changed.<p>\n *\n */\nclass NamedType extends ProxyObjectType {\n  private static final long serialVersionUID = 1L;\n  private final String reference;\n  private final String sourceName;\n  private final int lineno;\n  private final int charno;\n  private Predicate<JSType> validator;\n  private List<PropertyContinuation> propertyContinuations = null;\n  @Override\n  public String getReferenceName();\n  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testImplementsExtendsLoop() throws Exception {\n    testClosureTypesMultipleWarnings(\n        suppressMissingProperty(\"foo\") +\n            \"/** @constructor \\n * @implements {F} */var G = function() {};\" +\n            \"/** @constructor \\n * @extends {G} */var F = function() {};\" +\n        \"alert((new F).foo);\",\n        Lists.newArrayList(\n            \"Parse error. Cycle detected in inheritance chain of type F\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code refernceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n  private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n  private static final String WINDOW = \"window\";\n  private static final String FUNCTION = \"Function\";\n  private final boolean removeUnreferenced;\n  private final Set<String> globalNames;\n  private final AstChangeProxy changeProxy;\n  private final Set<String> externalNames = Sets.newHashSet();\n  private final List<RefNode> refNodes = Lists.newArrayList();\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code refernceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n  private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n  private static final String WINDOW = \"window\";\n  private static final String FUNCTION = \"Function\";\n  private final boolean removeUnreferenced;\n  private final Set<String> globalNames;\n  private final AstChangeProxy changeProxy;\n  private final Set<String> externalNames = Sets.newHashSet();\n  private final List<RefNode> refNodes = Lists.newArrayList();\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(CompilerOptions options, String original) {\n    testSame(options, new String[] { original });\n  }\n  private void testSame(CompilerOptions options, String[] original) {\n    test(options, original, original);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled) {\n    test(options, new String[] { original }, new String[] { compiled });\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled) {\n    Compiler compiler = compile(options, original);\n    assertEquals(\"Expected no warnings or errors\\n\" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        0, compiler.getErrors().length + compiler.getWarnings().length);\n\n    Node root = compiler.getRoot().getLastChild();\n    Node expectedRoot = parse(compiled, options);\n    String explanation = expectedRoot.checkTreeEquals(root);\n    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n        \"\\nResult: \" + compiler.toSource(root) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void test(CompilerOptions options,\n      String original, DiagnosticType warning) {\n    test(options, new String[] { original }, warning);\n  }\n  private void test(CompilerOptions options,\n      String original, String compiled, DiagnosticType warning) {\n    test(options, new String[] { original }, new String[] { compiled },\n         warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, DiagnosticType warning) {\n    test(options, original, null, warning);\n  }\n  private void test(CompilerOptions options,\n      String[] original, String[] compiled, DiagnosticType warning) {\n    Compiler compiler = compile(options, original);\n    checkUnexpectedErrorsOrWarnings(compiler, 1);\n    assertEquals(\"Expected exactly one warning or error\",\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n    if (compiler.getErrors().length > 0) {\n      assertEquals(warning, compiler.getErrors()[0].getType());\n    } else {\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    if (compiled != null) {\n      Node root = compiler.getRoot().getLastChild();\n      Node expectedRoot = parse(compiled, options);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \"+ msg,\n        expected, actual);\n    }\n  }\n  private Compiler compile(CompilerOptions options, String original) {\n    return compile(options, new String[] { original });\n  }\n  private Compiler compile(CompilerOptions options, String[] original) {\n    Compiler compiler = lastCompiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < original.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.compile(\n        externs, CompilerTestCase.createModuleChain(original), options);\n    return compiler;\n  }\n  private Node parse(String[] original, CompilerOptions options) {\n    Compiler compiler = new Compiler();\n    JSSourceFile[] inputs = new JSSourceFile[original.length];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n    }\n    compiler.init(externs, inputs, options);\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node all = compiler.parseInputs();\n    checkUnexpectedErrorsOrWarnings(compiler, 0);\n    Node n = all.getLastChild();\n    Node externs = all.getFirstChild();\n\n    (new CreateSyntheticBlocks(\n        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n    (new Normalize(compiler, false)).process(externs, n);\n    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n        externs, n);\n    (new Denormalize(compiler)).process(externs, n);\n    return n;\n  }\n  private CompilerOptions createCompilerOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new GoogleCodingConvention());\n    return options;\n  }\n  public void testIssue284() {\n    CompilerOptions options = createCompilerOptions();\n    options.smartNameRemoval = true;\n    test(options,\n        \"var goog = {};\" +\n        \"goog.inherits = function(x, y) {};\" +\n        \"var ns = {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n        \"    ns.PageSelectionModel.FooEvent);\",\n        \"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author pascallouis@google.com (Pascal-Louis Perez)\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private FunctionContents contents = UnknownFunctionContents.get();\n  private JSType returnType = null;\n  private boolean returnTypeInferred = false;\n  private List<ObjectType> implementedInterfaces = null;\n  private List<ObjectType> extendedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private String templateTypeName = null;\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info);\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author pascallouis@google.com (Pascal-Louis Perez)\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private FunctionContents contents = UnknownFunctionContents.get();\n  private JSType returnType = null;\n  private boolean returnTypeInferred = false;\n  private List<ObjectType> implementedInterfaces = null;\n  private List<ObjectType> extendedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private String templateTypeName = null;\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info);\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry);\n  }\n  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\nclass IRFactory {\n  private final String sourceString;\n  private final StaticSourceFile sourceFile;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private final Set<String> reservedKeywords;\n  private final Set<Comment> parsedComments = Sets.newHashSet();\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLinenoCharnoBinop(String binop) {\n    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n        getFirstChild().getFirstChild();\n\n    assertEquals(1, op.getLineno());\n    assertEquals(8, op.getCharno());\n  }\n  private void assertNodeEquality(Node expected, Node found) {\n    String message = expected.checkTreeEquals(found);\n    if (message != null) {\n      fail(message);\n    }\n  }\n  private Node createScript(Node n) {\n    Node script = new Node(Token.SCRIPT);\n    script.setIsSyntheticBlock(true);\n    script.addChildToBack(n);\n    return script;\n  }\n  private Node parseError(String string, String... errors) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n    Node script = null;\n    try {\n      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n      script = ParserRunner.parse(\n          file, string, ParserRunner.createConfig(isIdeMode, mode, false),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  private Node parse(String string, String... warnings) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    Node script = null;\n    try {\n      StaticSourceFile file = new SimpleSourceFile(\"input\", false);\n      script = ParserRunner.parse(\n          file, string, ParserRunner.createConfig(true, mode, false),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  public void testForEach() {\n    parseError(\n        \"function f(stamp, status) {\\n\" +\n        \"  for each ( var curTiming in this.timeLog.timings ) {\\n\" +\n        \"    if ( curTiming.callId == stamp ) {\\n\" +\n        \"      curTiming.flag = status;\\n\" +\n        \"      break;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\",\n        \"unsupported language extension: for each\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testLends10() throws Exception {\n    testTypes(\n        \"function defineClass(x) { return function() {}; } \" +\n        \"/** @constructor */\" +\n        \"var Foo = defineClass(\" +\n        \"    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));\" +\n        \"/** @return {string} */ function f() { return (new Foo()).bar; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void add(String newcode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void add(String newcode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testIssue620() {\n    assertPrint(\"alert(/ / / / /);\", \"alert(/ // / /)\");\n    assertPrint(\"alert(/ // / /);\", \"alert(/ // / /)\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Garbage collection for variable and function definitions. Basically performs\n * a mark-and-sweep type algorithm over the javascript parse tree.\n *\n * For each scope:\n * (1) Scan the variable/function declarations at that scope.\n * (2) Traverse the scope for references, marking all referenced variables.\n *     Unlike other compiler passes, this is a pre-order traversal, not a\n *     post-order traversal.\n * (3) If the traversal encounters an assign without other side-effects,\n *     create a continuation. Continue the continuation iff the assigned\n *     variable is referenced.\n * (4) When the traversal completes, remove all unreferenced variables.\n *\n * If it makes it easier, you can think of the continuations of the traversal\n * as a reference graph. Each continuation represents a set of edges, where the\n * source node is a known variable, and the destination nodes are lazily\n * evaluated when the continuation is executed.\n *\n * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n * between global symbols. However, {@code SmartNameRemoval} cannot handle\n * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n * substantially more complicated because it tries to handle namespaces\n * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n *\n * This pass also uses a more complex analysis of assignments, where\n * an assignment to a variable or a property of that variable does not\n * necessarily count as a reference to that variable, unless we can prove\n * that it modifies external state. This is similar to\n * {@code FlowSensitiveInlineVariables}, except that it works for variables\n * used across scopes.\n *\n */\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final boolean removeGlobals;\n  private boolean preserveFunctionExpressionNames;\n  private final Set<Var> referenced = Sets.newHashSet();\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n  private boolean modifyCallSites;\n  private CallSiteOptimizer callSiteOptimizer;\n  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Garbage collection for variable and function definitions. Basically performs\n * a mark-and-sweep type algorithm over the javascript parse tree.\n *\n * For each scope:\n * (1) Scan the variable/function declarations at that scope.\n * (2) Traverse the scope for references, marking all referenced variables.\n *     Unlike other compiler passes, this is a pre-order traversal, not a\n *     post-order traversal.\n * (3) If the traversal encounters an assign without other side-effects,\n *     create a continuation. Continue the continuation iff the assigned\n *     variable is referenced.\n * (4) When the traversal completes, remove all unreferenced variables.\n *\n * If it makes it easier, you can think of the continuations of the traversal\n * as a reference graph. Each continuation represents a set of edges, where the\n * source node is a known variable, and the destination nodes are lazily\n * evaluated when the continuation is executed.\n *\n * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n * between global symbols. However, {@code SmartNameRemoval} cannot handle\n * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n * substantially more complicated because it tries to handle namespaces\n * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n *\n * This pass also uses a more complex analysis of assignments, where\n * an assignment to a variable or a property of that variable does not\n * necessarily count as a reference to that variable, unless we can prove\n * that it modifies external state. This is similar to\n * {@code FlowSensitiveInlineVariables}, except that it works for variables\n * used across scopes.\n *\n */\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final boolean removeGlobals;\n  private boolean preserveFunctionExpressionNames;\n  private final Set<Var> referenced = Sets.newHashSet();\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n  private boolean modifyCallSites;\n  private CallSiteOptimizer callSiteOptimizer;\n  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue618_1() {\n    this.removeGlobal = false;\n    testSame(\n        \"function f() {\\n\" +\n        \"  var a = [], b;\\n\" +\n        \"  a.push(b = []);\\n\" +\n        \"  b[0] = 1;\\n\" +\n        \"  return a;\\n\" +\n        \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private boolean isFrozen = false;\n  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode);\n  @Override\n  public boolean isEquivalentTo(JSType other);\n  @Override\n  public JSType getLeastSupertype(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private boolean isFrozen = false;\n  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode);\n  @Override\n  public boolean isEquivalentTo(JSType other);\n  @Override\n  public JSType getLeastSupertype(JSType that);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) {\n    assertTrue(ownerType.isPropertyTypeDeclared(prop));\n    assertFalse(ownerType.isPropertyTypeInferred(prop));\n  }\n  private void assertPropertyTypeInferred(ObjectType ownerType, String prop) {\n    assertFalse(ownerType.isPropertyTypeDeclared(prop));\n    assertTrue(ownerType.isPropertyTypeInferred(prop));\n  }\n  private void assertPropertyTypeUnknown(ObjectType ownerType, String prop) {\n    assertFalse(ownerType.isPropertyTypeDeclared(prop));\n    assertFalse(ownerType.isPropertyTypeInferred(prop));\n    assertTrue(ownerType.getPropertyType(prop).isUnknownType());\n  }\n  private void assertReturnTypeEquals(JSType expectedReturnType,\n      JSType function) {\n    assertTrue(function instanceof FunctionType);\n    assertTypeEquals(expectedReturnType,\n        ((FunctionType) function).getReturnType());\n  }\n  private void compare(TernaryValue r, JSType t1, JSType t2) {\n    assertEquals(r, t1.testForEquality(t2));\n    assertEquals(r, t2.testForEquality(t1));\n  }\n  private void assertCanTestForEqualityWith(JSType t1, JSType t2) {\n    assertTrue(t1.canTestForEqualityWith(t2));\n    assertTrue(t2.canTestForEqualityWith(t1));\n  }\n  private void assertCannotTestForEqualityWith(JSType t1, JSType t2) {\n    assertFalse(t1.canTestForEqualityWith(t2));\n    assertFalse(t2.canTestForEqualityWith(t1));\n  }\n  private List<JSType> getTypesToTestForSymmetry() {\n    return Lists.newArrayList(\n        UNKNOWN_TYPE,\n        NULL_TYPE,\n        VOID_TYPE,\n        NUMBER_TYPE,\n        STRING_TYPE,\n        BOOLEAN_TYPE,\n        OBJECT_TYPE,\n        U2U_CONSTRUCTOR_TYPE,\n        LEAST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE,\n        ALL_TYPE,\n        NO_TYPE,\n        NO_OBJECT_TYPE,\n        NO_RESOLVED_TYPE,\n        createUnionType(BOOLEAN_TYPE, STRING_TYPE),\n        createUnionType(NUMBER_TYPE, STRING_TYPE),\n        createUnionType(NULL_TYPE, dateMethod),\n        createUnionType(UNKNOWN_TYPE, dateMethod),\n        createUnionType(namedGoogBar, dateMethod),\n        createUnionType(NULL_TYPE, unresolvedNamedType),\n        enumType,\n        elementsType,\n        dateMethod,\n        functionType,\n        unresolvedNamedType,\n        googBar,\n        namedGoogBar,\n        googBar.getInstanceType(),\n        namedGoogBar,\n        subclassOfUnresolvedNamedType,\n        subclassCtor,\n        recordType,\n        forwardDeclaredNamedType,\n        createUnionType(forwardDeclaredNamedType, NULL_TYPE));\n  }\n  private void testGetTypeUnderEquality(\n      JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n    // creating the pairs\n    TypePair p12 = t1.getTypesUnderEquality(t2);\n    TypePair p21 = t2.getTypesUnderEquality(t1);\n\n    // t1Eq\n    assertTypeEquals(t1Eq, p12.typeA);\n    assertTypeEquals(t1Eq, p21.typeB);\n\n    // t2Eq\n    assertTypeEquals(t2Eq, p12.typeB);\n    assertTypeEquals(t2Eq, p21.typeA);\n  }\n  private void testGetTypesUnderInequality(\n      JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n    // creating the pairs\n    TypePair p12 = t1.getTypesUnderInequality(t2);\n    TypePair p21 = t2.getTypesUnderInequality(t1);\n\n    // t1Eq\n    assertTypeEquals(t1Eq, p12.typeA);\n    assertTypeEquals(t1Eq, p21.typeB);\n\n    // t2Eq\n    assertTypeEquals(t2Eq, p12.typeB);\n    assertTypeEquals(t2Eq, p21.typeA);\n  }\n  private void assertTypeCanAssignToItself(JSType type) {\n    assertTrue(type.canAssignTo(type));\n  }\n  private static boolean containsType(\n      Iterable<? extends JSType> types, JSType type) {\n    for (JSType alt : types) {\n      if (alt.isEquivalentTo(type)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  private static boolean assertTypeListEquals(\n      Iterable<? extends JSType> typeListA,\n      Iterable<? extends JSType> typeListB) {\n    for (JSType alt : typeListA) {\n      assertTrue(\n          \"List : \" + typeListA + \"\\n\" +\n          \"does not contain: \" + alt,\n          containsType(typeListA, alt));\n    }\n    for (JSType alt : typeListB) {\n      assertTrue(\n          \"List : \" + typeListB + \"\\n\" +\n          \"does not contain: \" + alt,\n          containsType(typeListB, alt));\n    }\n    return false;\n  }\n  private ArrowType createArrowType(Node params) {\n    return registry.createArrowType(params);\n  }\n  public void testRecordTypeLeastSuperType2() {\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    builder.addProperty(\"e\", NUMBER_TYPE, null);\n    builder.addProperty(\"b\", STRING_TYPE, null);\n    builder.addProperty(\"c\", STRING_TYPE, null);\n    JSType otherRecordType = builder.build();\n\n    assertTypeEquals(\n        registry.createUnionType(recordType, otherRecordType),\n        recordType.getLeastSupertype(otherRecordType));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class for parsing version 3 of the SourceMap format, as produced by the\n * Closure Compiler, etc.\n * http://code.google.com/p/closure-compiler/wiki/SourceMaps\n * @author johnlenz@google.com (John Lenz)\n */\npublic class SourceMapConsumerV3 implements SourceMapConsumer,\n    SourceMappingReversable {\n  private String[] sources;\n  private String[] names;\n  private int lineCount;\n  private ArrayList<ArrayList<Entry>> lines = null;\n  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry);\n}\n/**\n * Collects information mapping the generated (compiled) source back to\n * its original source for debugging purposes.\n *\n * @see CodeConsumer\n * @see CodeGenerator\n * @see CodePrinter\n *\n */\npublic class SourceMap {\n  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition);\n  public void appendTo(Appendable out, String name) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class for parsing version 3 of the SourceMap format, as produced by the\n * Closure Compiler, etc.\n * http://code.google.com/p/closure-compiler/wiki/SourceMaps\n * @author johnlenz@google.com (John Lenz)\n */\npublic class SourceMapConsumerV3 implements SourceMapConsumer,\n    SourceMappingReversable {\n  private String[] sources;\n  private String[] names;\n  private int lineCount;\n  private ArrayList<ArrayList<Entry>> lines = null;\n  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry);\n}\n/**\n * Collects information mapping the generated (compiled) source back to\n * its original source for debugging purposes.\n *\n * @see CodeConsumer\n * @see CodeGenerator\n * @see CodePrinter\n *\n */\npublic class SourceMap {\n  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition);\n  public void appendTo(Appendable out, String name) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private String getEmptyMapFor(String name) throws IOException {\n    StringWriter out = new StringWriter();\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    generator.appendTo(out, name);\n    return out.toString();\n  }\n  public void testParseSourceMetaMap() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    final String MAP1 = \"map1\";\n    final String MAP2 = \"map2\";\n    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n    maps.put(MAP1, result1.sourceMapFileContent);\n    maps.put(MAP2, result2.sourceMapFileContent);\n\n    List<SourceMapSection> sections = Lists.newArrayList();\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    sections.add(SourceMapSection.forURL(MAP1, 0, 0));\n    output.append(result2.generatedSource);\n    sections.add(\n        SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn()));\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n\n    check(inputs, output.toString(), mapContents.toString(),\n      new SourceMapSupplier() {\n        @Override\n        public String getSourceMap(String url){\n          return maps.get(url);\n      }});\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(\n        \"unexpected error(s) : \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue586() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var MyClass = function() {};\" +\n        \"/** @param {boolean} success */\" +\n        \"MyClass.prototype.fn = function(success) {};\" +\n        \"MyClass.prototype.test = function() {\" +\n        \"  this.fn();\" +\n        \"  this.fn = function() {};\" +\n        \"};\",\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n        \"Function requires at least 1 argument(s) \" +\n        \"and no more than 1 argument(s).\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n *  Find all Functions, VARs, and Exception names and make them\n *  unique.  Specifically, it will not modify object properties.\n *  @author johnlenz@google.com (John Lenz)\n *  TODO(johnlenz): Try to merge this with the ScopeCreator.\n */\nclass MakeDeclaredNamesUnique\n    implements NodeTraversal.ScopedCallback {\n  public static final String ARGUMENTS = \"arguments\";\n  private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n  private final Renamer rootRenamer;\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n *  Find all Functions, VARs, and Exception names and make them\n *  unique.  Specifically, it will not modify object properties.\n *  @author johnlenz@google.com (John Lenz)\n *  TODO(johnlenz): Try to merge this with the ScopeCreator.\n */\nclass MakeDeclaredNamesUnique\n    implements NodeTraversal.ScopedCallback {\n  public static final String ARGUMENTS = \"arguments\";\n  private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n  private final Renamer rootRenamer;\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent);\n  @Override\n  public void enterScope(NodeTraversal t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private FunctionInjector getInjector() {\n    Compiler compiler = new Compiler();\n    return new FunctionInjector(\n        compiler, compiler.getUniqueNameIdSupplier(), true,\n        assumeStrictThis, assumeMinimumCapture);\n  }\n  private void validateSourceInfo(Compiler compiler, Node subtree) {\n    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n    // Source information problems are reported as compiler errors.\n    if (compiler.getErrorCount() != 0) {\n      String msg = \"Error encountered: \";\n      for (JSError err : compiler.getErrors()) {\n        msg += err.toString() + \"\\n\";\n      }\n      assertTrue(msg, compiler.getErrorCount() == 0);\n    }\n  }\n  private static Node findFunction(Node n, String name) {\n    if (n.getType() == Token.FUNCTION) {\n      if (n.getFirstChild().getString().equals(name)) {\n        return n;\n      }\n    }\n\n    for (Node c : n.children()) {\n      Node result = findFunction(c, name);\n      if (result != null) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n  private static Node prep(String js) {\n    Compiler compiler = new Compiler();\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n.getFirstChild();\n  }\n  private static Node parse(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private static Node parseExpected(Compiler compiler, String js) {\n    Node n = compiler.parseTestCode(js);\n    String message = \"Unexpected errors: \";\n    JSError[] errs = compiler.getErrors();\n    for (int i = 0; i < errs.length; i++){\n      message += \"\\n\" + errs[i].toString();\n    }\n    assertEquals(message, 0, compiler.getErrorCount());\n    return n;\n  }\n  private static String toSource(Node n) {\n    return new CodePrinter.Builder(n)\n        .setPrettyPrint(false)\n        .setLineBreak(false)\n        .setSourceMap(null)\n        .build();\n  }\n  public void testInline19b() {\n    helperInlineReferenceToFunction(\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() { foo(x,y); }\",\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() {\" +\n           \"{var b$$inline_1=y;\" +\n            \"y = x;\" +\n            \"x = b$$inline_1;}\" +\n        \"}\",\n        \"foo\", INLINE_BLOCK);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLocal(String code, String result) {\n    test(LOCAL_PREFIX + code + LOCAL_POSTFIX,\n         LOCAL_PREFIX + result + LOCAL_POSTFIX);\n  }\n  private void testSameLocal(String code) {\n    testLocal(code, code);\n  }\n  public void testNoInlineDeletedProperties() {\n    testSameLocal(\n        \"var foo = {bar:1};\" +\n        \"delete foo.bar;\" +\n        \"return foo.bar;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Just to fold known methods when they are called with constants.\n *\n */\nclass PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Just to fold known methods when they are called with constants.\n *\n */\nclass PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join()\");\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n        \"x = [foo,\\\"a,b,c\\\"].join()\");\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n        \"x = [\\\"a,b,c\\\",foo].join()\");\n\n    // Works with numbers\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n    // Works on boolean\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n    // Only optimize if it's a size win.\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n\n    // TODO(user): Its possible to fold this better.\n    foldSame(\"x = ['', foo].join('-')\");\n    foldSame(\"x = ['', foo, ''].join()\");\n\n    fold(\"x = ['', '', foo, ''].join(',')\",\n         \"x = [',', foo, ''].join()\");\n    fold(\"x = ['', '', foo, '', ''].join(',')\",\n         \"x = [',', foo, ','].join()\");\n\n    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n         \"x = [',', foo, ',', bar].join()\");\n\n    fold(\"x = [1,2,3].join('abcdef')\",\n         \"x = '1abcdef2abcdef3'\");\n\n    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n    // This can be folded but we don't currently.\n    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void addNumber(double x);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  void addNumber(double x);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testIssue582() {\n    assertPrint(\"var x = -0.0;\", \"var x=-0.0\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  static boolean isSimpleNumber(String s);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  static boolean isSimpleNumber(String s);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testNumericKeys() {\n    assertPrint(\"var x = {010: 1};\", \"var x={8:1}\");\n    assertPrint(\"var x = {'010': 1};\", \"var x={\\\"010\\\":1}\");\n\n    assertPrint(\"var x = {0x10: 1};\", \"var x={16:1}\");\n    assertPrint(\"var x = {'0x10': 1};\", \"var x={\\\"0x10\\\":1}\");\n\n    // I was surprised at this result too.\n    assertPrint(\"var x = {.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n    assertPrint(\"var x = {'.2': 1};\", \"var x={\\\".2\\\":1}\");\n\n    assertPrint(\"var x = {0.2: 1};\", \"var x={\\\"0.2\\\":1}\");\n    assertPrint(\"var x = {'0.2': 1};\", \"var x={\\\"0.2\\\":1}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLocal(String code, String result) {\n    test(LOCAL_PREFIX + code + LOCAL_POSTFIX,\n         LOCAL_PREFIX + result + LOCAL_POSTFIX);\n  }\n  private void testSameLocal(String code) {\n    testLocal(code, code);\n  }\n  public void testBug545() {\n    testLocal(\"var a = {}\", \"\");\n    testLocal(\"var a; a = {}\", \"true\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n  public void setPrototypeBasedOn(ObjectType baseType);\n  @Override\n  public JSType getPropertyType(String name);\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n  public boolean setPrototype(PrototypeObjectType prototype);\n  @Override\n  public boolean isConstructor();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n  public void setPrototypeBasedOn(ObjectType baseType);\n  @Override\n  public JSType getPropertyType(String name);\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n  public boolean setPrototype(PrototypeObjectType prototype);\n  @Override\n  public boolean isConstructor();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Reduces the size of common function expressions.\n *\n * This pass will rewrite:\n *\n * C.prototype.getA = function() { return this.a_ };\n * C.prototype.setA = function(newValue) { this.a_ = newValue };\n *\n * as:\n *\n * C.prototype.getA = JSCompiler_get(\"a_);\n * C.prototype.setA = JSCompiler_set(\"a_);\n *\n * if by doing so we will save bytes, after the helper functions are\n * added and renaming is done.\n *\n */\nclass FunctionRewriter implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private static final int SAVINGS_THRESHOLD = 16;\n  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Reduces the size of common function expressions.\n *\n * This pass will rewrite:\n *\n * C.prototype.getA = function() { return this.a_ };\n * C.prototype.setA = function(newValue) { this.a_ = newValue };\n *\n * as:\n *\n * C.prototype.getA = JSCompiler_get(\"a_);\n * C.prototype.setA = JSCompiler_set(\"a_);\n *\n * if by doing so we will save bytes, after the helper functions are\n * added and renaming is done.\n *\n */\nclass FunctionRewriter implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private static final int SAVINGS_THRESHOLD = 16;\n  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void checkCompilesTo(String src,\n                               String expectedHdr,\n                               String expectedBody,\n                               int repetitions) {\n    StringBuilder srcBuffer = new StringBuilder();\n    StringBuilder expectedBuffer = new StringBuilder();\n\n    expectedBuffer.append(expectedHdr);\n\n    for (int idx = 0; idx < repetitions; idx++) {\n      if (idx != 0) {\n        srcBuffer.append(\";\");\n        expectedBuffer.append(\";\");\n      }\n      srcBuffer.append(src);\n      expectedBuffer.append(expectedBody);\n    }\n    test(srcBuffer.toString(), expectedBuffer.toString());\n  }\n  private void checkCompilesToSame(String src, int repetitions) {\n    checkCompilesTo(src, \"\", src, repetitions);\n  }\n  public void testIssue538() {\n    checkCompilesToSame(      \"/** @constructor */\\n\" +\n        \"WebInspector.Setting = function() {}\\n\" +\n        \"WebInspector.Setting.prototype = {\\n\" +\n        \"    get name0(){return this._name;},\\n\" +\n        \"    get name1(){return this._name;},\\n\" +\n        \"    get name2(){return this._name;},\\n\" +\n        \"    get name3(){return this._name;},\\n\" +\n        \"    get name4(){return this._name;},\\n\" +\n        \"    get name5(){return this._name;},\\n\" +\n        \"    get name6(){return this._name;},\\n\" +\n        \"    get name7(){return this._name;},\\n\" +\n        \"    get name8(){return this._name;},\\n\" +\n        \"    get name9(){return this._name;},\\n\" +\n        \"}\", 1);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An abstract representation of a source file that provides access to\n * language-neutral features. The source file can be loaded from various\n * locations, such as from disk or from a preloaded string.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class SourceFile implements StaticSourceFile, Serializable {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An abstract representation of a source file that provides access to\n * language-neutral features. The source file can be loaded from various\n * locations, such as from disk or from a preloaded string.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class SourceFile implements StaticSourceFile, Serializable {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertRegionWellFormed(String sourceName, int lineNumber) {\n    Region region = provider.getSourceRegion(sourceName, lineNumber);\n    assertNotNull(region);\n    String sourceRegion = region.getSourceExcerpt();\n    assertNotNull(sourceRegion);\n    if (lineNumber == 1) {\n      assertEquals(1, region.getBeginningLineNumber());\n    } else {\n      assertTrue(region.getBeginningLineNumber() <= lineNumber);\n    }\n    assertTrue(lineNumber <= region.getEndingLineNumber());\n    assertNotSame(sourceRegion, 0, sourceRegion.length());\n    assertNotSame(sourceRegion, '\\n', sourceRegion.charAt(0));\n    assertNotSame(sourceRegion,\n        '\\n', sourceRegion.charAt(sourceRegion.length() - 1));\n    String line = provider.getSourceLine(sourceName, lineNumber);\n    assertTrue(sourceRegion, sourceRegion.contains(line));\n  }\n  public void testExceptNoNewLine() throws Exception {\n    assertEquals(\"foo2:first line\", provider.getSourceLine(\"foo2\", 1));\n    assertEquals(\"foo2:second line\", provider.getSourceLine(\"foo2\", 2));\n    assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3));\n    assertEquals(null, provider.getSourceLine(\"foo2\", 4));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This describes the Closure-specific JavaScript coding conventions.\n *\n */\npublic class ClosureCodingConvention extends DefaultCodingConvention {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n      Node callNode);\n  @Override\n  public Bind describeFunctionBind(Node n);\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName);\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent);\n  /**\n   * {@inheritDoc}\n   *\n   * <p>Understands several different inheritance patterns that occur in\n   * Google code (various uses of {@code inherits} and {@code mixin}).\n   */\n  @Override\n  public SubclassRelationship getClassesDefinedByCall(Node callNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This describes the Closure-specific JavaScript coding conventions.\n *\n */\npublic class ClosureCodingConvention extends DefaultCodingConvention {\n  private static final long serialVersionUID = 1L;\n  @Override\n  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n      Node callNode);\n  @Override\n  public Bind describeFunctionBind(Node n);\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName);\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent);\n  /**\n   * {@inheritDoc}\n   *\n   * <p>Understands several different inheritance patterns that occur in\n   * Google code (various uses of {@code inherits} and {@code mixin}).\n   */\n  @Override\n  public SubclassRelationship getClassesDefinedByCall(Node callNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> */\npublic class ClosureCodingConventionTest extends TestCase {\n  private void assertFunctionBind(String code) {\n    Node n = parseTestCode(code);\n    assertNotNull(conv.describeFunctionBind(n.getFirstChild()));\n  }\n  private void assertNotFunctionBind(String code) {\n    Node n = parseTestCode(code);\n    assertNull(conv.describeFunctionBind(n.getFirstChild()));\n  }\n  private void assertRequire(String code) {\n    Node n = parseTestCode(code);\n    assertNotNull(conv.extractClassNameIfRequire(n.getFirstChild(), n));\n  }\n  private void assertNotRequire(String code) {\n    Node n = parseTestCode(code);\n    assertNull(conv.extractClassNameIfRequire(n.getFirstChild(), n));\n  }\n  private void assertNotObjectLiteralCast(String code) {\n    Node n = parseTestCode(code);\n    assertNull(conv.getObjectLiteralCast(null, n.getFirstChild()));\n  }\n  private void assertObjectLiteralCast(String code) {\n    Node n = parseTestCode(code);\n    assertNotNull(conv.getObjectLiteralCast(null, n.getFirstChild()));\n  }\n  private void assertNotClassDefining(String code) {\n    Node n = parseTestCode(code);\n    assertNull(conv.getClassesDefinedByCall(n.getFirstChild()));\n  }\n  private void assertDefinesClasses(String code, String subclassName,\n      String superclassName) {\n    Node n = parseTestCode(code);\n    SubclassRelationship classes =\n        conv.getClassesDefinedByCall(n.getFirstChild());\n    assertNotNull(classes);\n    assertEquals(subclassName, classes.subclassName);\n    assertEquals(superclassName, classes.superclassName);\n  }\n  private Node parseTestCode(String code) {\n    Compiler compiler = new Compiler();\n    return compiler.parseTestCode(code).getFirstChild();\n  }\n  public void testRequire() {\n    assertRequire(\"goog.require('foo')\");\n    assertNotRequire(\"goog.require(foo)\");\n    assertNotRequire(\"goog.require()\");\n    assertNotRequire(\"foo()\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compute the \"liveness\" of all local variables. A variable is \"live\" at a\n * point of a program if the value it is currently holding might be read later.\n * Otherwise, the variable is considered \"dead\" if we know for sure that it will\n * no longer be read. Dead variables are candidates for dead assignment\n * elimination and variable name sharing. The worst case safe assumption is to\n * assume that all variables are live. In that case, we will have no opportunity\n * for optimizations. This is especially the case within a TRY block when an\n * assignment is not guaranteed to take place. We bail out by assuming that\n * all variables are live.\n * <p>\n * Due to the possibility of inner functions and closures, certain \"local\"\n * variables can escape the function. These variables will be considered as\n * global and they can be retrieved with {@link #getEscapedLocals()}.\n *\n */\nclass LiveVariablesAnalysis extends\n    DataFlowAnalysis<Node, LiveVariablesAnalysis.LiveVariableLattice> {\n  public static final String ARGUMENT_ARRAY_ALIAS = \"arguments\";\n  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional);\n  public Set<Var> getEscapedLocals();\n  public int getVarIndex(String var);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compute the \"liveness\" of all local variables. A variable is \"live\" at a\n * point of a program if the value it is currently holding might be read later.\n * Otherwise, the variable is considered \"dead\" if we know for sure that it will\n * no longer be read. Dead variables are candidates for dead assignment\n * elimination and variable name sharing. The worst case safe assumption is to\n * assume that all variables are live. In that case, we will have no opportunity\n * for optimizations. This is especially the case within a TRY block when an\n * assignment is not guaranteed to take place. We bail out by assuming that\n * all variables are live.\n * <p>\n * Due to the possibility of inner functions and closures, certain \"local\"\n * variables can escape the function. These variables will be considered as\n * global and they can be retrieved with {@link #getEscapedLocals()}.\n *\n */\nclass LiveVariablesAnalysis extends\n    DataFlowAnalysis<Node, LiveVariablesAnalysis.LiveVariableLattice> {\n  public static final String ARGUMENT_ARRAY_ALIAS = \"arguments\";\n  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional);\n  public Set<Var> getEscapedLocals();\n  public int getVarIndex(String var);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void assertLiveBeforeX(String src, String var) {\n    FlowState<LiveVariablesAnalysis.LiveVariableLattice> state =\n        getFlowStateAtX(src);\n    assertNotNull(src + \" should contain a label 'X:'\", state);\n    assertTrue(\"Variable\" + var + \" should be live before X\", state.getIn()\n        .isLive(liveness.getVarIndex(var)));\n  }\n  private void assertLiveAfterX(String src, String var) {\n    FlowState<LiveVariablesAnalysis.LiveVariableLattice> state =\n        getFlowStateAtX(src);\n    assertTrue(\"Label X should be in the input program.\", state != null);\n    assertTrue(\"Variable\" + var + \" should be live after X\", state.getOut()\n        .isLive(liveness.getVarIndex(var)));\n  }\n  private void assertNotLiveAfterX(String src, String var) {\n    FlowState<LiveVariablesAnalysis.LiveVariableLattice> state =\n        getFlowStateAtX(src);\n    assertTrue(\"Label X should be in the input program.\", state != null);\n    assertTrue(\"Variable\" + var + \" should not be live after X\", !state\n        .getOut().isLive(liveness.getVarIndex(var)));\n  }\n  private void assertNotLiveBeforeX(String src, String var) {\n    FlowState<LiveVariablesAnalysis.LiveVariableLattice> state =\n        getFlowStateAtX(src);\n    assertTrue(\"Label X should be in the input program.\", state != null);\n    assertTrue(\"Variable\" + var + \" should not be live before X\", !state\n        .getIn().isLive(liveness.getVarIndex(var)));\n  }\n  private FlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX(\n      String src) {\n    liveness = computeLiveness(src);\n    return getFlowStateAtX(liveness.getCfg().getEntry().getValue(), liveness\n        .getCfg());\n  }\n  private FlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX(\n      Node node, ControlFlowGraph<Node> cfg) {\n    if (node.getType() == Token.LABEL) {\n      if (node.getFirstChild().getString().equals(\"X\")) {\n        return cfg.getNode(node.getLastChild()).getAnnotation();\n      }\n    }\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      FlowState<LiveVariablesAnalysis.LiveVariableLattice> state =\n          getFlowStateAtX(c, cfg);\n      if (state != null) {\n        return state;\n      }\n    }\n    return null;\n  }\n  private static void assertEscaped(String src, String name) {\n    for (Var var : computeLiveness(src).getEscapedLocals()) {\n      if (var.name.equals(name)) {\n        return;\n      }\n    }\n    fail(\"Variable \" + name + \" should be in the escaped local list.\");\n  }\n  private static void assertNotEscaped(String src, String name) {\n    for (Var var : computeLiveness(src).getEscapedLocals()) {\n      assertFalse(var.name.equals(name));\n    }\n  }\n  private static LiveVariablesAnalysis computeLiveness(String src) {\n    Compiler compiler = new Compiler();\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new GoogleCodingConvention());\n    compiler.initOptions(options);\n    src = \"function _FUNCTION(param1, param2){\" + src + \"}\";\n    Node n = compiler.parseTestCode(src).removeFirstChild();\n    Node script = new Node(Token.SCRIPT, n);\n    script.setInputId(new InputId(\"test\"));\n    assertEquals(0, compiler.getErrorCount());\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(\n        n, new Scope(script, compiler));\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    cfa.process(null, n);\n    ControlFlowGraph<Node> cfg = cfa.getCfg();\n    LiveVariablesAnalysis analysis =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    analysis.analyze();\n    return analysis;\n  }\n  public void testExpressionInForIn() {\n    assertLiveBeforeX(\"var a = [0]; X:for (a[1] in foo) { }\", \"a\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  public Node parse(JSSourceFile file);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options);\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  @Override\n  public Node getRoot();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  public Node parse(JSSourceFile file);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options);\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  @Override\n  public Node getRoot();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testCheckGlobalThisOff() {\n    args.add(\"--warning_level=VERBOSE\");\n    args.add(\"--jscomp_off=globalThis\");\n    testSame(\"function f() { this.a = 3; }\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg);\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg);\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n    parent.setInputId(new InputId(\"code\"));\n\n    Node externs = new Node(Token.SCRIPT);\n    externs.setInputId(new InputId(\"externs\"));\n\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      Set<String> actualWarningDescriptions = Sets.newHashSet();\n      for (int i = 0; i < descriptions.size(); i++) {\n        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n      }\n      assertEquals(\n          Sets.newHashSet(descriptions), actualWarningDescriptions);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n        .getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry);\n  }\n  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getImpureBooleanValue(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n  static TernaryValue getPureBooleanValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getImpureBooleanValue(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n  static TernaryValue getPureBooleanValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String original, String expected, DiagnosticType warning) {\n    test(new String[] { original }, new String[] { expected }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testIssue504() {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"void function() { alert('hi'); }();\",\n         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  public void testCall1() {\n    test(\"Math.sin(0);\", \"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Lightweight message formatter. The format of messages this formatter\n * produces is very compact and to the point.\n *\n */\npublic class LightweightMessageFormatter extends AbstractMessageFormatter {\n  private SourceExcerpt excerpt;\n  public String formatError(JSError error);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Lightweight message formatter. The format of messages this formatter\n * produces is very compact and to the point.\n *\n */\npublic class LightweightMessageFormatter extends AbstractMessageFormatter {\n  private SourceExcerpt excerpt;\n  public String formatError(JSError error);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private LightweightMessageFormatter formatter(String string) {\n    return new LightweightMessageFormatter(source(string));\n  }\n  private SourceExcerptProvider source(final String source) {\n    return new SourceExcerptProvider() {\n      public String getSourceLine(String sourceName, int lineNumber) {\n        return source;\n      }\n      public Region getSourceRegion(String sourceName, int lineNumber) {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n  private String format(Region region) {\n    return new LineNumberingFormatter().formatRegion(region);\n  }\n  private Region region(final int startLine, final int endLine,\n      final String source) {\n    return new SimpleRegion(startLine, endLine, source);\n  }\n  public void testFormatErrorSpaceEndOfLine1() throws Exception {\n    JSError error = JSError.make(\"javascript/complex.js\",\n        1, 10, FOO_TYPE);\n    LightweightMessageFormatter formatter = formatter(\"assert (1;\");\n    assertEquals(\"javascript/complex.js:1: ERROR - error description here\\n\" + \"assert (1;\\n\" + \"          ^\\n\", formatter.formatError(error));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  public Node parse(JSSourceFile file);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  @Override\n  public Node getRoot();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  private PassConfig passes = null;\n  private List<CompilerInput> externs;\n  private List<JSModule> modules;\n  private JSModuleGraph moduleGraph;\n  private List<CompilerInput> inputs;\n  private ErrorManager errorManager;\n  private WarningsGuard warningsGuard;\n  private Map<String, CompilerInput> inputsByName;\n  private SourceMap sourceMap;\n  private String externExports = null;\n  private int uniqueNameId = 0;\n  private boolean useThreads = true;\n  private boolean hasRegExpGlobalReferences = true;\n  private FunctionInformationMap functionInformationMap;\n  private final StringBuilder debugLog = new StringBuilder();\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n  public PerformanceTracker tracker;\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n  private final PrintStream outStream;\n  private GlobalVarReferenceMap globalRefMap = null;\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap);\n  public Node parse(JSSourceFile file);\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options);\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root);\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors();\n  public void parse();\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n);\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings();\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs();\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options);\n  private Result compile();\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options);\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount();\n  @Override\n  public Node getRoot();\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options);\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options);\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options);\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options);\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource();\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options);\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    CompilerOptions options = new CompilerOptions();\n    // ECMASCRIPT5 is the most forgiving.\n    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n    compiler.init(externs, inputs, options);\n    Node all = compiler.parseInputs();\n    Preconditions.checkState(compiler.getErrorCount() == 0);\n    Preconditions.checkNotNull(all);\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testES5StrictUseStrictMultipleInputs() {\n    args.add(\"--language_in=ECMASCRIPT5_STRICT\");\n    Compiler compiler = compile(new String[] {\"var x = f.function\",\n        \"var y = f.function\", \"var z = f.function\"});\n    String outputSource = compiler.toSource();\n    assertEquals(\"'use strict'\", outputSource.substring(0, 12));\n    assertEquals(outputSource.substring(13).indexOf(\"'use strict'\"), -1);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\000\\\"\");\n    assertPrint(\"var x ='\\\\u00003';\", \"var x=\\\"\\\\0003\\\"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testGetTypedPercent5() throws Exception {\n    String js = \"/** @enum {number} */ keys = {A: 1,B: 2,C: 3};\";\n    assertEquals(100.0, getTypedPercent(js), 0.1);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Analyzes properties on prototypes.\n *\n * Uses a reference graph to analyze prototype properties. Each unique property\n * name is represented by a node in this graph. An edge from property A to\n * property B means that there's a GETPROP access of a property B on some\n * object inside of a method named A.\n *\n * Global functions are also represented by nodes in this graph, with\n * similar semantics.\n *\n */\nclass AnalyzePrototypeProperties implements CompilerPass {\n  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n  private final SymbolType VAR = SymbolType.VAR;\n  private final AbstractCompiler compiler;\n  private final boolean canModifyExterns;\n  private final boolean anchorUnusedVars;\n  private final JSModuleGraph moduleGraph;\n  private final JSModule firstModule;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Analyzes properties on prototypes.\n *\n * Uses a reference graph to analyze prototype properties. Each unique property\n * name is represented by a node in this graph. An edge from property A to\n * property B means that there's a GETPROP access of a property B on some\n * object inside of a method named A.\n *\n * Global functions are also represented by nodes in this graph, with\n * similar semantics.\n *\n */\nclass AnalyzePrototypeProperties implements CompilerPass {\n  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n  private final SymbolType VAR = SymbolType.VAR;\n  private final AbstractCompiler compiler;\n  private final boolean canModifyExterns;\n  private final boolean anchorUnusedVars;\n  private final JSModuleGraph moduleGraph;\n  private final JSModule firstModule;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testAliasing7() {\n    // An exported alias must preserved any referenced values in the\n    // referenced function.\n    testSame(\"function e(){}\" +\n           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n               \"function(){this.method2()};\" +\n           \"e.prototype.method2 = function(){};\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in jsdoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token);\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n  private Node parseFunctionType(JsDocToken token);\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A parser for JSDoc comments.\n *\n */\npublic final class JsDocInfoParser {\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n  private final Node templateNode;\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in jsdoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder);\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse();\n  JSDocInfo retrieveAndResetParsedJSDocInfo();\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString);\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token);\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n  private Node parseFunctionType(JsDocToken token);\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo();\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testParseType(String type) throws Exception {\n    testParseType(type, type);\n  }\n  private void testParseType(\n      String type, String typeExpected) throws Exception {\n    JSDocInfo info = parse(\"@type {\" + type + \"}*/\");\n\n    assertNotNull(info);\n    assertTrue(info.hasType());\n    assertEquals(typeExpected, resolve(info.getType()).toString());\n  }\n  private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker,\n                                                       String description,\n                                                       int startCharno,\n                                                       int endLineno,\n                                                       int endCharno) {\n    assertTrue(marker.description != null);\n    assertEquals(description, marker.description.getItem());\n\n    // Match positional information.\n    assertEquals(marker.annotation.getStartLine(),\n                 marker.description.getStartLine());\n    assertEquals(startCharno, marker.description.getPositionOnStartLine());\n    assertEquals(endLineno, marker.description.getEndLine());\n    assertEquals(endCharno, marker.description.getPositionOnEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker,\n                                            String typeName, int startCharno,\n                                            boolean hasBrackets) {\n\n    assertTrue(marker.type != null);\n    assertTrue(marker.type.getItem().getType() == Token.STRING);\n\n    // Match the name and brackets information.\n    String foundName = marker.type.getItem().getString();\n\n    assertEquals(typeName, foundName);\n    assertEquals(hasBrackets, marker.type.hasBrackets);\n\n    // Match position information.\n    assertEquals(startCharno, marker.type.getPositionOnStartLine());\n\n    int endCharno = startCharno + foundName.length();\n\n    if (hasBrackets) {\n      endCharno += 1;\n    }\n\n    assertEquals(endCharno, marker.type.getPositionOnEndLine());\n    assertEquals(marker.annotation.getStartLine(), marker.type.getStartLine());\n    assertEquals(marker.annotation.getStartLine(), marker.type.getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n                                            String name, int startCharno) {\n    assertTrue(marker.name != null);\n    assertEquals(name, marker.name.getItem());\n\n    assertEquals(startCharno, marker.name.getPositionOnStartLine());\n    assertEquals(startCharno + name.length(),\n                 marker.name.getPositionOnEndLine());\n\n    assertEquals(marker.annotation.getStartLine(), marker.name.getStartLine());\n    assertEquals(marker.annotation.getStartLine(), marker.name.getEndLine());\n\n    return marker;\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno) {\n    return assertAnnotationMarker(jsdoc, annotationName, startLineno,\n                                  startCharno, 0);\n  }\n  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n                                                  String annotationName,\n                                                  int startLineno,\n                                                  int startCharno,\n                                                  int index) {\n\n    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();\n\n    assertTrue(markers.size() > 0);\n\n    int counter = 0;\n\n    for (JSDocInfo.Marker marker : markers) {\n      if (marker.annotation != null) {\n        if (annotationName.equals(marker.annotation.getItem())) {\n\n          if (counter == index) {\n            assertEquals(startLineno, marker.annotation.getStartLine());\n            assertEquals(startCharno,\n                         marker.annotation.getPositionOnStartLine());\n            assertEquals(startLineno, marker.annotation.getEndLine());\n            assertEquals(startCharno + annotationName.length(),\n                         marker.annotation.getPositionOnEndLine());\n\n            return marker;\n          }\n\n          counter++;\n        }\n      }\n    }\n\n    fail(\"No marker found\");\n    return null;\n  }\n  private <T> void assertContains(Collection<T> collection, T item) {\n    assertTrue(collection.contains(item));\n  }\n  private void parseFull(String code, String... warnings) {\n    CompilerEnvirons environment = new CompilerEnvirons();\n\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    environment.setErrorReporter(testErrorReporter);\n\n    environment.setRecordingComments(true);\n    environment.setRecordingLocalJsDocComments(true);\n\n    Parser p = new Parser(environment, testErrorReporter);\n    AstRoot script = p.parse(code, null, 0);\n\n    Config config =\n        new Config(extraAnnotations, extraSuppressions,\n            true, LanguageMode.ECMASCRIPT3, false);\n    for (Comment comment : script.getComments()) {\n      JsDocInfoParser jsdocParser =\n        new JsDocInfoParser(\n            new JsDocTokenStream(comment.getValue().substring(3),\n                comment.getLineno()),\n            comment,\n            script.getSourceName(),\n            config,\n            testErrorReporter);\n      jsdocParser.parse();\n      jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n\n    assertTrue(\"some expected warnings were not reported\",\n        testErrorReporter.hasEncounteredAllWarnings());\n  }\n  private JSDocInfo parseFileOverviewWithoutDoc(String comment,\n                                                String... warnings) {\n    return parse(comment, false, true, warnings);\n  }\n  private JSDocInfo parseFileOverview(String comment, String... warnings) {\n    return parse(comment, true, true, warnings);\n  }\n  private JSDocInfo parse(String comment, String... warnings) {\n    return parse(comment, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n                          String... warnings) {\n    return parse(comment, parseDocumentation, false, warnings);\n  }\n  private JSDocInfo parse(String comment, boolean parseDocumentation,\n      boolean parseFileOverview, String... warnings) {\n    TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n\n    Config config = new Config(extraAnnotations, extraSuppressions,\n        parseDocumentation, LanguageMode.ECMASCRIPT3, false);\n    JsDocInfoParser jsdocParser = new JsDocInfoParser(\n        stream(comment),\n        new Comment(0, 0, CommentType.JSDOC, comment),\n        \"testcode\", config, errorReporter);\n\n    if (fileLevelJsDocBuilder != null) {\n      jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    }\n\n    jsdocParser.parse();\n\n    assertTrue(\"expected warnings were not reported\",\n        errorReporter.hasEncounteredAllWarnings());\n\n    if (parseFileOverview) {\n      return jsdocParser.getFileOverviewJSDocInfo();\n    } else {\n      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n  }\n  private Node parseType(String typeComment) {\n    return JsDocInfoParser.parseTypeString(typeComment);\n  }\n  private JsDocTokenStream stream(String source) {\n    return new JsDocTokenStream(source, 0);\n  }\n  private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) {\n    assertEquals(expected, ((ObjectType) resolve(te)).getParameterType());\n  }\n  private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) {\n    assertEquals(expected, ((ObjectType) resolve(te)).getIndexType());\n  }\n  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testThisTypeOfFunction2() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @type {function(this:F)} */ function f() {}\" +\n        \"f();\",\n        \"\\\"function (this:F): ?\\\" must be called with a \\\"this\\\" type\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Chainable reverse abstract interpreter providing basic functionality.\n *\n */\npublic abstract class ChainableReverseAbstractInterpreter\n    implements ReverseAbstractInterpreter {\n  private ChainableReverseAbstractInterpreter firstLink;\n  private ChainableReverseAbstractInterpreter nextLink;\n  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Chainable reverse abstract interpreter providing basic functionality.\n *\n */\npublic abstract class ChainableReverseAbstractInterpreter\n    implements ReverseAbstractInterpreter {\n  private ChainableReverseAbstractInterpreter firstLink;\n  private ChainableReverseAbstractInterpreter nextLink;\n  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    CompilerTypeTestCase {\n  private void testClosureFunction(String function, JSType type,\n      JSType trueType, JSType falseType) {\n    // function(a) where a : type\n    Node n = compiler.parseTestCode(\"var a; \" + function + \"(a)\");\n    Node call = n.getLastChild().getLastChild();\n    Node name = call.getLastChild();\n\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null);\n    FlowScope flowScope = LinkedFlowScope.createEntryLattice(scope);\n\n    assertEquals(Token.CALL, call.getType());\n    assertEquals(Token.NAME, name.getType());\n\n    GoogleCodingConvention convention = new GoogleCodingConvention();\n    flowScope.inferSlotType(\"a\", type);\n    ClosureReverseAbstractInterpreter rai =\n        new ClosureReverseAbstractInterpreter(convention, registry);\n\n    // trueScope\n    Asserts.assertTypeEquals(\n        trueType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, true)\n        .getSlot(\"a\").getType());\n\n    // falseScope\n    Asserts.assertTypeEquals(\n        falseType,\n        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, false)\n        .getSlot(\"a\").getType());\n  }\n  public void testGoogIsFunction2() throws Exception {\n    testClosureFunction(\"goog.isFunction\",\n        OBJECT_NUMBER_STRING_BOOLEAN,\n        U2U_CONSTRUCTOR_TYPE,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private static final String LEGACY_TYPEDEF = \"goog.typedef\";\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private static final String LEGACY_TYPEDEF = \"goog.typedef\";\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private JSType getNativeType(JSTypeNative nativeType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry);\n  }\n  public void testDuplicateLocalVarDecl() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"/** @param {number} x */\\n\" +\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n        Lists.newArrayList(\n            \"variable x redefined with type string, original definition\" +\n            \" at  [testcode] :2 with type number\",\n            \"initializing variable\\n\" +\n            \"found   : string\\n\" +\n            \"required: number\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A compiler pass that checks that the programmer has obeyed all the access\n * control restrictions indicated by JSDoc annotations, like\n * {@code @private} and {@code @deprecated}.\n *\n * Because access control restrictions are attached to type information,\n * it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo\n * all run before this pass. TypedScopeCreator creates and resolves types,\n * TypeInference propagates those types across the AST, and InferJSDocInfo\n * propagates JSDoc across the types.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private int deprecatedDepth = 0;\n  private int methodDepth = 0;\n  private JSType currentClass = null;\n  private final Multimap<String, String> initializedConstantProperties;\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A compiler pass that checks that the programmer has obeyed all the access\n * control restrictions indicated by JSDoc annotations, like\n * {@code @private} and {@code @deprecated}.\n *\n * Because access control restrictions are attached to type information,\n * it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo\n * all run before this pass. TypedScopeCreator creates and resolves types,\n * TypeInference propagates those types across the AST, and InferJSDocInfo\n * propagates JSDoc across the types.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private int deprecatedDepth = 0;\n  private int methodDepth = 0;\n  private JSType currentClass = null;\n  private final Multimap<String, String> initializedConstantProperties;\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testDep(String js, String reason,\n                       DiagnosticType error,\n                       DiagnosticType errorWithMessage) {\n\n    // Test without a reason.\n    test(String.format(js, \"\"), null, error);\n\n    // Test with a reason.\n    test(String.format(js, reason), null, errorWithMessage, null, reason);\n  }\n  public void testNoPrivateAccessForProperties6() {\n    // Overriding a private property with a non-private property\n    // in a different file causes problems.\n    test(new String[] {\n      \"/** @constructor */ function Foo() {} \" +\n      \"/** @private */ Foo.prototype.bar_ = function() {};\",\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n      \"function SubFoo() {};\" +\n      \"SubFoo.prototype.bar_ = function() {};\"\n    }, null, BAD_PRIVATE_PROPERTY_ACCESS);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A class to transform the body of a function into a generic block suitable\n * for inlining.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionToBlockMutator {\n  private AbstractCompiler compiler;\n  private Supplier<String> safeNameIdSupplier;\n  /**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop);\n}\n/**\n * RenameLabels renames all the labels so that they have short names, to reduce\n * code size and also to obfuscate the code.\n *\n * Label names have a unique namespace, so variable or function names clashes\n * are not a concern, but keywords clashes are.\n *\n * Additionally, labels names are only within the statements include in the\n * label and do not cross function boundaries. This means that it is possible to\n * create one label name that is used for labels at any given depth of label\n * nesting. Typically, the name \"a\" will be used for all top level labels, \"b\"\n * for the next nested label, and so on. For example:\n *\n * <code>\n * function bar() {\n *   a: {\n *     b: {\n *       foo();\n *     }\n *   }\n *\n *   a: {\n *     b: break a;\n *   }\n * }\n * </code>\n *\n * The general processes is as follows: process() is the entry point for the\n * CompilerPass, and from there a standard \"ScopedCallback\" traversal is done,\n * where \"shouldTraverse\" is called when descending the tree, and the \"visit\" is\n * called in a depth first manner. The name for the label is selected during the\n * decent in \"shouldTraverse\", and the references to the label name are renamed\n * as they are encountered during the \"visit\". This means that if the label is\n * unreferenced, it is known when the label node is visited, and, if so, can be\n * safely removed.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nfinal class RenameLabels implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> nameSupplier;\n  private final boolean removeUnused;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A class to transform the body of a function into a generic block suitable\n * for inlining.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionToBlockMutator {\n  private AbstractCompiler compiler;\n  private Supplier<String> safeNameIdSupplier;\n  /**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop);\n}\n/**\n * RenameLabels renames all the labels so that they have short names, to reduce\n * code size and also to obfuscate the code.\n *\n * Label names have a unique namespace, so variable or function names clashes\n * are not a concern, but keywords clashes are.\n *\n * Additionally, labels names are only within the statements include in the\n * label and do not cross function boundaries. This means that it is possible to\n * create one label name that is used for labels at any given depth of label\n * nesting. Typically, the name \"a\" will be used for all top level labels, \"b\"\n * for the next nested label, and so on. For example:\n *\n * <code>\n * function bar() {\n *   a: {\n *     b: {\n *       foo();\n *     }\n *   }\n *\n *   a: {\n *     b: break a;\n *   }\n * }\n * </code>\n *\n * The general processes is as follows: process() is the entry point for the\n * CompilerPass, and from there a standard \"ScopedCallback\" traversal is done,\n * where \"shouldTraverse\" is called when descending the tree, and the \"visit\" is\n * called in a depth first manner. The name for the label is selected during the\n * decent in \"shouldTraverse\", and the references to the label name are renamed\n * as they are encountered during the \"visit\". This means that if the label is\n * unreferenced, it is known when the label node is visited, and, if so, can be\n * safely removed.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nfinal class RenameLabels implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final Supplier<String> nameSupplier;\n  private final boolean removeUnused;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testInlineFunctions31() {\n    // Don't introduce a duplicate label in the same scope\n    test(\"function foo(){ lab:{4;} }\" +\n        \"lab:{foo();}\",\n        \"lab:{{JSCompiler_inline_label_0:{4}}}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testUnicode() {\n    assertPrint(\"var x ='\\\\x0f';\", \"var x=\\\"\\\\u000f\\\"\");\n    assertPrint(\"var x ='\\\\x68';\", \"var x=\\\"h\\\"\");\n    assertPrint(\"var x ='\\\\x7f';\", \"var x=\\\"\\\\u007f\\\"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryFoldComparison(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryFoldComparison(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);  // TODO: why is nothing done with this?\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        new JSSourceFile[] {},\n        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testFoldComparison3() {\n    fold(\"x = !1 == !0\", \"x = false\");\n\n    fold(\"x = !0 == !0\", \"x = true\");\n    fold(\"x = !1 == !1\", \"x = true\");\n    fold(\"x = !1 == null\", \"x = false\");\n    fold(\"x = !1 == !0\", \"x = false\");\n    fold(\"x = !0 == null\", \"x = false\");\n\n    fold(\"!0 == !0\", \"true\");\n    fold(\"!1 == null\", \"false\");\n    fold(\"!1 == !0\", \"false\");\n    fold(\"!0 == null\", \"false\");\n\n    fold(\"x = !0 === !0\", \"x = true\");\n    fold(\"x = !1 === !1\", \"x = true\");\n    fold(\"x = !1 === null\", \"x = false\");\n    fold(\"x = !1 === !0\", \"x = false\");\n    fold(\"x = !0 === null\", \"x = false\");\n\n    fold(\"!0 === !0\", \"true\");\n    fold(\"!1 === null\", \"false\");\n    fold(\"!1 === !0\", \"false\");\n    fold(\"!0 === null\", \"false\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Copied from Rhino's ScriptRuntime\n   */\n  static TernaryValue isStrWhiteSpaceChar(int c);\n  /**\n   * Gets the value of a node as a Number, or null if it cannot be converted.\n   * When it returns a non-null Double, this method effectively emulates the\n   * <code>Number()</code> JavaScript cast function.\n   */\n  static Double getNumberValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Copied from Rhino's ScriptRuntime\n   */\n  static TernaryValue isStrWhiteSpaceChar(int c);\n  /**\n   * Gets the value of a node as a Number, or null if it cannot be converted.\n   * When it returns a non-null Double, this method effectively emulates the\n   * <code>Number()</code> JavaScript cast function.\n   */\n  static Double getNumberValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);  // TODO: why is nothing done with this?\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        new JSSourceFile[] {},\n        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testIEString() {\n    testSame(\"!+'\\\\v1'\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Removes local variable assignments that are useless based on information from\n * {@link LiveVariablesAnalysis}. If there is an assignment to variable\n * {@code x} and {@code x} is dead after this assignment, we know that the\n * current content of {@code x} will not be read and this assignment is useless.\n *\n */\nclass DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private LiveVariablesAnalysis liveness;\n  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable);\n  /**\n   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n   * the root, this function returns true if there exists a read of that\n   * variable before a write to that variable that is on the right side of n.\n   *\n   * For example, suppose the node is x = 1:\n   *\n   * y = 1, x = 1; // false, there is no reads at all.\n   * y = 1, x = 1, print(x) // true, there is a read right of n.\n   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but\n   *                               // it is after a write.\n   *\n   * @param n The current node we should look at.\n   * @param exprRoot The node\n   */\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Removes local variable assignments that are useless based on information from\n * {@link LiveVariablesAnalysis}. If there is an assignment to variable\n * {@code x} and {@code x} is dead after this assignment, we know that the\n * current content of {@code x} will not be read and this assignment is useless.\n *\n */\nclass DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private LiveVariablesAnalysis liveness;\n  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable);\n  /**\n   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n   * the root, this function returns true if there exists a read of that\n   * variable before a write to that variable that is on the right side of n.\n   *\n   * For example, suppose the node is x = 1:\n   *\n   * y = 1, x = 1; // false, there is no reads at all.\n   * y = 1, x = 1, print(x) // true, there is a read right of n.\n   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but\n   *                               // it is after a write.\n   *\n   * @param n The current node we should look at.\n   * @param exprRoot The node\n   */\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void inFunction(String src) {\n    inFunction(src, src);\n  }\n  private void inFunction(String src, String expected) {\n    test(\"function FUNC(param1, param2){\" + src + \"}\",\n         \"function FUNC(param1, param2){\" + expected + \"}\");\n  }\n  public void testInExpression2() {\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\n        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");\n\n    inFunction(\n        \"var a; (a = 1) || (a = 2)\",\n        \"var a; 1 || 2\");\n\n    inFunction(\"var a; (a = 1) || (a = 2); return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a = 2 : a;\",\n        \"var a; a = 1; a ?     2 : a;\");\n\n    inFunction(\"var a; a = 1; a ? a = 2 : a; return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a : a = 2;\",\n        \"var a; a = 1; a ? a : 2;\");\n\n    inFunction(\"var a; a = 1; a ? a : a =2; return a\");\n\n    inFunction(\n        \"var a; (a = 1) ? a = 2 : a = 3;\",\n        \"var a;      1  ?     2 :     3;\");\n\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\"var a; (a = 1) ? a = 2 : a = 3; return a\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CodeGenerator generates codes from a parse tree, sending it to the specified\n * CodeConsumer.\n *\n */\nclass CodeGenerator {\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static void checkUnexpectedErrorsOrWarnings(\n      Compiler compiler, int expected) {\n    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n    if (actual != expected) {\n      String msg = \"\";\n      for (JSError err : compiler.getErrors()) {\n        msg += \"Error:\" + err.toString() + \"\\n\";\n      }\n      for (JSError err : compiler.getWarnings()) {\n        msg += \"Warning:\" + err.toString() + \"\\n\";\n      }\n      assertEquals(\"Unexpected warnings or errors.\\n \" + msg, expected, actual);\n    }\n  }\n  private void assertPrint(String js, String expected) {\n    parse(expected); // validate the expected string is valid js\n    assertEquals(expected,\n        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertLineBreak(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertPrettyPrint(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n  }\n  private void assertTypeAnnotations(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, true, false,\n            CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n  }\n  private void assertLineLength(String js, String expected) {\n    assertEquals(expected,\n        parsePrint(js, false, true, 10));\n  }\n  private void testReparse(String code) {\n    Compiler compiler = new Compiler();\n    Node parse1 = parse(code);\n    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n    String explanation = parse1.checkTreeEquals(parse2);\n    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n        \"\\nResult: \" + compiler.toSource(parse2) +\n        \"\\n\" + explanation, explanation);\n  }\n  private void assertPrintNumber(String expected, double number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  private void assertPrintNumber(String expected, int number) {\n    assertPrint(String.valueOf(number), expected);\n    assertPrintNode(expected, Node.newNumber(number));\n  }\n  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\0\\\"\");\n    assertPrint(\"var x ='\\\\x00';\", \"var x=\\\"\\\\0\\\"\");\n    assertPrint(\"var x ='\\\\u0000';\", \"var x=\\\"\\\\0\\\"\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n */\nclass PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  private String join(String operandA, String op, String operandB) {\n    return operandA + \" \" + op + \" \" + operandB;\n  }\n  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n    String resultA = process(exprA);\n    String resultB = process(exprB);\n    if (resultA.equals(print(exprA))) {\n      foldSame(exprA);\n      foldSame(exprB);\n    } else {\n      assertSameResults(exprA, exprB);\n    }\n  }\n  private void assertSameResults(String exprA, String exprB) {\n    assertEquals(\n        \"Expressions did not fold the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA), process(exprB));\n  }\n  private void assertNotSameResults(String exprA, String exprB) {\n    assertFalse(\n        \"Expressions folded the same\\nexprA: \" +\n        exprA + \"\\nexprB: \" + exprB,\n        process(exprA).equals(process(exprB)));\n  }\n  private String process(String js) {\n    return printHelper(js, true);\n  }\n  private String print(String js) {\n    return printHelper(js, false);\n  }\n  private String printHelper(String js, boolean runProcessor) {\n    Compiler compiler = createCompiler();\n    CompilerOptions options = getOptions();\n    compiler.init(\n        new JSSourceFile[] {},\n        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n        options);\n    Node root = compiler.parseInputs();\n    assertTrue(\"Unexpected parse error(s): \" +\n        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"\\nEXPR: \" + js,\n        root != null);\n    Node externsRoot = root.getFirstChild();\n    Node mainRoot = externsRoot.getNext();\n    if (runProcessor) {\n      getProcessor(compiler).process(externsRoot, mainRoot);\n    }\n    return compiler.toSource(mainRoot);\n  }\n  public void testFoldArithmetic() {\n    fold(\"x = 10 + 20\", \"x = 30\");\n    fold(\"x = 2 / 4\", \"x = 0.5\");\n    fold(\"x = 2.25 * 3\", \"x = 6.75\");\n    fold(\"z = x * y\", \"z = x * y\");\n    fold(\"x = y * 5\", \"x = y * 5\");\n    fold(\"x = 1 / 0\", \"x = 1 / 0\");\n    fold(\"x = 3 % 2\", \"x = 1\");\n    fold(\"x = 3 % -2\", \"x = 1\");\n    fold(\"x = -1 % 3\", \"x = -1\");\n    fold(\"x = 1 % 0\", \"x = 1 % 0\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * Checks that all variables are declared, that file-private variables are\n * accessed only in the file that declares them, and that any var references\n * that cross module boundaries respect declared module dependencies.\n *\n */\nclass VarCheck extends AbstractPostOrderCallback implements CompilerPass {\n  private CompilerInput synthesizedExternsInput = null;\n  private Node synthesizedExternsRoot = null;\n  private Set<String> varsToDeclareInExterns = Sets.newHashSet();\n  private final AbstractCompiler compiler;\n  private final boolean sanityCheck;\n  private boolean strictExternCheck;\n  /**\n   * Create a new variable in a synthetic script. This will prevent\n   * subsequent compiler passes from crashing.\n   */\n  private void createSynthesizedExternVar(String varName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\nclass Normalize implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  @Override\n  public void process(Node externs, Node root);\n}\n/**\n * Checks that all variables are declared, that file-private variables are\n * accessed only in the file that declares them, and that any var references\n * that cross module boundaries respect declared module dependencies.\n *\n */\nclass VarCheck extends AbstractPostOrderCallback implements CompilerPass {\n  private CompilerInput synthesizedExternsInput = null;\n  private Node synthesizedExternsRoot = null;\n  private Set<String> varsToDeclareInExterns = Sets.newHashSet();\n  private final AbstractCompiler compiler;\n  private final boolean sanityCheck;\n  private boolean strictExternCheck;\n  /**\n   * Create a new variable in a synthetic script. This will prevent\n   * subsequent compiler passes from crashing.\n   */\n  private void createSynthesizedExternVar(String varName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private String inFunction(String code) {\n    return \"(function(){\" + code + \"})\";\n  }\n  private void testSameInFunction(String code) {\n    testSame(inFunction(code));\n  }\n  private void testInFunction(String code, String expected) {\n    test(inFunction(code), inFunction(expected));\n  }\n  private Set<Node> findNodesWithProperty(Node root, final int prop) {\n    final Set<Node> set = Sets.newHashSet();\n    NodeTraversal.traverse(\n        getLastCompiler(), root, new AbstractPostOrderCallback() {\n        public void visit(NodeTraversal t, Node node, Node parent) {\n          if (node.getBooleanProp(prop)) {\n            set.add(node);\n          }\n        }\n      });\n    return set;\n  }\n    private void testConstantProperties() {\n      test(\"var a={}; a.ACONST = 4;var b = a.ACONST;\",\n           \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;\",\n           \"var a$b$ACONST = 4;var b = a$b$ACONST;\");\n\n      test(\"var a = {FOO: 1};var b = a.FOO;\",\n           \"var a$FOO = 1; var b = a$FOO;\");\n\n      test(\"var EXTERN; var ext; ext.FOO;\", \"var b = EXTERN; var c = ext.FOO\",\n           \"var b = EXTERN; var c = ext.FOO\", null, null);\n\n      test(\"var a={}; a.ACONST = 4; var b = a.ACONST;\",\n           \"var a$ACONST = 4; var b = a$ACONST;\");\n\n      test(\"var a = {}; function foo() { var d = a.CONST; };\" +\n           \"(function(){a.CONST=4})();\",\n           \"var a$CONST;function foo(){var d = a$CONST;};\" +\n           \"(function(){a$CONST = 4})();\");\n\n      test(\"var a = {}; a.ACONST = new Foo(); var b = a.ACONST;\",\n           \"var a$ACONST = new Foo(); var b = a$ACONST;\");\n    }\n  public void testIssue() {\n    super.allowExternsChanges(true);\n    test(\"var a,b,c; var a,b\", \"a(), b()\", \"a(), b()\", null, null);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Collapses multiple variable declarations into a single one. i.e the\n * following:\n *\n * <pre>\n * var a;\n * var b = 1;\n * var c = 2;\n * </pre>\n *\n * becomes:\n *\n * <pre>var a, b = 1, c = 2;</pre>\n *\n * This reduces the generated code size. More optimizations are possible:\n * <li>Group all variable declarations inside a function into one such variable.\n * declaration block.</li>\n * <li>Re-use variables instead of declaring a new one if they are used for\n * only part of a function.</li>\n *\n * Similarly, also collapses assigns like:\n *\n * <pre>\n * a = true;\n * b = true;\n * var c = true;\n * </pre>\n *\n * becomes:\n *\n * <pre>var c = b = a = true;</pre>\n *\n */\nclass CollapseVariableDeclarations implements CompilerPass {\n  private final AbstractCompiler compiler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Collapses multiple variable declarations into a single one. i.e the\n * following:\n *\n * <pre>\n * var a;\n * var b = 1;\n * var c = 2;\n * </pre>\n *\n * becomes:\n *\n * <pre>var a, b = 1, c = 2;</pre>\n *\n * This reduces the generated code size. More optimizations are possible:\n * <li>Group all variable declarations inside a function into one such variable.\n * declaration block.</li>\n * <li>Re-use variables instead of declaring a new one if they are used for\n * only part of a function.</li>\n *\n * Similarly, also collapses assigns like:\n *\n * <pre>\n * a = true;\n * b = true;\n * var c = true;\n * </pre>\n *\n * becomes:\n *\n * <pre>var c = b = a = true;</pre>\n *\n */\nclass CollapseVariableDeclarations implements CompilerPass {\n  private final AbstractCompiler compiler;\n  @Override\n  public void process(Node externs, Node root);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testIssue820() throws Exception {\n    // Don't redeclare function parameters, this is incompatible with\n    // strict mode.\n    testSame(\"function f(a){ var b=1; a=2; var c; }\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  static boolean isBooleanResultHelper(Node n);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * @return Whether the result of node evaluation is always a boolean\n   */\n  static boolean isBooleanResult(Node n);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  static boolean isBooleanResultHelper(Node n);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * @return Whether the result of node evaluation is always a boolean\n   */\n  static boolean isBooleanResult(Node n);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static Node parse(String js) {\n    Compiler compiler = new Compiler();\n    compiler.initCompilerOptionsIfTesting();\n    compiler.getOptions().languageIn = LanguageMode.ECMASCRIPT5;\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private void assertBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private Node parseExpr(String js) {\n    Compiler compiler = new Compiler();\n    CompilerOptions options = new CompilerOptions();\n    options.languageIn = LanguageMode.ECMASCRIPT5;\n    compiler.initOptions(options);\n    Node root = compiler.parseTestCode(js);\n    return root.getFirstChild().getFirstChild();\n  }\n  private void testIsObjectLiteralKey(Node node, boolean expected) {\n    assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent()));\n  }\n  private void testGetFunctionName(Node function, String name) {\n    assertEquals(Token.FUNCTION, function.getType());\n    assertEquals(name, NodeUtil.getFunctionName(function));\n  }\n  private void assertSideEffect(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n  }\n  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n    Node n = parse(js);\n    Compiler compiler = new Compiler();\n    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n  }\n  private void assertMutableState(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayEffectMutableState(n.getFirstChild()));\n  }\n  private void assertContainsAnonFunc(boolean expected, String js) {\n    Node funcParent = findParentOfFuncDescendant(parse(js));\n    assertNotNull(\"Expected function node in parse tree of: \" + js, funcParent);\n    Node funcNode = getFuncChild(funcParent);\n    assertEquals(expected, NodeUtil.isFunctionExpression(funcNode));\n  }\n  private Node findParentOfFuncDescendant(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return n;\n      }\n      Node result = findParentOfFuncDescendant(c);\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }\n  private Node getFuncChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return c;\n      }\n    }\n    return null;\n  }\n  private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) {\n    Set<String> actualNames = Sets.newHashSet();\n    for (Node node : nodes) {\n      actualNames.add(node.getString());\n    }\n    assertEquals(nodeNames, actualNames);\n  }\n  private boolean testLocalValue(String js) {\n    return NodeUtil.evaluatesToLocalValue(getNode(js));\n  }\n  private boolean testValidDefineValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Node var = script.getFirstChild();\n    Node name = var.getFirstChild();\n    Node value = name.getFirstChild();\n\n    ImmutableSet<String> defines = ImmutableSet.of();\n    return NodeUtil.isValidDefineValue(value, defines);\n  }\n  public void testIsBooleanResult() {\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));\n\n    // Definitely not boolean\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLinenoCharnoBinop(String binop) {\n    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n        getFirstChild().getFirstChild();\n\n    assertEquals(1, op.getLineno());\n    assertEquals(11, op.getCharno());\n  }\n  private void assertNodeEquality(Node expected, Node found) {\n    String message = expected.checkTreeEquals(found);\n    if (message != null) {\n      fail(message);\n    }\n  }\n  private Node createScript(Node n) {\n    Node script = new Node(Token.SCRIPT);\n    script.addChildToBack(n);\n    return script;\n  }\n  private void parseError(String string, String... errors) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n    Node script = null;\n    try {\n      script = ParserRunner.parse(\n          \"input\", string, ParserRunner.createConfig(true, es5mode, false),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n  }\n  private Node parse(String string, String... warnings) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    Node script = null;\n    try {\n      script = ParserRunner.parse(\n          \"input\", string, ParserRunner.createConfig(true, es5mode, false),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  public void testUnnamedFunctionStatement() {\n    // Statements\n    parseError(\"function() {};\", \"unnamed function statement\");\n    parseError(\"if (true) { function() {}; }\", \"unnamed function statement\");\n    parse(\"function f() {};\");\n    // Expressions\n    parse(\"(function f() {});\");\n    parse(\"(function () {});\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n  public boolean isNoObjectType();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Represents JavaScript value types.<p>\n *\n * Types are split into two separate families: value types and object types.\n *\n * A special {@link UnknownType} exists to represent a wildcard type on which\n * no information can be gathered. In particular, it can assign to everyone,\n * is a subtype of everyone (and everyone is a subtype of it).<p>\n *\n * If you remove the {@link UnknownType}, the set of types in the type system\n * forms a lattice with the {@link #isSubtype} relation defining the partial\n * order of types. All types are united at the top of the lattice by the\n * {@link AllType} and at the bottom by the {@link NoType}.<p>\n *\n */\npublic abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor();\n  public boolean isNoObjectType();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private void testExternFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    testTypes(\n        functionDef,\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\", false);\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testIssue301() throws Exception {\n    testTypes(\n        \"Array.indexOf = function() {};\" +\n        \"var s = 'hello';\" +\n        \"alert(s.toLowerCase.indexOf('1'));\",\n        \"Property indexOf never defined on String.prototype.toLowerCase\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected Compiler createCompiler();\n  private void initConfigFromFlags(String[] args, PrintStream err);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     MyCommandLineRunner runner = new MyCommandLineRunner(args);\n *     if (runner.shouldRunCompiler()) {\n *       runner.run();\n *     } else {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler();\n  @Override\n  protected Compiler createCompiler();\n  private void initConfigFromFlags(String[] args, PrintStream err);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    if (lastArg != null) {\n      args.add(lastArg);\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testVersionFlag2() {\n    lastArg = \"--version\";\n    testSame(\"\");\n    assertEquals( 0, new String(errReader.toByteArray()).indexOf( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n  private Node templateNode;\n  private Node justTransform(AstNode node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testLinenoCharnoBinop(String binop) {\n    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n        getFirstChild().getFirstChild();\n\n    assertEquals(1, op.getLineno());\n    assertEquals(11, op.getCharno());\n  }\n  private void assertNodeEquality(Node expected, Node found) {\n    String message = expected.checkTreeEquals(found);\n    if (message != null) {\n      fail(message);\n    }\n  }\n  private Node createScript(Node n) {\n    Node script = new Node(Token.SCRIPT);\n    script.addChildToBack(n);\n    return script;\n  }\n  private void parseError(String string, String... errors) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n    Node script = null;\n    try {\n      script = ParserRunner.parse(\n          \"input\", string, ParserRunner.createConfig(true, es5mode),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n  }\n  private Node parse(String string, String... warnings) {\n    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n    Node script = null;\n    try {\n      script = ParserRunner.parse(\n          \"input\", string, ParserRunner.createConfig(true, es5mode),\n          testErrorReporter, Logger.getAnonymousLogger());\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    // verifying that all warnings were seen\n    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n\n    return script;\n  }\n  public void testDestructuringAssignForbidden4() {\n    parseError(\"[x, y] = foo();\",\n        \"destructuring assignment forbidden\",\n        \"invalid assignment target\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Removes dead code from a parse tree. The kinds of dead code that this pass\n * removes are:\n *  - Any code following a return statement, such as the <code>alert</code>\n *    call in: <code>if (x) { return; alert('unreachable'); }</code>.\n *  - Statements that have no side effects, such as:\n *    <code>a.b.MyClass.prototype.propertyName;</code> or <code>true;</code>.\n *    That first kind of statement sometimes appears intentionally, so that\n *    prototype properties can be annotated using JSDoc without actually\n *    being initialized.\n *\n */\nclass UnreachableCodeElimination extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback  {\n  private final AbstractCompiler compiler;\n  private final boolean removeNoOpStatements;\n  /**\n   * Tries to remove n if an unconditional branch node (break, continue or\n   * return) if the target of n is the same as the the follow of n. That is, if\n   * we remove n, the control flow remains the same. Also if n targets to\n   * another unconditional branch, this function will recursively try to remove\n   * the target branch as well. The reason why we want to cascade this removal\n   * is because we only run this pass once. If we have code such as\n   *\n   * break -> break -> break\n   *\n   * where all 3 break's are useless. The order of removal matters. When we\n   * first look at the first break, we see that it branches to the 2nd break.\n   * However, if we remove the last break, the 2nd break becomes useless and\n   * finally the first break becomes useless as well.\n   *\n   * @return The target of this jump. If the target is also useless jump,\n   *     the target of that useless jump recursively.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryRemoveUnconditionalBranching(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Removes dead code from a parse tree. The kinds of dead code that this pass\n * removes are:\n *  - Any code following a return statement, such as the <code>alert</code>\n *    call in: <code>if (x) { return; alert('unreachable'); }</code>.\n *  - Statements that have no side effects, such as:\n *    <code>a.b.MyClass.prototype.propertyName;</code> or <code>true;</code>.\n *    That first kind of statement sometimes appears intentionally, so that\n *    prototype properties can be annotated using JSDoc without actually\n *    being initialized.\n *\n */\nclass UnreachableCodeElimination extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback  {\n  private final AbstractCompiler compiler;\n  private final boolean removeNoOpStatements;\n  /**\n   * Tries to remove n if an unconditional branch node (break, continue or\n   * return) if the target of n is the same as the the follow of n. That is, if\n   * we remove n, the control flow remains the same. Also if n targets to\n   * another unconditional branch, this function will recursively try to remove\n   * the target branch as well. The reason why we want to cascade this removal\n   * is because we only run this pass once. If we have code such as\n   *\n   * break -> break -> break\n   *\n   * where all 3 break's are useless. The order of removal matters. When we\n   * first look at the first break, we see that it branches to the 2nd break.\n   * However, if we remove the last break, the 2nd break becomes useless and\n   * finally the first break becomes useless as well.\n   *\n   * @return The target of this jump. If the target is also useless jump,\n   *     the target of that useless jump recursively.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryRemoveUnconditionalBranching(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testCascadedRemovalOfUnlessUnconditonalJumps() {\n    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n         \"switch (a) { case 'a': break; case 'b': case 'c': }\");\n    // Only one break removed per pass.\n    test(\"switch (a) { case 'a': break; case 'b': case 'c': }\",\n         \"switch (a) { case 'a': case 'b': case 'c': }\");\n\n    test(\"function foo() {\" +\n      \"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}\",\n      \"function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}\");\n    test(\"function foo() {\" +\n      \"  switch (a) { case 'a':return; case 'b': case 'c': }}\",\n      \"function foo() { switch (a) { case 'a': case 'b': case 'c': }}\");\n\n    testSame(\"function foo() {\" +\n             \"switch (a) { case 'a':return 2; case 'b':return 1}}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent);\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent);\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static Node parse(String js) {\n    Compiler compiler = new Compiler();\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private void assertBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private Node parseExpr(String js) {\n    Compiler compiler = new Compiler();\n    CompilerOptions options = new CompilerOptions();\n    options.languageIn = LanguageMode.ECMASCRIPT5;\n    compiler.initOptions(options);\n    Node root = compiler.parseTestCode(js);\n    return root.getFirstChild().getFirstChild();\n  }\n  private void testIsObjectLiteralKey(Node node, boolean expected) {\n    assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent()));\n  }\n  private void testGetFunctionName(Node function, String name) {\n    assertEquals(Token.FUNCTION, function.getType());\n    assertEquals(name, NodeUtil.getFunctionName(function));\n  }\n  private void assertSideEffect(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n  }\n  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n    Node n = parse(js);\n    Compiler compiler = new Compiler();\n    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n  }\n  private void assertMutableState(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayEffectMutableState(n.getFirstChild()));\n  }\n  private void assertContainsAnonFunc(boolean expected, String js) {\n    Node funcParent = findParentOfFuncDescendant(parse(js));\n    assertNotNull(\"Expected function node in parse tree of: \" + js, funcParent);\n    Node funcNode = getFuncChild(funcParent);\n    assertEquals(expected, NodeUtil.isFunctionExpression(funcNode));\n  }\n  private Node findParentOfFuncDescendant(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return n;\n      }\n      Node result = findParentOfFuncDescendant(c);\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }\n  private Node getFuncChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return c;\n      }\n    }\n    return null;\n  }\n  private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) {\n    Set<String> actualNames = Sets.newHashSet();\n    for (Node node : nodes) {\n      actualNames.add(node.getString());\n    }\n    assertEquals(nodeNames, actualNames);\n  }\n  private boolean testLocalValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Preconditions.checkState(script.getType() == Token.SCRIPT);\n    Node var = script.getFirstChild();\n    Preconditions.checkState(var.getType() == Token.VAR);\n    Node name = var.getFirstChild();\n    Preconditions.checkState(name.getType() == Token.NAME);\n    Node value = name.getFirstChild();\n\n    return NodeUtil.evaluatesToLocalValue(value);\n  }\n  private boolean testValidDefineValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Node var = script.getFirstChild();\n    Node name = var.getFirstChild();\n    Node value = name.getFirstChild();\n\n    ImmutableSet<String> defines = ImmutableSet.of();\n    return NodeUtil.isValidDefineValue(value, defines);\n  }\n  public void testLocalValue1() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));\n    assertFalse(testLocalValue(\"x()\"));\n    assertFalse(testLocalValue(\"this\"));\n    assertFalse(testLocalValue(\"arguments\"));\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));\n    assertFalse(testLocalValue(\"(new x())['y']\"));\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));\n    assertTrue(testLocalValue(\"undefined\"));\n    assertTrue(testLocalValue(\"Infinity\"));\n    assertTrue(testLocalValue(\"NaN\"));\n    assertTrue(testLocalValue(\"1\"));\n    assertTrue(testLocalValue(\"'a'\"));\n    assertTrue(testLocalValue(\"true\"));\n    assertTrue(testLocalValue(\"false\"));\n    assertTrue(testLocalValue(\"[]\"));\n    assertTrue(testLocalValue(\"{}\"));\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));\n    assertTrue(testLocalValue(\"{'a':x}\"));\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));\n    assertTrue(testLocalValue(\"--x\"));\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));\n    assertFalse(testLocalValue(\"x--\"));\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));\n    assertFalse(testLocalValue(\"x=[]\"));\n    assertFalse(testLocalValue(\"x=y\"));\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));\n    assertTrue(testLocalValue(\"x*=y\"));\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));\n    assertTrue(testLocalValue(\"x!=y\"));\n    assertTrue(testLocalValue(\"x>y\"));\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));\n    assertTrue(testLocalValue(\"(x,1)\"));\n    assertFalse(testLocalValue(\"(x,y)\"));\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));\n    assertFalse(testLocalValue(\"x||1\"));\n    assertFalse(testLocalValue(\"x||y\"));\n    assertFalse(testLocalValue(\"1||y\"));\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));\n    assertFalse(testLocalValue(\"x&&1\"));\n    assertFalse(testLocalValue(\"x&&y\"));\n    assertFalse(testLocalValue(\"1&&y\"));\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));\n    assertFalse(testLocalValue(\"x?x:2\"));\n    assertFalse(testLocalValue(\"x?1:x\"));\n    assertFalse(testLocalValue(\"x?x:y\"));\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));\n    assertTrue(testLocalValue(\"~y\"));\n    assertTrue(testLocalValue(\"y + 1\"));\n    assertTrue(testLocalValue(\"y + z\"));\n    assertTrue(testLocalValue(\"y * z\"));\n\n    assertTrue(testLocalValue(\"'a' in x\"));\n    assertTrue(testLocalValue(\"typeof x\"));\n    assertTrue(testLocalValue(\"x instanceof y\"));\n\n    assertTrue(testLocalValue(\"void x\"));\n    assertTrue(testLocalValue(\"void 0\"));\n\n    assertFalse(testLocalValue(\"{}.x\"));\n\n    assertTrue(testLocalValue(\"{}.toString()\"));\n    assertTrue(testLocalValue(\"o.toString()\"));\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\npublic class PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\npublic class PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  public void testIssue291() {\n    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n    foldSame(\"if (f) { f.onchange(); }\");\n    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n    foldSame(\"if (f) { f['x'](); }\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Removes local variable assignments that are useless based on information from\n * {@link LiveVariablesAnalysis}. If there is an assignment to variable\n * {@code x} and {@code x} is dead after this assignment, we know that the\n * current content of {@code x} will not be read and this assignment is useless.\n *\n */\nclass DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private LiveVariablesAnalysis liveness;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Removes local variable assignments that are useless based on information from\n * {@link LiveVariablesAnalysis}. If there is an assignment to variable\n * {@code x} and {@code x} is dead after this assignment, we know that the\n * current content of {@code x} will not be read and this assignment is useless.\n *\n */\nclass DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    CompilerPass, ScopedCallback {\n  private final AbstractCompiler compiler;\n  private LiveVariablesAnalysis liveness;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testSame(String original) {\n    testSame(new String[] { original });\n  }\n  private void testSame(String[] original) {\n    test(original, original);\n  }\n  private void test(String original, String compiled) {\n    test(new String[] { original }, new String[] { compiled });\n  }\n  private void test(String[] original, String[] compiled) {\n    test(original, compiled, null);\n  }\n  private void test(String[] original, String[] compiled,\n                    DiagnosticType warning) {\n    Compiler compiler = compile(original);\n\n    if (warning == null) {\n      assertEquals(\"Expected no warnings or errors\\n\" +\n          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n          0, compiler.getErrors().length + compiler.getWarnings().length);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n    }\n\n    Node root = compiler.getRoot().getLastChild();\n    if (useStringComparison) {\n      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n    } else {\n      Node expectedRoot = parse(compiled);\n      String explanation = expectedRoot.checkTreeEquals(root);\n      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n          \"\\nResult: \" + compiler.toSource(root) +\n          \"\\n\" + explanation, explanation);\n    }\n  }\n  private void test(String original, DiagnosticType warning) {\n    test(new String[] { original }, warning);\n  }\n  private void test(String[] original, DiagnosticType warning) {\n    Compiler compiler = compile(original);\n    assertEquals(\"Expected exactly one warning or error \" +\n        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n        1, compiler.getErrors().length + compiler.getWarnings().length);\n\n    assertTrue(exitCodes.size() > 0);\n    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n\n    if (compiler.getErrors().length > 0) {\n      assertEquals(1, compiler.getErrors().length);\n      assertEquals(warning, compiler.getErrors()[0].getType());\n      assertEquals(1, lastExitCode);\n    } else {\n      assertEquals(1, compiler.getWarnings().length);\n      assertEquals(warning, compiler.getWarnings()[0].getType());\n      assertEquals(0, lastExitCode);\n    }\n  }\n  private CommandLineRunner createCommandLineRunner(String[] original) {\n    for (int i = 0; i < original.length; i++) {\n      args.add(\"--js\");\n      args.add(\"/path/to/input\" + i + \".js\");\n      if (useModules == ModulePattern.CHAIN) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n      } else if (useModules == ModulePattern.STAR) {\n        args.add(\"--module\");\n        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n      }\n    }\n\n    String[] argStrings = args.toArray(new String[] {});\n    return new CommandLineRunner(\n        argStrings,\n        new PrintStream(outReader),\n        new PrintStream(errReader));\n  }\n  private Compiler compile(String[] original) {\n    CommandLineRunner runner = createCommandLineRunner(original);\n    assertTrue(runner.shouldRunCompiler());\n    Supplier<List<JSSourceFile>> inputsSupplier = null;\n    Supplier<List<JSModule>> modulesSupplier = null;\n\n    if (useModules == ModulePattern.NONE) {\n      List<JSSourceFile> inputs = Lists.newArrayList();\n      for (int i = 0; i < original.length; i++) {\n        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n      }\n      inputsSupplier = Suppliers.ofInstance(inputs);\n    } else if (useModules == ModulePattern.STAR) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleStar(original)));\n    } else if (useModules == ModulePattern.CHAIN) {\n      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n          Lists.<JSModule>newArrayList(\n              CompilerTestCase.createModuleChain(original)));\n    } else {\n      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n    }\n\n    runner.enableTestMode(\n        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n        inputsSupplier,\n        modulesSupplier,\n        new Function<Integer, Boolean>() {\n          @Override\n          public Boolean apply(Integer code) {\n            return exitCodes.add(code);\n          }\n        });\n    runner.run();\n    lastCompiler = runner.getCompiler();\n    lastCommandLineRunner = runner;\n    return lastCompiler;\n  }\n  private Node parse(String[] original) {\n    String[] argStrings = args.toArray(new String[] {});\n    CommandLineRunner runner = new CommandLineRunner(argStrings);\n    Compiler compiler = runner.createCompiler();\n    List<JSSourceFile> inputs = Lists.newArrayList();\n    for (int i = 0; i < original.length; i++) {\n      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n    }\n    compiler.init(externs, inputs, new CompilerOptions());\n    Node all = compiler.parseInputs();\n    Node n = all.getLastChild();\n    return n;\n  }\n  public void testIssue297() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    test(\"function f(p) {\" +\n         \" var x;\" +\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n         \"}\",\n         \"function f(b) {\" +\n         \" var a;\" +\n         \" return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);\" +\n         \"}\");\n  }  \n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref);\n}\n/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n */\nclass GlobalNamespace {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Flattens global objects/namespaces by replacing each '.' with '$' in\n * their names. This reduces the number of property lookups the browser has\n * to do and allows the {@link RenameVars} pass to shorten namespaced names.\n * For example, goog.events.handleEvent() -> goog$events$handleEvent() -> Za().\n *\n * <p>If a global object's name is assigned to more than once, or if a property\n * is added to the global object in a complex expression, then none of its\n * properties will be collapsed (for safety/correctness).\n *\n * <p>If, after a global object is declared, it is never referenced except when\n * its properties are read or set, then the object will be removed after its\n * properties have been collapsed.\n *\n * <p>Uninitialized variable stubs are created at a global object's declaration\n * site for any of its properties that are added late in a local scope.\n *\n * <p>If, after an object is declared, it is referenced directly in a way that\n * might create an alias for it, then none of its properties will be collapsed.\n * This behavior is a safeguard to prevent the values associated with the\n * flattened names from getting out of sync with the object's actual property\n * values. For example, in the following case, an alias a$b, if created, could\n * easily keep the value 0 even after a.b became 5:\n * <code> a = {b: 0}; c = a; c.b = 5; </code>.\n *\n * <p>This pass doesn't flatten property accesses of the form: a[b].\n *\n * <p>For lots of examples, see the unit test.\n *\n */\nclass CollapseProperties implements CompilerPass {\n  private AbstractCompiler compiler;\n  private List<Name> globalNames;\n  private Map<String, Name> nameMap;\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref);\n}\n/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n */\nclass GlobalNamespace {\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n  private List<Name> globalNames = new ArrayList<Name>();\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n * into a form that can be safely concatenated.\n * Does not add a function around the module body but instead adds suffixes\n * to global variables to avoid conflicts.\n * Calls to require are changed to reference the required module directly.\n * goog.provide and goog.require are emitted for closure compiler automatic\n * ordering.\n */\npublic class ProcessCommonJSModules implements CompilerPass {\n  private static final String MODULE_SLASH = \"/\";\n  public static final String DEFAULT_FILENAME_PREFIX = \".\" + MODULE_SLASH;\n  private static final String MODULE_NAME_SEPARATOR = \"\\\\$\";\n  private static final String MODULE_NAME_PREFIX = \"module$\";\n  private final AbstractCompiler compiler;\n  private final String filenamePrefix;\n  private final boolean reportDependencies;\n  private JSModule module;\n  String guessCJSModuleName(String filename);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n * into a form that can be safely concatenated.\n * Does not add a function around the module body but instead adds suffixes\n * to global variables to avoid conflicts.\n * Calls to require are changed to reference the required module directly.\n * goog.provide and goog.require are emitted for closure compiler automatic\n * ordering.\n */\npublic class ProcessCommonJSModules implements CompilerPass {\n  private static final String MODULE_SLASH = \"/\";\n  public static final String DEFAULT_FILENAME_PREFIX = \".\" + MODULE_SLASH;\n  private static final String MODULE_NAME_SEPARATOR = \"\\\\$\";\n  private static final String MODULE_NAME_PREFIX = \"module$\";\n  private final AbstractCompiler compiler;\n  private final String filenamePrefix;\n  private final boolean reportDependencies;\n  private JSModule module;\n  String guessCJSModuleName(String filename);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testGuessModuleName() {\n    ProcessCommonJSModules pass = new ProcessCommonJSModules(null, \"foo\");\n    assertEquals(\"module$baz\", pass.guessCJSModuleName(\"foo/baz.js\"));\n    assertEquals(\"module$baz\", pass.guessCJSModuleName(\"foo\\\\baz.js\"));\n    assertEquals(\"module$bar$baz\", pass.guessCJSModuleName(\"foo\\\\bar\\\\baz.js\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public boolean isConstructor();\n  @Override\n  public boolean hasProperty(String name);\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n  @Override\n  public JSType getPropertyType(String name);\n}\n/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author pascallouis@google.com (Pascal-Louis Perez)\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private JSType returnType = null;\n  private boolean returnTypeInferred = false;\n  private List<ObjectType> implementedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private Node sourceNode = null;\n  private String templateTypeName = null;\n  /**\n   * Sets the FUNCTION node of this function.\n   */\n  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This derived type provides extended information about a function, including\n * its return type and argument types.<p>\n *\n * Note: the parameters list is the LP node that is the parent of the\n * actual NAME node containing the parsed argument list (annotated with\n * JSDOC_TYPE_PROP's for the compile-time type of each argument.\n */\npublic class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType();\n  @Override\n  public boolean isConstructor();\n  @Override\n  public boolean hasProperty(String name);\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n  @Override\n  public JSType getPropertyType(String name);\n}\n/**\n * A builder for FunctionTypes, because FunctionTypes are so\n * ridiculously complex. All methods return {@code this} for ease of use.\n *\n * Right now, this mostly uses JSDocInfo to infer type information about\n * functions. In the long term, developers should extend it to use other\n * signals by overloading the various \"inferXXX\" methods. For example, we\n * might want to use {@code goog.inherits} calls as a signal for inheritance, or\n * {@code return} statements as a signal for return type.\n *\n * NOTE(nicksantos): Organizationally, this feels like it should be in Rhino.\n * But it depends on some coding convention stuff that's really part\n * of JSCompiler.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author pascallouis@google.com (Pascal-Louis Perez)\n */\nfinal class FunctionTypeBuilder {\n  private final String fnName;\n  private final AbstractCompiler compiler;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final Node errorRoot;\n  private final String sourceName;\n  private final Scope scope;\n  private JSType returnType = null;\n  private boolean returnTypeInferred = false;\n  private List<ObjectType> implementedInterfaces = null;\n  private ObjectType baseType = null;\n  private ObjectType thisType = null;\n  private boolean isConstructor = false;\n  private boolean isInterface = false;\n  private Node parametersNode = null;\n  private Node sourceNode = null;\n  private String templateTypeName = null;\n  /**\n   * Sets the FUNCTION node of this function.\n   */\n  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    testClosureTypesMultipleWarnings(js,\n        description == null ? null : Lists.newArrayList(description));\n  }\n  private void testClosureTypesMultipleWarnings(\n      String js, List<String> descriptions) throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (descriptions == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(descriptions.size(), compiler.getWarningCount());\n      for (int i = 0; i < descriptions.size(); i++) {\n        assertEquals(descriptions.get(i),\n            compiler.getWarnings()[i].description);\n      }\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFailure(String js) {\n    test(js, null, CheckGlobalThis.GLOBAL_THIS);\n  }\n  public void testLendsAnnotation3() {\n    testSame(\"/** @constructor */ function F() {}\" +\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n        \"    {foo: function() { return this.foo; }}));\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Replaces goog.provide calls, removes goog.require calls, verifies that\n * goog.require has a corresponding goog.provide and some closure specific\n * simplifications.\n *\n */\nclass ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final boolean rewriteNewDateGoogNow;\n  /**\n   * Registers ProvidedNames for prefix namespaces if they haven't\n   * already been defined. The prefix namespaces must be registered in\n   * order from shortest to longest.\n   *\n   * @param ns The namespace whose prefixes may need to be provided.\n   * @param node The EXPR of the provide call.\n   * @param module The current module.\n   */\n  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Replaces goog.provide calls, removes goog.require calls, verifies that\n * goog.require has a corresponding goog.provide and some closure specific\n * simplifications.\n *\n */\nclass ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements CompilerPass {\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final boolean rewriteNewDateGoogNow;\n  /**\n   * Registers ProvidedNames for prefix namespaces if they haven't\n   * already been defined. The prefix namespaces must be registered in\n   * order from shortest to longest.\n   *\n   * @param ns The namespace whose prefixes may need to be provided.\n   * @param node The EXPR of the provide call.\n   * @param module The current module.\n   */\n  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testProvideInIndependentModules4() {\n    // Regression test for bug 261:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=261\n    test(\n        createModuleStar(\n            \"goog.provide('apps');\",\n            \"goog.provide('apps.foo.bar.B');\",\n            \"goog.provide('apps.foo.bar.C');\"),\n        new String[] {\n            \"var apps = {};apps.foo = {};apps.foo.bar = {}\",\n            \"apps.foo.bar.B = {};\",\n            \"apps.foo.bar.C = {};\",\n        });\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * NodeUtil contains utilities that get properties from the Node object.\n *\n */\npublic final class NodeUtil {\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines);\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler);\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n);\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n);\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   */\n  static TernaryValue getBooleanValue(Node n);\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value);\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n);\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals);\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler);\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n);\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getExpressionBooleanValue(Node n);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private static Node parse(String js) {\n    Compiler compiler = new Compiler();\n    Node n = compiler.parseTestCode(js);\n    assertEquals(0, compiler.getErrorCount());\n    return n;\n  }\n  private void assertBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanTrue(String val) {\n    assertEquals(TernaryValue.TRUE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanFalse(String val) {\n    assertEquals(TernaryValue.FALSE,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void assertExpressionBooleanUnknown(String val) {\n    assertEquals(TernaryValue.UNKNOWN,\n        NodeUtil.getExpressionBooleanValue(getNode(val)));\n  }\n  private void testGetFunctionName(Node function, String name) {\n    assertEquals(Token.FUNCTION, function.getType());\n    assertEquals(name, NodeUtil.getFunctionName(function));\n  }\n  private void assertSideEffect(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n  }\n  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n    Node n = parse(js);\n    Compiler compiler = new Compiler();\n    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n    assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n  }\n  private void assertMutableState(boolean se, String js) {\n    Node n = parse(js);\n    assertEquals(se, NodeUtil.mayEffectMutableState(n.getFirstChild()));\n  }\n  private void assertContainsAnonFunc(boolean expected, String js) {\n    Node funcParent = findParentOfFuncDescendant(parse(js));\n    assertNotNull(\"Expected function node in parse tree of: \" + js, funcParent);\n    Node funcNode = getFuncChild(funcParent);\n    assertEquals(expected, NodeUtil.isFunctionExpression(funcNode));\n  }\n  private Node findParentOfFuncDescendant(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return n;\n      }\n      Node result = findParentOfFuncDescendant(c);\n      if (result != null) {\n        return result;\n      }\n    }\n    return null;\n  }\n  private Node getFuncChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.FUNCTION) {\n        return c;\n      }\n    }\n    return null;\n  }\n  private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) {\n    Set<String> actualNames = Sets.newHashSet();\n    for (Node node : nodes) {\n      actualNames.add(node.getString());\n    }\n    assertEquals(nodeNames, actualNames);\n  }\n  private boolean testLocalValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Preconditions.checkState(script.getType() == Token.SCRIPT);\n    Node var = script.getFirstChild();\n    Preconditions.checkState(var.getType() == Token.VAR);\n    Node name = var.getFirstChild();\n    Preconditions.checkState(name.getType() == Token.NAME);\n    Node value = name.getFirstChild();\n\n    return NodeUtil.evaluatesToLocalValue(value);\n  }\n  private boolean testValidDefineValue(String js) {\n    Node script = parse(\"var test = \" + js +\";\");\n    Node var = script.getFirstChild();\n    Node name = var.getFirstChild();\n    Node value = name.getFirstChild();\n\n    ImmutableSet<String> defines = ImmutableSet.of();\n    return NodeUtil.isValidDefineValue(value, defines);   \n  }\n  public void testValidDefine() {\n    assertTrue(testValidDefineValue(\"1\"));\n    assertTrue(testValidDefineValue(\"-3\"));\n    assertTrue(testValidDefineValue(\"true\"));\n    assertTrue(testValidDefineValue(\"false\"));\n    assertTrue(testValidDefineValue(\"'foo'\"));\n    \n    assertFalse(testValidDefineValue(\"x\"));\n    assertFalse(testValidDefineValue(\"null\"));\n    assertFalse(testValidDefineValue(\"undefined\"));\n    assertFalse(testValidDefineValue(\"NaN\"));\n    \n    assertTrue(testValidDefineValue(\"!true\"));\n    assertTrue(testValidDefineValue(\"-true\"));\n    assertTrue(testValidDefineValue(\"1 & 8\"));\n    assertTrue(testValidDefineValue(\"1 + 8\"));\n    assertTrue(testValidDefineValue(\"'a' + 'b'\"));\n\n    assertFalse(testValidDefineValue(\"1 & foo\"));\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (description == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(1, compiler.getWarningCount());\n      assertEquals(description, compiler.getWarnings()[0].description);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testQualifiedNameInference5() throws Exception {\n    testTypes(\n        \"var ns = {}; \" +\n        \"(function() { \" +\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n        \"(function() { ns.foo(true); })();\",\n        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n *\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Checks the types of JS expressions against any declared type\n * information.</p>\n *\n *\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n  private ScopeCreator scopeCreator;\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n  private boolean reportMissingProperties = true;\n  private InferJSDocInfo inferJSDocInfo = null;\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n  private int noTypeCheckSection = 0;\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot);\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n);\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot);\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent();\n  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFunctionType(String functionDef, String functionType)\n      throws Exception {\n    testFunctionType(functionDef, \"f\", functionType);\n  }\n  private void testFunctionType(String functionDef, String functionName,\n      String functionType) throws Exception {\n    // using the variable initialization check to verify the function's type\n    testTypes(\n        functionDef +\n        \"/** @type number */var a=\" + functionName + \";\",\n        \"initializing variable\\n\" +\n        \"found   : \" + functionType + \"\\n\" +\n        \"required: number\");\n  }\n  private JSType testNameNode(String name) {\n    Node node = Node.newString(Token.NAME, name);\n    Node parent = new Node(Token.SCRIPT, node);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, parent);\n    return node.getJSType();\n  }\n  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n      TypeCheckResult p) {\n    ObjectType goog = (ObjectType) p.scope.getVar(\"goog\").getType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n    JSType googA = goog.getPropertyType(\"A\");\n    assertNotNull(googA);\n    assertTrue(googA instanceof FunctionType);\n    FunctionType googAFunction = (FunctionType) googA;\n    ObjectType classA = googAFunction.getInstanceType();\n    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n  }\n  private double getTypedPercent(String js) throws Exception {\n    Node n = compiler.parseTestCode(js);\n\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    TypeCheck t = makeTypeCheck();\n    t.processForTesting(null, n);\n    return t.getTypedPercent();\n  }\n  private ObjectType getInstanceType(Node js1Node) {\n    JSType type = js1Node.getFirstChild().getJSType();\n    assertNotNull(type);\n    assertTrue(type instanceof FunctionType);\n    FunctionType functionType = (FunctionType) type;\n    assertTrue(functionType.isConstructor());\n    return functionType.getInstanceType();\n  }\n  private void checkObjectType(ObjectType objectType, String propertyName,\n        JSType expectedType) {\n    assertTrue(\"Expected \" + objectType.getReferenceName() +\n        \" to have property \" +\n        propertyName, objectType.hasProperty(propertyName));\n    assertEquals(\"Expected \" + objectType.getReferenceName() +\n        \"'s property \" +\n        propertyName + \" to have type \" + expectedType,\n        expectedType, objectType.getPropertyType(propertyName));\n  }\n  private void testTypes(String js) throws Exception {\n    testTypes(js, (String) null);\n  }\n  private void testTypes(String js, String description) throws Exception {\n    testTypes(js, description, false);\n  }\n  private void testTypes(String js, DiagnosticType type) throws Exception {\n    testTypes(js, type.format(), false);\n  }\n  private void testClosureTypes(String js, String description)\n      throws Exception {\n    Node n = compiler.parseTestCode(js);\n    Node externs = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    // For processing goog.addDependency for forward typedefs.\n    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n        .process(null, n);\n\n    CodingConvention convention = compiler.getCodingConvention();\n    new TypeCheck(compiler,\n        new ClosureReverseAbstractInterpreter(\n            convention, registry).append(\n                new SemanticReverseAbstractInterpreter(\n                    convention, registry))\n            .getFirst(),\n        registry)\n        .processForTesting(null, n);\n\n    assertEquals(0, compiler.getErrorCount());\n\n    if (description == null) {\n      assertEquals(\n          \"unexpected warning(s) : \" +\n          Joiner.on(\", \").join(compiler.getWarnings()),\n          0, compiler.getWarningCount());\n    } else {\n      assertEquals(1, compiler.getWarningCount());\n      assertEquals(description, compiler.getWarnings()[0].description);\n    }\n  }\n  private Node parseAndTypeCheck(String js) {\n    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n  }\n  private Node parseAndTypeCheck(String externs, String js) {\n    return parseAndTypeCheckWithScope(externs, js).root;\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(String js) {\n    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n  }\n  private TypeCheckResult parseAndTypeCheckWithScope(\n      String externs, String js) {\n    compiler.init(\n        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n        compiler.getOptions());\n\n    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    assertEquals(\"parsing error: \" +\n        Joiner.on(\", \").join(compiler.getErrors()),\n        0, compiler.getErrorCount());\n\n    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n    return new TypeCheckResult(n, s);\n  }\n  private Node typeCheck(Node n) {\n    Node externsNode = new Node(Token.BLOCK);\n    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    makeTypeCheck().processForTesting(null, n);\n    return n;\n  }\n  private TypeCheck makeTypeCheck() {\n    return new TypeCheck(\n        compiler,\n        new SemanticReverseAbstractInterpreter(\n            compiler.getCodingConvention(), registry),\n        registry,\n        reportMissingOverrides,\n        CheckLevel.OFF);\n  }\n  public void testFunctionArguments16() throws Exception {\n    testTypes(\n        \"/** @param {...number} var_args */\" +\n        \"function g(var_args) {} g(1, true);\",\n        \"actual parameter 2 of g does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: (number|undefined)\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n*\n*\n */\npublic class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n *\n*\n*\n */\npublic class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void foldSame(String js) {\n    testSame(js);\n  }\n  private void fold(String js, String expected) {\n    test(js, expected);\n  }\n  private void fold(String js, String expected, DiagnosticType warning) {\n    test(js, expected, warning);\n  }\n  private void assertResultString(String js, String expected) {\n    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n\n    scTest.test(js, expected);\n  }\n  public void testFoldBitShifts() {\n    fold(\"x = 1 << 0\", \"x = 1\");\n    fold(\"x = -1 << 0\", \"x = -1\");\n    fold(\"x = 1 << 1\", \"x = 2\");\n    fold(\"x = 3 << 1\", \"x = 6\");\n    fold(\"x = 1 << 8\", \"x = 256\");\n\n    fold(\"x = 1 >> 0\", \"x = 1\");\n    fold(\"x = -1 >> 0\", \"x = -1\");\n    fold(\"x = 1 >> 1\", \"x = 0\");\n    fold(\"x = 2 >> 1\", \"x = 1\");\n    fold(\"x = 5 >> 1\", \"x = 2\");\n    fold(\"x = 127 >> 3\", \"x = 15\");\n    fold(\"x = 3 >> 1\", \"x = 1\");\n    fold(\"x = 3 >> 2\", \"x = 0\");\n    fold(\"x = 10 >> 1\", \"x = 5\");\n    fold(\"x = 10 >> 2\", \"x = 2\");\n    fold(\"x = 10 >> 5\", \"x = 0\");\n\n    fold(\"x = 10 >>> 1\", \"x = 5\");\n    fold(\"x = 10 >>> 2\", \"x = 2\");\n    fold(\"x = 10 >>> 5\", \"x = 0\");\n    fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff\n    fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff\n    fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe\n\n    fold(\"3000000000 << 1\", \"3000000000<<1\",\n         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n    fold(\"1 << 32\", \"1<<32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"1 << -1\", \"1<<32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"3000000000 >> 1\", \"3000000000>>1\",\n        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n    fold(\"1 >> 32\", \"1>>32\",\n        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n    fold(\"1.5 << 0\",  \"1.5<<0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 << .5\",   \"1.5<<0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 >>> .5\",  \"1.5>>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1.5 >> 0\",  \"1.5>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n    fold(\"1 >> .5\",   \"1.5>>0\",\n        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A helper class for passes that want to access all information about where a\n * variable is referenced and declared at once and then make a decision as to\n * how it should be handled, possibly inlining, reordering, or generating\n * warnings. Callers do this by providing {@link Behavior} and then\n * calling {@link #process(Node, Node)}.\n *\n * @author kushal@google.com (Kushal Dave)\n */\nclass ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n  private final Behavior behavior;\n  private final AbstractCompiler compiler;\n  private final Predicate<Var> varFilter;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void testNoInlineAliasesInLoop() {\n    testSame(\n        \"function f() { \" +\n        \"  for (var i = 0; i < 5; i++) {\" +\n        \"    var x = extern();\" +\n        \"    (function() {\" +\n        \"       var y = x; window.setTimeout(function() { extern(y); }, 0);\" +\n        \"     })();\" +\n        \"  }\" +\n        \"}\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  private Node assignLhsChild = null;\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  private void testFailure(String js) {\n    test(js, null, CheckGlobalThis.GLOBAL_THIS);\n  }\n  public void testPropertyOfMethod() {\n    testFailure(\"a.protoype.b = {}; \" +\n        \"a.prototype.b.c = function() { this.foo = 3; };\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Provides static utility methods and decorators for {@link Iterator}\n * instances. The implementations are provided in the iterators subpackage.\n * <p>\n * WARNING: Due to human error certain binary incompatibilities were introduced\n * between Commons Collections 2.1 and 3.0. The class remained source and test\n * compatible, so if you can recompile all your classes and dependencies\n * everything is OK. Those methods which are binary incompatible are marked as\n * such, together with alternate solutions that are binary compatible\n * against versions 2.1.1 and 3.1.\n *\n * @since 2.1\n * @version $Id$\n */\npublic class IteratorUtils {\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Collection<Iterator<? extends E>> iterators);\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator);\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code>.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2);\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize);\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in an array of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null value\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E>... iterators);\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1\n     */\n    public static int size(final Iterator<?> iterator);\n    /**\n     * Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator);\n    /**\n     * Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Provides static utility methods and decorators for {@link Iterator}\n * instances. The implementations are provided in the iterators subpackage.\n * <p>\n * WARNING: Due to human error certain binary incompatibilities were introduced\n * between Commons Collections 2.1 and 3.0. The class remained source and test\n * compatible, so if you can recompile all your classes and dependencies\n * everything is OK. Those methods which are binary incompatible are marked as\n * such, together with alternate solutions that are binary compatible\n * against versions 2.1.1 and 3.1.\n *\n * @since 2.1\n * @version $Id$\n */\npublic class IteratorUtils {\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Collection<Iterator<? extends E>> iterators);\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator);\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code>.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2);\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize);\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in an array of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null value\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E>... iterators);\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1\n     */\n    public static int size(final Iterator<?> iterator);\n    /**\n     * Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator);\n    /**\n     * Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private Iterator<String> getImmutableIterator() {\n        final List<String> list = new ArrayList<String>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        return IteratorUtils.unmodifiableIterator(list.iterator());\n    }\n    private ListIterator<String> getImmutableListIterator() {\n        final List<String> list = new ArrayList<String>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        return IteratorUtils.unmodifiableListIterator(list.listIterator());\n    }\n    private Node[] createNodes() {\n        final Node node1 = createMock(Node.class);\n        final Node node2 = createMock(Node.class);\n        final Node node3 = createMock(Node.class);\n        final Node node4 = createMock(Node.class);\n        replay(node1);\n        replay(node2);\n        replay(node3);\n        replay(node4);\n\n        return new Node[]{node1, node2, node3, node4};\n}\n    private NodeList createNodeList(final Node[] nodes) {\n        return new NodeList() {\n            public Node item(final int index) {\n                return nodes[index];\n            }\n            public int getLength() {\n                return nodes.length;\n            }\n        };\n    }\n    public void testCollatedIterator() {\n        try {\n            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);\n            fail(\"expecting NullPointerException\");\n        } catch (NullPointerException npe) {\n            // expected\n        }\n\n        try {\n            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());\n            fail(\"expecting NullPointerException\");\n        } catch (NullPointerException npe) {\n            // expected\n        }\n\n        // natural ordering\n        Iterator<Integer> it = \n                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());\n\n        List<Integer> result = IteratorUtils.toList(it);\n        assertEquals(12, result.size());\n\n        List<Integer> combinedList = new ArrayList<Integer>();\n        combinedList.addAll(collectionOdd);\n        combinedList.addAll(collectionEven);\n        Collections.sort(combinedList);\n\n        assertEquals(combinedList, result);\n\n        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(collectionOdd, result);\n\n        final Comparator<Integer> reverseComparator =\n                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        Collections.reverse((List<Integer>) collectionOdd);\n        Collections.reverse((List<Integer>) collectionEven);\n        Collections.reverse(combinedList);\n\n        it = IteratorUtils.collatedIterator(reverseComparator,\n                                            collectionOdd.iterator(),\n                                            collectionEven.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(combinedList, result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MultiKey<K> implements Serializable {\n    private static final long serialVersionUID = 4465448607415788805L;\n    private final K[] keys;\n    private transient int hashCode;\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode();\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MultiKey<K> implements Serializable {\n    private static final long serialVersionUID = 4465448607415788805L;\n    private final K[] keys;\n    private transient int hashCode;\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode();\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>        private Object readResolve() {\n            hashCode=2; // simulate different hashCode after deserialization in another process\n            return this;\n        }\n    public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException\n    {\n        final DerivedMultiKey<?> mk = new DerivedMultiKey<String>(\"A\", \"B\");\n\n        // serialize\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n        out.writeObject(mk);\n        out.close();\n\n        // deserialize\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream in = new ObjectInputStream(bais);\n        final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject();\n        in.close();\n\n        assertEquals(mk.hashCode(), mk2.hashCode());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @since 3.2\n * @version $Id$\n * @deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n */\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n    private static final long serialVersionUID = -2214159910087182007L;\n    private final Factory<? extends Collection<V>> collectionFactory;\n    private transient Collection<V> valuesView;\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object put(final K key, final Object value);\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass);\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory);\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException;\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @since 3.2\n * @version $Id$\n * @deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n */\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n    private static final long serialVersionUID = -2214159910087182007L;\n    private final Factory<? extends Collection<V>> collectionFactory;\n    private transient Collection<V> valuesView;\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object put(final K key, final Object value);\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass);\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory);\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException;\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private MultiValueMap<K, V> createTestMap() {\n        return createTestMap(ArrayList.class);\n    }\n    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {\n        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n        map.put((K) \"one\", (V) \"uno\");\n        map.put((K) \"one\", (V) \"un\");\n        map.put((K) \"two\", (V) \"dos\");\n        map.put((K) \"two\", (V) \"deux\");\n        map.put((K) \"three\", (V) \"tres\");\n        map.put((K) \"three\", (V) \"trois\");\n        return map;\n    }\n    private byte[] serialize(Object object) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n\n        oos.writeObject(object);\n        oos.close();\n\n        return baos.toByteArray();\n    }\n    private Object deserialize(byte[] data) throws IOException, ClassNotFoundException {\n        ByteArrayInputStream bais = new ByteArrayInputStream(data);\n        ObjectInputStream iis = new ObjectInputStream(bais);\n        \n        return iis.readObject();\n    }\n    private Map makeEmptyMap() {\n        return new MultiValueMap();\n    }\n    public void testUnsafeDeSerialization() throws Exception {\n        MultiValueMap map1 = MultiValueMap.multiValueMap(new HashMap(), ArrayList.class);\n        byte[] bytes = serialize(map1);\n        Object result = deserialize(bytes);\n        assertEquals(map1, result);\n        \n        MultiValueMap map2 = MultiValueMap.multiValueMap(new HashMap(), (Class) String.class);\n        bytes = serialize(map2);\n        try {\n            result = deserialize(bytes);\n            fail(\"unsafe clazz accepted when de-serializing MultiValueMap\");\n        } catch (UnsupportedOperationException ex) {\n            // expected\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class implements the base PATRICIA algorithm and everything that\n * is related to the {@link Map} interface.\n *\n * @since 4.0\n * @version $Id$\n */\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    private static final long serialVersionUID = 5155253417231339498L;\n    private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n    private transient volatile Set<K> keySet;\n    private transient volatile Collection<V> values;\n    private transient volatile Set<Map.Entry<K,V>> entrySet;\n    private transient int size = 0;\n    @Override\n    public Set<K> keySet();\n    @Override\n    public V put(final K key, final V value);\n    /**\n     * Returns true if 'next' is a valid uplink coming from 'from'.\n     */\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\n    public SortedMap<K, V> prefixMap(final K key);\n    @Override\n    public void clear();\n    @Override\n    public Collection<V> values();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class implements the base PATRICIA algorithm and everything that\n * is related to the {@link Map} interface.\n *\n * @since 4.0\n * @version $Id$\n */\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    private static final long serialVersionUID = 5155253417231339498L;\n    private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n    private transient volatile Set<K> keySet;\n    private transient volatile Collection<V> values;\n    private transient volatile Set<Map.Entry<K,V>> entrySet;\n    private transient int size = 0;\n    @Override\n    public Set<K> keySet();\n    @Override\n    public V put(final K key, final V value);\n    /**\n     * Returns true if 'next' is a valid uplink coming from 'from'.\n     */\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\n    public SortedMap<K, V> prefixMap(final K key);\n    @Override\n    public void clear();\n    @Override\n    public Collection<V> values();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testPrefixMapClear() {\n        Trie<String, Integer> trie = new PatriciaTrie<Integer>();\n        trie.put(\"Anna\", 1);\n        trie.put(\"Anael\", 2);\n        trie.put(\"Analu\", 3);\n        trie.put(\"Andreas\", 4);\n        trie.put(\"Andrea\", 5);\n        trie.put(\"Andres\", 6);\n        trie.put(\"Anatole\", 7);\n        SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<String>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<Integer>(prefixMap.values()));\n\n        prefixMap.clear();\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.keySet().isEmpty());\n        assertTrue(prefixMap.values().isEmpty());\n        assertEquals(new HashSet<String>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<Integer>(trie.values()));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n * <p/>\n * <p/>\n * An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.\n * <p/>\n * <code><pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(&quot;testfile&quot;);\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * out.putNextEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered threadsafe.\n * \n * based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry cpioEntry;\n    private boolean closed = false;\n    private boolean finished;\n    private short entryFormat = FORMAT_NEW;\n    private final HashMap names = new HashMap();\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry\n     * (org.apache.commons.compress.archivers.ArchiveEntry)\n     */\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException;\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException;\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException;\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n * <p/>\n * <p/>\n * An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.\n * <p/>\n * <code><pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(&quot;testfile&quot;);\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * out.putNextEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered threadsafe.\n * \n * based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry cpioEntry;\n    private boolean closed = false;\n    private boolean finished;\n    private short entryFormat = FORMAT_NEW;\n    private final HashMap names = new HashMap();\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry\n     * (org.apache.commons.compress.archivers.ArchiveEntry)\n     */\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException;\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException;\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException;\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCpioUnarchive() throws Exception {\n        final File output = new File(dir, \"bla.cpio\");\n        {\n            final File file1 = getFile(\"test1.xml\");\n            final File file2 = getFile(\"test2.xml\");\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n            os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n\n            os.close();\n            out.close();\n        }\n\n        // Unarchive Operation\n        final File input = output;\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n        Map result = new HashMap();\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            File target = new File(dir, entry.getName());\n            final OutputStream out = new FileOutputStream(target);\n            IOUtils.copy(in, out);\n            out.close();\n            result.put(entry.getName(), target);\n        }\n        in.close();\n\n        int lineSepLength = System.getProperty(\"line.separator\").length();\n\n        File t = (File)result.get(\"test1.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(), 72 + 4 * lineSepLength, t.length());\n\n        t = (File)result.get(\"test2.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(), 73 + 5 * lineSepLength, t.length());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Replacement for <code>java.util.ZipFile</code>.\n *\n * <p>This class adds support for file name encodings other than UTF-8\n * (which is required to work on ZIP files created by native zip tools\n * and is able to skip a preamble like the one found in self\n * extracting archives.  Furthermore it returns instances of\n * <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n * instead of <code>java.util.zip.ZipEntry</code>.</p>\n *\n * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n * have to reimplement all methods anyway.  Like\n * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n * covers and supports compressed and uncompressed entries.  As of\n * Apache Commons Compress it also transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The method signatures mimic the ones of\n * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n *\n * <ul>\n *   <li>There is no getName method.</li>\n *   <li>entries has been renamed to getEntries.</li>\n *   <li>getEntries and getEntry return\n *   <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n *   instances.</li>\n *   <li>close is allowed to throw IOException.</li>\n * </ul>\n *\n */\npublic class ZipFile {\n    private static final int HASH_SIZE = 509;\n    private static final int POS_0 = 0;\n    private static final int POS_1 = 1;\n    private static final int POS_2 = 2;\n    private static final int POS_3 = 3;\n    /**\n     * Returns a named entry - or <code>null</code> if no entry by\n     * that name exists.\n     * @param name name of the entry.\n     * @return the ZipArchiveEntry corresponding to the given name - or\n     * <code>null</code> if not present.\n     */\n    public ZipArchiveEntry getEntry(String name);\n    /**\n     * Returns all entries.\n     *\n     * <p>Entries will be returned in the same order they appear\n     * within the archive's central directory.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     */\n    public Enumeration<ZipArchiveEntry> getEntries();\n    /**\n     * close a zipfile quietly; throw no io fault, do nothing\n     * on a null parameter\n     * @param zipfile file to close, can be null\n     */\n    public static void closeQuietly(ZipFile zipfile);\n    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException;\n    /**\n     * Closes the archive.\n     * @throws IOException if an error occurs closing the archive.\n     */\n    public void close() throws IOException;\n    /**\n     * Returns an InputStream for reading the contents of the given entry.\n     *\n     * @param ze the entry to get the stream for.\n     * @return a stream to read the entry from.\n     * @throws IOException if unable to create an input stream from the zipenty\n     * @throws ZipException if the zipentry uses an unsupported feature\n     */\n    public InputStream getInputStream(ZipArchiveEntry ze)\n        throws IOException, ZipException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Replacement for <code>java.util.ZipFile</code>.\n *\n * <p>This class adds support for file name encodings other than UTF-8\n * (which is required to work on ZIP files created by native zip tools\n * and is able to skip a preamble like the one found in self\n * extracting archives.  Furthermore it returns instances of\n * <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n * instead of <code>java.util.zip.ZipEntry</code>.</p>\n *\n * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n * have to reimplement all methods anyway.  Like\n * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n * covers and supports compressed and uncompressed entries.  As of\n * Apache Commons Compress it also transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The method signatures mimic the ones of\n * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n *\n * <ul>\n *   <li>There is no getName method.</li>\n *   <li>entries has been renamed to getEntries.</li>\n *   <li>getEntries and getEntry return\n *   <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n *   instances.</li>\n *   <li>close is allowed to throw IOException.</li>\n * </ul>\n *\n */\npublic class ZipFile {\n    private static final int HASH_SIZE = 509;\n    private static final int POS_0 = 0;\n    private static final int POS_1 = 1;\n    private static final int POS_2 = 2;\n    private static final int POS_3 = 3;\n    /**\n     * Returns a named entry - or <code>null</code> if no entry by\n     * that name exists.\n     * @param name name of the entry.\n     * @return the ZipArchiveEntry corresponding to the given name - or\n     * <code>null</code> if not present.\n     */\n    public ZipArchiveEntry getEntry(String name);\n    /**\n     * Returns all entries.\n     *\n     * <p>Entries will be returned in the same order they appear\n     * within the archive's central directory.</p>\n     *\n     * @return all entries as {@link ZipArchiveEntry} instances\n     */\n    public Enumeration<ZipArchiveEntry> getEntries();\n    /**\n     * close a zipfile quietly; throw no io fault, do nothing\n     * on a null parameter\n     * @param zipfile file to close, can be null\n     */\n    public static void closeQuietly(ZipFile zipfile);\n    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException;\n    /**\n     * Closes the archive.\n     * @throws IOException if an error occurs closing the archive.\n     */\n    public void close() throws IOException;\n    /**\n     * Returns an InputStream for reading the contents of the given entry.\n     *\n     * @param ze the entry to get the stream for.\n     * @return a stream to read the entry from.\n     * @throws IOException if unable to create an input stream from the zipenty\n     * @throws ZipException if the zipentry uses an unsupported feature\n     */\n    public InputStream getInputStream(ZipArchiveEntry ze)\n        throws IOException, ZipException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void assertCanRead(ZipFile zf, String fileName) throws IOException {\n        ZipArchiveEntry entry = zf.getEntry(fileName);\n        assertNotNull(\"Entry doesn't exist\", entry);\n        InputStream is = zf.getInputStream(entry);\n        assertNotNull(\"InputStream is null\", is);\n        try {\n            is.read();\n        } finally {\n            is.close();\n        }\n    }\n    private static void testFileRoundtrip(String encoding, boolean withEFS,\n                                          boolean withExplicitUnicodeExtra)\n        throws IOException {\n\n        File file = File.createTempFile(encoding + \"-test\", \".zip\");\n        file.deleteOnExit();\n        try {\n            createTestFile(file, encoding, withEFS, withExplicitUnicodeExtra);\n            testFile(file, encoding);\n        } finally {\n            tryHardToDelete(file);\n        }\n    }\n    private static void createTestFile(File file, String encoding,\n                                       boolean withEFS,\n                                       boolean withExplicitUnicodeExtra)\n        throws UnsupportedEncodingException, IOException {\n\n        ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n\n        ZipArchiveOutputStream zos = null;\n        try {\n            zos = new ZipArchiveOutputStream(file);\n            zos.setEncoding(encoding);\n            zos.setUseLanguageEncodingFlag(withEFS);\n            zos.setCreateUnicodeExtraFields(withExplicitUnicodeExtra ? \n                                            ZipArchiveOutputStream\n                                            .UnicodeExtraFieldPolicy.NEVER\n                                            : ZipArchiveOutputStream\n                                            .UnicodeExtraFieldPolicy.ALWAYS);\n\n            ZipArchiveEntry ze = new ZipArchiveEntry(OIL_BARREL_TXT);\n            if (withExplicitUnicodeExtra\n                && !zipEncoding.canEncode(ze.getName())) {\n\n                ByteBuffer en = zipEncoding.encode(ze.getName());\n\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           en.array(),\n                                                           en.arrayOffset(),\n                                                           en.limit()));\n            }\n\n            zos.putArchiveEntry(ze);\n            zos.write(\"Hello, world!\".getBytes(\"US-ASCII\"));\n            zos.closeArchiveEntry();\n\n            ze = new ZipArchiveEntry(EURO_FOR_DOLLAR_TXT);\n            if (withExplicitUnicodeExtra\n                && !zipEncoding.canEncode(ze.getName())) {\n\n                ByteBuffer en = zipEncoding.encode(ze.getName());\n\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           en.array(),\n                                                           en.arrayOffset(),\n                                                           en.limit()));\n            }\n\n            zos.putArchiveEntry(ze);\n            zos.write(\"Give me your money!\".getBytes(\"US-ASCII\"));\n            zos.closeArchiveEntry();\n\n            ze = new ZipArchiveEntry(ASCII_TXT);\n\n            if (withExplicitUnicodeExtra\n                && !zipEncoding.canEncode(ze.getName())) {\n\n                ByteBuffer en = zipEncoding.encode(ze.getName());\n\n                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                           en.array(),\n                                                           en.arrayOffset(),\n                                                           en.limit()));\n            }\n\n            zos.putArchiveEntry(ze);\n            zos.write(\"ascii\".getBytes(\"US-ASCII\"));\n            zos.closeArchiveEntry();\n            \n            zos.finish();\n        } finally {\n            if (zos != null) {\n                try {\n                    zos.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n        }\n    }\n    private static void testFile(File file, String encoding)\n        throws IOException {\n        ZipFile zf = null;\n        try {\n            zf = new ZipFile(file, encoding, false);\n\n            Enumeration<ZipArchiveEntry> e = zf.getEntries();\n            while (e.hasMoreElements()) {\n                ZipArchiveEntry ze = e.nextElement();\n\n                if (ze.getName().endsWith(\"sser.txt\")) {\n                    assertUnicodeName(ze, OIL_BARREL_TXT, encoding);\n\n                } else if (ze.getName().endsWith(\"_for_Dollar.txt\")) {\n                    assertUnicodeName(ze, EURO_FOR_DOLLAR_TXT, encoding);\n                } else if (!ze.getName().equals(ASCII_TXT)) {\n                    throw new AssertionError(\"Urecognized ZIP entry with name [\"\n                                             + ze.getName() + \"] found.\");\n                }\n            }\n        } finally {\n            ZipFile.closeQuietly(zf);\n        }\n    }\n    private static UnicodePathExtraField findUniCodePath(ZipArchiveEntry ze) {\n        return (UnicodePathExtraField)\n            ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n    }\n    private static void assertUnicodeName(ZipArchiveEntry ze,\n                                          String expectedName,\n                                          String encoding)\n        throws IOException {\n        if (!expectedName.equals(ze.getName())) {\n            UnicodePathExtraField ucpf = findUniCodePath(ze);\n            assertNotNull(ucpf);\n\n            ZipEncoding enc = ZipEncodingHelper.getZipEncoding(encoding);\n            ByteBuffer ne = enc.encode(ze.getName());\n\n            CRC32 crc = new CRC32();\n            crc.update(ne.array(),ne.arrayOffset(),ne.limit());\n\n            assertEquals(crc.getValue(), ucpf.getNameCRC32());\n            assertEquals(expectedName, new String(ucpf.getUnicodeName(),\n                                                  UTF_8));\n        }\n    }\n    private static void assertRawNameOfAcsiiTxt(ZipArchiveEntry ze) {\n        byte[] b = ze.getRawName();\n        assertNotNull(b);\n        final int len = ASCII_TXT.length();\n        assertEquals(len, b.length);\n        for (int i = 0; i < len; i++) {\n            assertEquals(\"Byte \" + i, (byte) ASCII_TXT.charAt(i), b[i]);\n        }\n        assertNotSame(b, ze.getRawName());\n    }\n    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n        File archive = new File(new URI(zip.toString()));\n        ZipFile zf = null;\n        try {\n            zf = new ZipFile(archive, null, true);\n            assertCanRead(zf, ASCII_TXT);\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n            assertCanRead(zf, OIL_BARREL_TXT);\n        } finally {\n            ZipFile.closeQuietly(zf);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shortTextFilesAreNoTARs() throws Exception {\n        try {\n            new ArchiveStreamFactory()\n                .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private static final int BUFFER_SIZE = 8 * 1024;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private byte[] readBuf;\n    private TarArchiveEntry currEntry;\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private static final int BUFFER_SIZE = 8 * 1024;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private byte[] readBuf;\n    private TarArchiveEntry currEntry;\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        }\n        in.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * {@link <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">\n * APPNOTE.txt</a>}:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry, Cloneable {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    /**\n     * Is this entry a directory?\n     * @return true if the entry is a directory\n     */\n    @Override\n    public boolean isDirectory();\n    /**\n     * Get the name of the entry.\n     * @return the entry name\n     */\n    @Override\n    public String getName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * {@link <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">\n * APPNOTE.txt</a>}:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry, Cloneable {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    /**\n     * Is this entry a directory?\n     * @return true if the entry is a directory\n     */\n    @Override\n    public boolean isDirectory();\n    /**\n     * Get the name of the entry.\n     * @return the entry name\n     */\n    @Override\n    public String getName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void winzipBackSlashWorkaround() throws Exception {\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n        ZipArchiveInputStream in = null;\n        try {\n            in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n            ZipArchiveEntry zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            assertEquals(\"\\u00e4/\", zae.getName());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void workaroundForBrokenTimeHeader() throws Exception {\n        URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n            TarArchiveEntry tae = in.getNextTarEntry();\n            tae = in.getNextTarEntry();\n            assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n            assertEquals(new Date(0), tae.getLastModifiedDate());\n            assertTrue(tae.isSymbolicLink());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }        \n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * {@link <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">\n * APPNOTE.txt</a>}:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * {@link <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">\n * APPNOTE.txt</a>}:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNullCommentEqualsEmptyComment() {\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n        entry1.setComment(null);\n        entry2.setComment(\"\");\n        entry3.setComment(\"bar\");\n        assertEquals(entry1, entry2);\n        assertFalse(entry1.equals(entry3));\n        assertFalse(entry2.equals(entry3));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void aiffFilesAreNoTARs() throws Exception {\n        InputStream is = null;\n        try {\n            is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n            new ArchiveStreamFactory().createArchiveInputStream(is);\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void datePriorToEpoch(String archive) throws Exception {\n        URL tar = getClass().getResource(archive);\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n            TarArchiveEntry tae = in.getNextTarEntry();\n            assertEquals(\"foo\", tae.getName());\n            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n            cal.set(1969, 11, 31, 23, 59, 59);\n            cal.set(Calendar.MILLISECOND, 0);\n            assertEquals(cal.getTime(), tae.getLastModifiedDate());\n            assertTrue(tae.isCheckSumOK());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n    private TarArchiveInputStream getTestStream(String name) {\n        return new TarArchiveInputStream(\n                TarArchiveInputStreamTest.class.getResourceAsStream(name));\n    }\n    public void testCompress197() throws Exception {\n        TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n        try {\n            TarArchiveEntry entry = tar.getNextTarEntry();\n            while (entry != null) {\n                entry = tar.getNextTarEntry();\n            }\n        } catch (IOException e) {\n            fail(\"COMPRESS-197: \" + e.getMessage());\n        } finally {\n            tar.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    public static final int LONGFILE_POSIX = 3;\n    public static final int BIGNUMBER_ERROR = 0;\n    public static final int BIGNUMBER_STAR = 1;\n    public static final int BIGNUMBER_POSIX = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private int       bigNumberMode = BIGNUMBER_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    private final ZipEncoding encoding;\n    private boolean addPaxHeadersForNonAsciiNames = false;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Whether to add a PAX extension header for non-ASCII file names.\n     * @since 1.4\n     */\n    public void setAddPaxHeadersForNonAsciiNames(boolean b);\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException;\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     * @throws IOException on error\n     */\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    public static final int LONGFILE_POSIX = 3;\n    public static final int BIGNUMBER_ERROR = 0;\n    public static final int BIGNUMBER_STAR = 1;\n    public static final int BIGNUMBER_POSIX = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private int       bigNumberMode = BIGNUMBER_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    private final ZipEncoding encoding;\n    private boolean addPaxHeadersForNonAsciiNames = false;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Whether to add a PAX extension header for non-ASCII file names.\n     * @since 1.4\n     */\n    public void setAddPaxHeadersForNonAsciiNames(boolean b);\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException;\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     * @throws IOException on error\n     */\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private byte[] writePaxHeader(Map<String, String> m) throws Exception {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n        tos.writePaxHeaders(\"foo\", m);\n\n        // add a dummy entry so data gets written\n        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n        t.setSize(10 * 1024);\n        tos.putArchiveEntry(t);\n        tos.write(new byte[10 * 1024]);\n        tos.closeArchiveEntry();\n        tos.close();\n\n        return bos.toByteArray();\n    }\n    private void testRoundtripWith67CharFileName(int mode) throws Exception {\n        String n = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            + \"AAAAAAA\";\n        assertEquals(67, n.length());\n        TarArchiveEntry t = new TarArchiveEntry(n);\n        t.setSize(10 * 1024);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n        tos.setLongFileMode(mode);\n        tos.putArchiveEntry(t);\n        tos.write(new byte[10 * 1024]);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        TarArchiveInputStream tin =\n            new TarArchiveInputStream(new ByteArrayInputStream(data));\n        TarArchiveEntry e = tin.getNextTarEntry();\n        assertEquals(n, e.getName());\n        tin.close();\n    }\n    private void testWriteLongDirectoryName(int mode) throws Exception {\n        String n = \"01234567890123456789012345678901234567890123456789\"\n            + \"01234567890123456789012345678901234567890123456789\"\n            + \"01234567890123456789012345678901234567890123456789/\";\n        TarArchiveEntry t = new TarArchiveEntry(n);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n        tos.setLongFileMode(mode);\n        tos.putArchiveEntry(t);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        TarArchiveInputStream tin =\n            new TarArchiveInputStream(new ByteArrayInputStream(data));\n        TarArchiveEntry e = tin.getNextTarEntry();\n        assertEquals(n, e.getName());\n        assertTrue(e.isDirectory());\n        tin.close();\n    }\n    public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n        String n = \"f\\u00f6\\u00f6/\";\n        TarArchiveEntry t = new TarArchiveEntry(n);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setAddPaxHeadersForNonAsciiNames(true);\n        tos.putArchiveEntry(t);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        TarArchiveInputStream tin =\n            new TarArchiveInputStream(new ByteArrayInputStream(data));\n        TarArchiveEntry e = tin.getNextTarEntry();\n        assertEquals(n, e.getName());\n        assertTrue(e.isDirectory());\n        tin.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Holds size and other extended information for entries that use Zip64\n * features.\n *\n * <p>From {@link \"http://www.pkware.com/documents/casestudies/APPNOTE.TXT PKWARE's APPNOTE.TXT\"}\n * <pre>\n * Zip64 Extended Information Extra Field (0x0001):\n *\n *          The following is the layout of the zip64 extended \n *          information \"extra\" block. If one of the size or\n *          offset fields in the Local or Central directory\n *          record is too small to hold the required data,\n *          a Zip64 extended information record is created.\n *          The order of the fields in the zip64 extended \n *          information record is fixed, but the fields will\n *          only appear if the corresponding Local or Central\n *          directory record field is set to 0xFFFF or 0xFFFFFFFF.\n *\n *          Note: all fields stored in Intel low-byte/high-byte order.\n *\n *          Value      Size       Description\n *          -----      ----       -----------\n *  (ZIP64) 0x0001     2 bytes    Tag for this \"extra\" block type\n *          Size       2 bytes    Size of this \"extra\" block\n *          Original \n *          Size       8 bytes    Original uncompressed file size\n *          Compressed\n *          Size       8 bytes    Size of compressed data\n *          Relative Header\n *          Offset     8 bytes    Offset of local header record\n *          Disk Start\n *          Number     4 bytes    Number of the disk on which\n *                                this file starts \n *\n *          This entry in the Local header must include BOTH original\n *          and compressed file size fields. If encrypting the \n *          central directory and bit 13 of the general purpose bit\n *          flag is set indicating masking, the value stored in the\n *          Local Header for the original file size will be zero.\n * </pre></p>\n *\n * <p>Currently Commons Compress doesn't support encrypting the\n * central directory so the note about masking doesn't apply.</p>\n *\n * <p>The implementation relies on data being read from the local file\n * header and assumes that both size values are always present.</p>\n *\n * @since 1.2\n * @NotThreadSafe\n */\npublic class Zip64ExtendedInformationExtraField implements ZipExtraField {\n    private static final byte[] EMPTY = new byte[0];\n    private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n    private ZipLong diskStart;\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException;\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getSize();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Holds size and other extended information for entries that use Zip64\n * features.\n *\n * <p>From {@link \"http://www.pkware.com/documents/casestudies/APPNOTE.TXT PKWARE's APPNOTE.TXT\"}\n * <pre>\n * Zip64 Extended Information Extra Field (0x0001):\n *\n *          The following is the layout of the zip64 extended \n *          information \"extra\" block. If one of the size or\n *          offset fields in the Local or Central directory\n *          record is too small to hold the required data,\n *          a Zip64 extended information record is created.\n *          The order of the fields in the zip64 extended \n *          information record is fixed, but the fields will\n *          only appear if the corresponding Local or Central\n *          directory record field is set to 0xFFFF or 0xFFFFFFFF.\n *\n *          Note: all fields stored in Intel low-byte/high-byte order.\n *\n *          Value      Size       Description\n *          -----      ----       -----------\n *  (ZIP64) 0x0001     2 bytes    Tag for this \"extra\" block type\n *          Size       2 bytes    Size of this \"extra\" block\n *          Original \n *          Size       8 bytes    Original uncompressed file size\n *          Compressed\n *          Size       8 bytes    Size of compressed data\n *          Relative Header\n *          Offset     8 bytes    Offset of local header record\n *          Disk Start\n *          Number     4 bytes    Number of the disk on which\n *                                this file starts \n *\n *          This entry in the Local header must include BOTH original\n *          and compressed file size fields. If encrypting the \n *          central directory and bit 13 of the general purpose bit\n *          flag is set indicating masking, the value stored in the\n *          Local Header for the original file size will be zero.\n * </pre></p>\n *\n * <p>Currently Commons Compress doesn't support encrypting the\n * central directory so the note about masking doesn't apply.</p>\n *\n * <p>The implementation relies on data being read from the local file\n * header and assumes that both size values are always present.</p>\n *\n * @since 1.2\n * @NotThreadSafe\n */\npublic class Zip64ExtendedInformationExtraField implements ZipExtraField {\n    private static final byte[] EMPTY = new byte[0];\n    private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n    private ZipLong diskStart;\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException;\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getSize();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void readOrderTest() throws Exception {\n        File archive = getFile(\"ordertest.zip\");\n        zf = new ZipFile(archive);\n    }\n    private static void assertEntryName(ArrayList<ZipArchiveEntry> entries,\n                                        int index,\n                                        String expectedName) {\n        ZipArchiveEntry ze = entries.get(index);\n        assertEquals(\"src/main/java/org/apache/commons/compress/archivers/zip/\"\n                     + expectedName + \".java\",\n                     ze.getName());\n    }\n    public void testExcessDataInZip64ExtraField() throws Exception {\n        File archive = getFile(\"COMPRESS-228.zip\");\n        zf = new ZipFile(archive);\n        // actually, if we get here, the test already has passed\n\n        ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n        assertEquals(26101, ze.getSize());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implements the \"ar\" archive format as an input stream.\n * \n * @NotThreadSafe\n * \n */\npublic class ArArchiveInputStream extends ArchiveInputStream {\n    private final InputStream input;\n    private long offset = 0;\n    private boolean closed;\n    public int read(byte[] b, final int off, final int len) throws IOException;\n    public int read(byte[] b) throws IOException;\n    public void close() throws IOException;\n    /**\n     * Returns the next AR entry in this stream.\n     * \n     * @return the next AR entry.\n     * @throws IOException\n     *             if the entry could not be read\n     */\n    public ArArchiveEntry getNextArEntry() throws IOException;\n    public ArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implements the \"ar\" archive format as an input stream.\n * \n * @NotThreadSafe\n * \n */\npublic class ArArchiveInputStream extends ArchiveInputStream {\n    private final InputStream input;\n    private long offset = 0;\n    private boolean closed;\n    public int read(byte[] b, final int off, final int len) throws IOException;\n    public int read(byte[] b) throws IOException;\n    public void close() throws IOException;\n    /**\n     * Returns the next AR entry in this stream.\n     * \n     * @return the next AR entry.\n     * @throws IOException\n     *             if the entry could not be read\n     */\n    public ArArchiveEntry getNextArEntry() throws IOException;\n    public ArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testArDelete() throws Exception {\n        final File output = new File(dir, \"bla.ar\");\n\n        final File file1 = getFile(\"test1.xml\");\n        final File file2 = getFile(\"test2.xml\");\n        {\n            // create\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n            os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n            os.close();\n            out.close();\n        }\n\n        assertEquals(8 + 60 + file1.length() + (file1.length() % 2) + 60 + file2.length() + (file2.length() % 2), output.length());\n\n        final File output2 = new File(dir, \"bla2.ar\");\n\n        int copied = 0;\n        int deleted = 0;\n\n        {\n            // remove all but one file\n\n            final InputStream is = new FileInputStream(output);\n            final OutputStream os = new FileOutputStream(output2);\n            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", os);\n            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n            while(true) {\n                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n\n                if (\"test1.xml\".equals(entry.getName())) {\n                    aos.putArchiveEntry(entry);\n                    IOUtils.copy(ais, aos);\n                    aos.closeArchiveEntry();\n                    copied++;\n                } else {\n                    IOUtils.copy(ais, new ByteArrayOutputStream());\n                    deleted++;\n                }\n\n            }\n            ais.close();\n            aos.close();\n            is.close();\n            os.close();\n        }\n\n        assertEquals(1, copied);\n        assertEquals(1, deleted);\n        assertEquals(144, output2.length());\n\n        long files = 0;\n        long sum = 0;\n\n        {\n            final InputStream is = new FileInputStream(output2);\n            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n            while(true) {\n                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n\n                IOUtils.copy(ais, new ByteArrayOutputStream());\n\n                sum +=  entry.getLength();\n                files++;\n            }\n            ais.close();\n            is.close();\n        }\n\n        assertEquals(1, files);\n        assertEquals(76, sum);\n\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n * cpio are supported (old ascii, old binary, new portable format and the new\n * portable format with crc).\n * <p/>\n * <p/>\n * The stream can be read by extracting a cpio entry (containing all\n * informations about a entry) and afterwards reading from the stream the file\n * specified by the entry.\n * <p/>\n * <code><pre>\n * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n * CPIOArchiveEntry cpioEntry;\n * <p/>\n * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n *     System.out.println(cpioEntry.getName());\n *     int tmp;\n *     StringBuilder buf = new StringBuilder();\n *     while ((tmp = cpIn.read()) != -1) {\n *         buf.append((char) tmp);\n *     }\n *     System.out.println(buf.toString());\n * }\n * cpioIn.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered to be threadsafe.\n * \n * Based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveInputStream extends ArchiveInputStream implements\n        CpioConstants {\n    private boolean closed = false;\n    private CpioArchiveEntry entry;\n    private long entryBytesRead = 0;\n    private boolean entryEOF = false;\n    private final byte tmpbuf[] = new byte[4096];\n    private long crc = 0;\n    private final InputStream in;\n    private final byte[] TWO_BYTES_BUF = new byte[2];\n    private final byte[] FOUR_BYTES_BUF = new byte[4];\n    private final byte[] SIX_BYTES_BUF = new byte[6];\n    private final int blockSize;\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n            throws IOException;\n    @Override\n    public CpioArchiveEntry getNextEntry() throws IOException;\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException;\n    /**\n     * Closes the CPIO input stream.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    @Override\n    public void close() throws IOException;\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n            throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n * cpio are supported (old ascii, old binary, new portable format and the new\n * portable format with crc).\n * <p/>\n * <p/>\n * The stream can be read by extracting a cpio entry (containing all\n * informations about a entry) and afterwards reading from the stream the file\n * specified by the entry.\n * <p/>\n * <code><pre>\n * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n * CPIOArchiveEntry cpioEntry;\n * <p/>\n * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n *     System.out.println(cpioEntry.getName());\n *     int tmp;\n *     StringBuilder buf = new StringBuilder();\n *     while ((tmp = cpIn.read()) != -1) {\n *         buf.append((char) tmp);\n *     }\n *     System.out.println(buf.toString());\n * }\n * cpioIn.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered to be threadsafe.\n * \n * Based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveInputStream extends ArchiveInputStream implements\n        CpioConstants {\n    private boolean closed = false;\n    private CpioArchiveEntry entry;\n    private long entryBytesRead = 0;\n    private boolean entryEOF = false;\n    private final byte tmpbuf[] = new byte[4096];\n    private long crc = 0;\n    private final InputStream in;\n    private final byte[] TWO_BYTES_BUF = new byte[2];\n    private final byte[] FOUR_BYTES_BUF = new byte[4];\n    private final byte[] SIX_BYTES_BUF = new byte[6];\n    private final int blockSize;\n    private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n            throws IOException;\n    @Override\n    public CpioArchiveEntry getNextEntry() throws IOException;\n    private CpioArchiveEntry readOldAsciiEntry() throws IOException;\n    /**\n     * Closes the CPIO input stream.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    @Override\n    public void close() throws IOException;\n    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n            throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n        CpioArchiveInputStream in =\n            new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n        CpioArchiveEntry entry= null;\n\n        int count = 0;\n        while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n            count++;\n        }\n        in.close();\n\n        assertEquals(count, 1);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Writes a 7z file.\n * @since 1.6\n */\npublic class SevenZOutputFile {\n    private final RandomAccessFile file;\n    private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\n    private int numNonEmptyStreams = 0;\n    private CRC32 crc32 = new CRC32();\n    private CRC32 compressedCrc32 = new CRC32();\n    private long fileBytesWritten = 0;\n    private boolean finished = false;\n    private CountingOutputStream currentOutputStream;\n    private SevenZMethod contentCompression = SevenZMethod.LZMA2;\n    /**\n     * Writes a byte to the current archive entry.\n     * @param b The byte to be written.\n     * @throws IOException on error\n     */\n    public void write(final int b) throws IOException;\n    /**\n     * Closes the archive, calling {@link #finish} if necessary.\n     * \n     * @throws IOException\n     */\n    public void close() throws IOException;\n    /**\n     * Closes the archive entry.\n     * @throws IOException\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Records an archive entry to add.\n     *\n     * The caller must then write the content to the archive and call\n     * {@link #closeArchiveEntry()} to complete the process.\n     * \n     * @param archiveEntry describes the entry\n     * @throws IOException\n     */\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Create an archive entry using the inputFile and entryName provided.\n     * \n     * @param inputFile\n     * @param entryName \n     * @return the ArchiveEntry set up with details from the file\n     * \n     * @throws IOException\n     */\n    public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n            final String entryName) throws IOException;\n    /**\n     * Writes part of a byte array to the current archive entry.\n     * @param b The byte array to be written.\n     * @param off offset into the array to start writing from\n     * @param len number of bytes to write\n     * @throws IOException on error\n     */\n    public void write(final byte[] b, final int off, final int len) throws IOException;\n    /**\n     * Writes a byte array to the current archive entry.\n     * @param b The byte array to be written.\n     * @throws IOException on error\n     */\n    public void write(final byte[] b) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Writes a 7z file.\n * @since 1.6\n */\npublic class SevenZOutputFile {\n    private final RandomAccessFile file;\n    private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\n    private int numNonEmptyStreams = 0;\n    private CRC32 crc32 = new CRC32();\n    private CRC32 compressedCrc32 = new CRC32();\n    private long fileBytesWritten = 0;\n    private boolean finished = false;\n    private CountingOutputStream currentOutputStream;\n    private SevenZMethod contentCompression = SevenZMethod.LZMA2;\n    /**\n     * Writes a byte to the current archive entry.\n     * @param b The byte to be written.\n     * @throws IOException on error\n     */\n    public void write(final int b) throws IOException;\n    /**\n     * Closes the archive, calling {@link #finish} if necessary.\n     * \n     * @throws IOException\n     */\n    public void close() throws IOException;\n    /**\n     * Closes the archive entry.\n     * @throws IOException\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Records an archive entry to add.\n     *\n     * The caller must then write the content to the archive and call\n     * {@link #closeArchiveEntry()} to complete the process.\n     * \n     * @param archiveEntry describes the entry\n     * @throws IOException\n     */\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Create an archive entry using the inputFile and entryName provided.\n     * \n     * @param inputFile\n     * @param entryName \n     * @return the ArchiveEntry set up with details from the file\n     * \n     * @throws IOException\n     */\n    public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n            final String entryName) throws IOException;\n    /**\n     * Writes part of a byte array to the current archive entry.\n     * @param b The byte array to be written.\n     * @param off offset into the array to start writing from\n     * @param len number of bytes to write\n     * @throws IOException on error\n     */\n    public void write(final byte[] b, final int off, final int len) throws IOException;\n    /**\n     * Writes a byte array to the current archive entry.\n     * @param b The byte array to be written.\n     * @throws IOException on error\n     */\n    public void write(final byte[] b) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void testCompress252(int numberOfFiles, int numberOfNonEmptyFiles)\n        throws Exception {\n        int nonEmptyModulus = numberOfNonEmptyFiles != 0\n            ? numberOfFiles / numberOfNonEmptyFiles\n            : numberOfFiles + 1;\n        output = new File(dir, \"COMPRESS252-\" + numberOfFiles + \"-\" + numberOfNonEmptyFiles + \".7z\");\n        SevenZOutputFile archive = new SevenZOutputFile(output);\n        try {\n            addDir(archive);\n            for (int i = 0; i < numberOfFiles; i++) {\n                addFile(archive, i, (i + 1) % nonEmptyModulus == 0);\n            }\n        } finally {\n            archive.close();\n        }\n        verifyCompress252(output, numberOfFiles, numberOfNonEmptyFiles);\n    }\n    private void verifyCompress252(File output, int numberOfFiles, int numberOfNonEmptyFiles)\n        throws Exception {\n        SevenZFile archive = new SevenZFile(output);\n        int filesFound = 0;\n        int nonEmptyFilesFound = 0;\n        try {\n            verifyDir(archive);\n            Boolean b = verifyFile(archive, filesFound++);\n            while (b != null) {\n                if (Boolean.TRUE.equals(b)) {\n                    nonEmptyFilesFound++;\n                }\n                b = verifyFile(archive, filesFound++);\n            }\n        } finally {\n            archive.close();\n        }\n        assertEquals(numberOfFiles + 1, filesFound);\n        assertEquals(numberOfNonEmptyFiles, nonEmptyFilesFound);\n    }\n    private void addDir(SevenZOutputFile archive) throws Exception {\n        SevenZArchiveEntry entry = archive.createArchiveEntry(dir, \"foo/\");\n        archive.putArchiveEntry(entry);\n        archive.closeArchiveEntry();\n    }\n    private void verifyDir(SevenZFile archive) throws Exception {\n        SevenZArchiveEntry entry = archive.getNextEntry();\n        assertNotNull(entry);\n        assertEquals(\"foo/\", entry.getName());\n        assertTrue(entry.isDirectory());\n    }\n    private void addFile(SevenZOutputFile archive, int index, boolean nonEmpty)\n        throws Exception {\n        SevenZArchiveEntry entry = new SevenZArchiveEntry();\n        entry.setName(\"foo/\" + index + \".txt\");\n        archive.putArchiveEntry(entry);\n        archive.write(nonEmpty ? new byte[] { 17 } : new byte[0]);\n        archive.closeArchiveEntry();\n    }\n    private Boolean verifyFile(SevenZFile archive, int index) throws Exception {\n        SevenZArchiveEntry entry = archive.getNextEntry();\n        if (entry == null) {\n            return null;\n        }\n        assertEquals(\"foo/\" + index + \".txt\", entry.getName());\n        assertEquals(false, entry.isDirectory());\n        if (entry.getSize() == 0) {\n            return false;\n        }\n        assertEquals(1, entry.getSize());\n        assertEquals(17, archive.read());\n        assertEquals(-1, archive.read());\n        return true;\n    }\n    public void testSevenEmptyFiles() throws Exception {\n        testCompress252(7, 0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An input stream that decompresses from the BZip2 format to be read as any other stream.\n * \n * @NotThreadSafe\n */\npublic class BZip2CompressorInputStream extends CompressorInputStream implements\n                                                                          BZip2Constants {\n    private int last;\n    private int origPtr;\n    private int blockSize100k;\n    private boolean blockRandomised;\n    private int bsBuff;\n    private int bsLive;\n    private final CRC crc = new CRC();\n    private int nInUse;\n    private InputStream in;\n    private final boolean decompressConcatenated;\n    private int currentChar = -1;\n    private static final int EOF = 0;\n    private static final int START_BLOCK_STATE = 1;\n    private static final int RAND_PART_A_STATE = 2;\n    private static final int RAND_PART_B_STATE = 3;\n    private static final int RAND_PART_C_STATE = 4;\n    private static final int NO_RAND_PART_A_STATE = 5;\n    private static final int NO_RAND_PART_B_STATE = 6;\n    private static final int NO_RAND_PART_C_STATE = 7;\n    private int currentState = START_BLOCK_STATE;\n    private int storedBlockCRC, storedCombinedCRC;\n    private int computedBlockCRC, computedCombinedCRC;\n    private int su_count;\n    private int su_ch2;\n    private int su_chPrev;\n    private int su_i2;\n    private int su_j2;\n    private int su_rNToGo;\n    private int su_rTPos;\n    private int su_tPos;\n    private char su_z;\n    private BZip2CompressorInputStream.Data data;\n    private int setupRandPartB() throws IOException;\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException;\n    private int setupNoRandPartA() throws IOException;\n    @Override\n    public int read() throws IOException;\n    private int setupNoRandPartB() throws IOException;\n    private void makeMaps();\n    private int setupNoRandPartC() throws IOException;\n    private int setupRandPartA() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An input stream that decompresses from the BZip2 format to be read as any other stream.\n * \n * @NotThreadSafe\n */\npublic class BZip2CompressorInputStream extends CompressorInputStream implements\n                                                                          BZip2Constants {\n    private int last;\n    private int origPtr;\n    private int blockSize100k;\n    private boolean blockRandomised;\n    private int bsBuff;\n    private int bsLive;\n    private final CRC crc = new CRC();\n    private int nInUse;\n    private InputStream in;\n    private final boolean decompressConcatenated;\n    private int currentChar = -1;\n    private static final int EOF = 0;\n    private static final int START_BLOCK_STATE = 1;\n    private static final int RAND_PART_A_STATE = 2;\n    private static final int RAND_PART_B_STATE = 3;\n    private static final int RAND_PART_C_STATE = 4;\n    private static final int NO_RAND_PART_A_STATE = 5;\n    private static final int NO_RAND_PART_B_STATE = 6;\n    private static final int NO_RAND_PART_C_STATE = 7;\n    private int currentState = START_BLOCK_STATE;\n    private int storedBlockCRC, storedCombinedCRC;\n    private int computedBlockCRC, computedCombinedCRC;\n    private int su_count;\n    private int su_ch2;\n    private int su_chPrev;\n    private int su_i2;\n    private int su_j2;\n    private int su_rNToGo;\n    private int su_rTPos;\n    private int su_tPos;\n    private char su_z;\n    private BZip2CompressorInputStream.Data data;\n    private int setupRandPartB() throws IOException;\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException;\n    private int setupNoRandPartA() throws IOException;\n    @Override\n    public int read() throws IOException;\n    private int setupNoRandPartB() throws IOException;\n    private void makeMaps();\n    private int setupNoRandPartC() throws IOException;\n    private int setupRandPartA() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static ReadableByteChannel makeBZ2C(InputStream source) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(source);\n        BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);\n\n        return Channels.newChannel(bZin);\n    }\n    public void testPartialReadTruncatedData() throws IOException {\n        //with BZ2File(self.filename) as f:\n        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n        //    self.assertRaises(EOFError, f.read, 1)\n\n        final int length = TEXT.length();\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        bz2Channel.read(buffer);\n\n        assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length), buffer.array());\n\n        // subsequent read should throw\n        buffer = ByteBuffer.allocate(1);\n        try {\n            bz2Channel.read(buffer);\n            Assert.fail(\"The read should have thrown.\");\n        } catch (IOException e) {\n            // pass\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>class Coders {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>class Coders {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void test7zUnarchive(File f) throws Exception {\n        test7zUnarchive(f, null);\n    }\n    private void test7zUnarchive(File f, byte[] password) throws Exception {\n        SevenZFile sevenZFile = new SevenZFile(f, password);\n        try {\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            assertEquals(\"test1.xml\", entry.getName());\n            entry = sevenZFile.getNextEntry();\n            assertEquals(\"test2.xml\", entry.getName());\n            byte[] contents = new byte[(int)entry.getSize()];\n            int off = 0;\n            while ((off < contents.length)) {\n                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                assert(bytesRead >= 0);\n                off += bytesRead;\n            }\n            assertEquals(TEST2_CONTENT, new String(contents, \"UTF-8\"));\n            assertNull(sevenZFile.getNextEntry());\n        } finally {\n            sevenZFile.close();\n        }\n    }\n    private void checkHelloWorld(final String filename) throws Exception {\n        SevenZFile sevenZFile = new SevenZFile(getFile(filename));\n        try {\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            assertEquals(\"Hello world.txt\", entry.getName());\n            byte[] contents = new byte[(int)entry.getSize()];\n            int off = 0;\n            while ((off < contents.length)) {\n                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                assert(bytesRead >= 0);\n                off += bytesRead;\n            }\n            assertEquals(\"Hello, world!\\n\", new String(contents, \"UTF-8\"));\n            assertNull(sevenZFile.getNextEntry());\n        } finally {\n            sevenZFile.close();\n        }\n    }\n    private static boolean isStrongCryptoAvailable() throws NoSuchAlgorithmException {\n        return Cipher.getMaxAllowedKeyLength(\"AES/ECB/PKCS5Padding\") >= 256;\n    }\n    public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n        try {\n            int count = 0;\n            while (sevenZFile.getNextEntry() != null) {\n                count++;\n            }\n            assertEquals(446, count);\n        } finally {\n            sevenZFile.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void checkRoundTripOctal(final long value, final int bufsize) {\n        byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void checkRoundTripOctal(final long value) {\n        checkRoundTripOctal(value, TarConstants.SIZELEN);\n    }\n    private void checkRoundTripOctalOrBinary(final long value, final int bufsize) {\n        byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctalOrBinary(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void testRoundTripOctalOrBinary(int length) {\n        checkRoundTripOctalOrBinary(0, length);\n        checkRoundTripOctalOrBinary(1, length);\n        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, length); // will need binary format\n        checkRoundTripOctalOrBinary(-1, length); // will need binary format\n        checkRoundTripOctalOrBinary(0xff00000000000001l, length);\n    }\n    private void checkName(String string) {\n        byte buff[] = new byte[100];\n        int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n        assertEquals(string, TarUtils.parseName(buff, 0, len));\n    }\n    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n        buffer[buffer.length - 1] = ' ';\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer[buffer.length-1]=0;\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer=new byte[]{0,0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{0,' '};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the\n * DEFLATE algorithm is used, as the size information is not available\n * from the header.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files.</p>\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    @Override\n    public void close() throws IOException;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the\n * DEFLATE algorithm is used, as the size information is not available\n * from the header.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files.</p>\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    @Override\n    public void close() throws IOException;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void extractZipInputStream(final ZipArchiveInputStream in)\n        throws IOException {\n        ZipArchiveEntry zae = in.getNextZipEntry();\n        while (zae != null) {\n            if (zae.getName().endsWith(\".zip\")) {\n                extractZipInputStream(new ZipArchiveInputStream(in));\n            }\n            zae = in.getNextZipEntry();\n        }\n    }\n    public void testReadingOfFirstStoredEntry() throws Exception {\n        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n        \n        try {\n            ZipArchiveEntry ze = in.getNextZipEntry();\n            assertEquals(5, ze.getSize());\n            assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'}, IOUtils.toByteArray(in));\n        } finally {\n            in.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Utility functions\n * @Immutable\n */\npublic final class IOUtils {\n    private static final int COPY_BUF_SIZE = 8024;\n    private static final int SKIP_BUF_SIZE = 4096;\n    /**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Utility functions\n * @Immutable\n */\npublic final class IOUtils {\n    private static final int COPY_BUF_SIZE = 8024;\n    private static final int SKIP_BUF_SIZE = 4096;\n    /**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void skip(StreamWrapper wrapper) throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n            });\n        InputStream sut = wrapper.wrap(in);\n        Assert.assertEquals(10, IOUtils.skip(sut, 10));\n        Assert.assertEquals(11, sut.read());\n    }\n    public void skipUsingRead() throws Exception {\n        skip(new StreamWrapper() {\n                public InputStream wrap(InputStream toWrap) {\n                    return new FilterInputStream(toWrap) {\n                        public long skip(long s) {\n                            return 0;\n                        }\n                    };\n                }\n            });\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void checkRoundTripOctal(final long value, final int bufsize) {\n        byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void checkRoundTripOctal(final long value) {\n        checkRoundTripOctal(value, TarConstants.SIZELEN);\n    }\n    private void checkRoundTripOctalOrBinary(final long value, final int bufsize) {\n        byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctalOrBinary(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void testRoundTripOctalOrBinary(int length) {\n        checkRoundTripOctalOrBinary(0, length);\n        checkRoundTripOctalOrBinary(1, length);\n        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, length); // will need binary format\n        checkRoundTripOctalOrBinary(-1, length); // will need binary format\n        checkRoundTripOctalOrBinary(0xff00000000000001l, length);\n    }\n    private void checkName(String string) {\n        byte buff[] = new byte[100];\n        int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n        assertEquals(string, TarUtils.parseName(buff, 0, len));\n    }\n    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n        buffer[buffer.length - 1] = ' ';\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer[buffer.length-1]=0;\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(MAX_OCTAL, value);\n        buffer=new byte[]{0,0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{0,' '};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n        buffer=new byte[]{' ',0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(0, value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n/**\n * The DumpArchiveInputStream reads a UNIX dump archive as an InputStream.\n * Methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n *\n * There doesn't seem to exist a hint on the encoding of string values\n * in any piece documentation.  Given the main purpose of dump/restore\n * is backing up a system it seems very likely the format uses the\n * current default encoding of the system.\n *\n * @NotThreadSafe\n */\npublic class DumpArchiveInputStream extends ArchiveInputStream {\n    private DumpArchiveSummary summary;\n    private DumpArchiveEntry active;\n    private boolean isClosed;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private int readIdx;\n    private final byte[] readBuf = new byte[DumpArchiveConstants.TP_SIZE];\n    private byte[] blockBuffer;\n    private int recordOffset;\n    private long filepos;\n    private final Map<Integer, Dirent> names = new HashMap<Integer, Dirent>();\n    private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>();\n    private Queue<DumpArchiveEntry> queue;\n    private final ZipEncoding zipEncoding;\n    @Deprecated\n    @Override\n    public int getCount();\n}\n/**\n * Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order to add other implementations, you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * @Immutable provided that the deprecated method setEntryEncoding is not used.\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String ARJ = \"arj\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    public static final String SEVEN_Z = \"7z\";\n    private final String encoding;\n    private volatile String entryEncoding = null;\n    /**\n     * Create an archive output stream from an archiver name and an output stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * written to a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n}\n/**\n * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n * cpio are supported (old ascii, old binary, new portable format and the new\n * portable format with crc).\n *\n * <p>\n * The stream can be read by extracting a cpio entry (containing all\n * informations about a entry) and afterwards reading from the stream the file\n * specified by the entry.\n * </p>\n * <pre>\n * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n * CPIOArchiveEntry cpioEntry;\n *\n * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n *     System.out.println(cpioEntry.getName());\n *     int tmp;\n *     StringBuilder buf = new StringBuilder();\n *     while ((tmp = cpIn.read()) != -1) {\n *         buf.append((char) tmp);\n *     }\n *     System.out.println(buf.toString());\n * }\n * cpioIn.close();\n * </pre>\n * <p>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * <p>This class uses mutable fields and is not considered to be threadsafe.\n * \n * <p>Based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveInputStream extends ArchiveInputStream implements\n        CpioConstants {\n    private boolean closed = false;\n    private CpioArchiveEntry entry;\n    private long entryBytesRead = 0;\n    private boolean entryEOF = false;\n    private final byte tmpbuf[] = new byte[4096];\n    private long crc = 0;\n    private final InputStream in;\n    private final byte[] TWO_BYTES_BUF = new byte[2];\n    private final byte[] FOUR_BYTES_BUF = new byte[4];\n    private final byte[] SIX_BYTES_BUF = new byte[6];\n    private final int blockSize;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Returns 0 after EOF has reached for the current entry data, otherwise\n     * always return 1.\n     * <p>\n     * Programs should not count on this method to return the actual number of\n     * bytes that could be read without blocking.\n     * \n     * @return 1 before EOF and 0 after EOF has reached for current entry.\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    @Override\n    public int available() throws IOException;\n}\n/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the\n * DEFLATE algorithm is used, as the size information is not available\n * from the header.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files.</p>\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n}\n/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    public static final int LONGFILE_POSIX = 3;\n    public static final int BIGNUMBER_ERROR = 0;\n    public static final int BIGNUMBER_STAR = 1;\n    public static final int BIGNUMBER_POSIX = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private int       bigNumberMode = BIGNUMBER_ERROR;\n    private int recordsWritten;\n    private final int recordsPerBlock;\n    private final int recordSize;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    private final ZipEncoding zipEncoding;\n    private boolean addPaxHeadersForNonAsciiNames = false;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names &gt;= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n}\n/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n *\n * <p>An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.</p>\n *\n * <pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(\"testfile\");\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * entry.setMode(CpioConstants.C_ISREG); // regular file\n * ... set other attributes, e.g. time, number of links\n * out.putArchiveEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre>\n *\n * <p>Note: This implementation should be compatible to cpio 2.5</p>\n * \n * <p>This class uses mutable fields and is not considered threadsafe.</p>\n * \n * <p>based on code from the jRPM project (jrpm.sourceforge.net)</p>\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry entry;\n    private boolean closed = false;\n    private boolean finished;\n    private final short entryFormat;\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    private final int blockSize;\n    private long nextArtificalDeviceAndInode = 1;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Check to make sure that this stream has not been closed\n     * \n     * @throws IOException\n     *             if the stream is already closed\n     */\n    private void ensureOpen() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n/**\n * The DumpArchiveInputStream reads a UNIX dump archive as an InputStream.\n * Methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n *\n * There doesn't seem to exist a hint on the encoding of string values\n * in any piece documentation.  Given the main purpose of dump/restore\n * is backing up a system it seems very likely the format uses the\n * current default encoding of the system.\n *\n * @NotThreadSafe\n */\npublic class DumpArchiveInputStream extends ArchiveInputStream {\n    private DumpArchiveSummary summary;\n    private DumpArchiveEntry active;\n    private boolean isClosed;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private int readIdx;\n    private final byte[] readBuf = new byte[DumpArchiveConstants.TP_SIZE];\n    private byte[] blockBuffer;\n    private int recordOffset;\n    private long filepos;\n    private final Map<Integer, Dirent> names = new HashMap<Integer, Dirent>();\n    private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>();\n    private Queue<DumpArchiveEntry> queue;\n    private final ZipEncoding zipEncoding;\n    @Deprecated\n    @Override\n    public int getCount();\n}\n/**\n * Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order to add other implementations, you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * @Immutable provided that the deprecated method setEntryEncoding is not used.\n */\npublic class ArchiveStreamFactory {\n    public static final String AR = \"ar\";\n    public static final String ARJ = \"arj\";\n    public static final String CPIO = \"cpio\";\n    public static final String DUMP = \"dump\";\n    public static final String JAR = \"jar\";\n    public static final String TAR = \"tar\";\n    public static final String ZIP = \"zip\";\n    public static final String SEVEN_Z = \"7z\";\n    private final String encoding;\n    private volatile String entryEncoding = null;\n    /**\n     * Create an archive output stream from an archiver name and an output stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * written to a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException;\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException;\n}\n/**\n * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n * cpio are supported (old ascii, old binary, new portable format and the new\n * portable format with crc).\n *\n * <p>\n * The stream can be read by extracting a cpio entry (containing all\n * informations about a entry) and afterwards reading from the stream the file\n * specified by the entry.\n * </p>\n * <pre>\n * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n * CPIOArchiveEntry cpioEntry;\n *\n * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n *     System.out.println(cpioEntry.getName());\n *     int tmp;\n *     StringBuilder buf = new StringBuilder();\n *     while ((tmp = cpIn.read()) != -1) {\n *         buf.append((char) tmp);\n *     }\n *     System.out.println(buf.toString());\n * }\n * cpioIn.close();\n * </pre>\n * <p>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * <p>This class uses mutable fields and is not considered to be threadsafe.\n * \n * <p>Based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveInputStream extends ArchiveInputStream implements\n        CpioConstants {\n    private boolean closed = false;\n    private CpioArchiveEntry entry;\n    private long entryBytesRead = 0;\n    private boolean entryEOF = false;\n    private final byte tmpbuf[] = new byte[4096];\n    private long crc = 0;\n    private final InputStream in;\n    private final byte[] TWO_BYTES_BUF = new byte[2];\n    private final byte[] FOUR_BYTES_BUF = new byte[4];\n    private final byte[] SIX_BYTES_BUF = new byte[6];\n    private final int blockSize;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Returns 0 after EOF has reached for the current entry data, otherwise\n     * always return 1.\n     * <p>\n     * Programs should not count on this method to return the actual number of\n     * bytes that could be read without blocking.\n     * \n     * @return 1 before EOF and 0 after EOF has reached for current entry.\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    @Override\n    public int available() throws IOException;\n}\n/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the\n * DEFLATE algorithm is used, as the size information is not available\n * from the header.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files.</p>\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n}\n/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    public static final int LONGFILE_POSIX = 3;\n    public static final int BIGNUMBER_ERROR = 0;\n    public static final int BIGNUMBER_STAR = 1;\n    public static final int BIGNUMBER_POSIX = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private int       bigNumberMode = BIGNUMBER_ERROR;\n    private int recordsWritten;\n    private final int recordsPerBlock;\n    private final int recordSize;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    private final ZipEncoding zipEncoding;\n    private boolean addPaxHeadersForNonAsciiNames = false;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names &gt;= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n}\n/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n *\n * <p>An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.</p>\n *\n * <pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(\"testfile\");\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * entry.setMode(CpioConstants.C_ISREG); // regular file\n * ... set other attributes, e.g. time, number of links\n * out.putArchiveEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre>\n *\n * <p>Note: This implementation should be compatible to cpio 2.5</p>\n * \n * <p>This class uses mutable fields and is not considered threadsafe.</p>\n * \n * <p>based on code from the jRPM project (jrpm.sourceforge.net)</p>\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry entry;\n    private boolean closed = false;\n    private boolean finished;\n    private final short entryFormat;\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    private final int blockSize;\n    private long nextArtificalDeviceAndInode = 1;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Check to make sure that this stream has not been closed\n     * \n     * @throws IOException\n     *             if the stream is already closed\n     */\n    private void ensureOpen() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static boolean eq(String exp, String act) {\n        if (exp == null) {\n            return act == null;\n        }\n        return exp.equals(act);\n    }\n    private static String getField(Object instance, String name) {\n        Class<?> cls = instance.getClass();\n        Field fld;\n        try {\n            fld = cls.getDeclaredField(name);\n        } catch (NoSuchFieldException nsfe) {\n                try {\n                    fld = cls.getSuperclass().getDeclaredField(name);\n                } catch (NoSuchFieldException e) {\n                    System.out.println(\"Cannot find \" + name + \" in class \" + instance.getClass().getSimpleName());\n                    return \"??\";\n                }                \n        }\n        boolean isAccessible = fld.isAccessible();\n        try {\n            if (!isAccessible) {\n                fld.setAccessible(true);\n            }\n            final Object object = fld.get(instance);\n            if (object instanceof String || object == null) {\n                return (String) object;\n            } else {\n                System.out.println(\"Wrong type: \" + object.getClass().getCanonicalName() + \" for \" + name + \" in class \" + instance.getClass().getSimpleName());\n                return \"??\";                \n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"??\";\n        } finally {\n            if (!isAccessible) {\n                fld.setAccessible(isAccessible);\n            }\n        }\n    }\n    private ArchiveInputStream getInputStreamFor(String resource, ArchiveStreamFactory factory)\n            throws IOException, ArchiveException {\n        return factory.createArchiveInputStream(\n                   new BufferedInputStream(new FileInputStream(\n                       getFile(resource))));\n    }\n    private ArchiveInputStream getInputStreamFor(String type, String resource, ArchiveStreamFactory factory)\n            throws IOException, ArchiveException {\n        return factory.createArchiveInputStream(\n                   type,\n                   new BufferedInputStream(new FileInputStream(\n                       getFile(resource))));\n    }\n    private ArchiveOutputStream getOutputStreamFor(String type, ArchiveStreamFactory factory)\n            throws IOException, ArchiveException {\n        return factory.createArchiveOutputStream(type, new ByteArrayOutputStream());\n    }\n    public void testEncodingInputStream() throws Exception {\n        int failed = 0;\n        for(int i = 1; i <= TESTS.length; i++) {\n            TestData test = TESTS[i-1];\n            ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n            final String field = getField(ais,test.fieldName);\n            if (!eq(test.expectedEncoding,field)) {\n                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n                failed++;\n            }\n        }\n        if (failed > 0) { fail(\"Tests failed: \" + failed);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private final OutputStream out;\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * \n     * An archive consists of a series of file entries terminated by an\n     * end-of-archive entry, which consists of two 512 blocks of zero bytes. \n     * POSIX.1 requires two EOF records, like some other implementations.\n     * \n     * @throws IOException on error\n     */\n    public void finish() throws IOException;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private final OutputStream out;\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * \n     * An archive consists of a series of file entries terminated by an\n     * end-of-archive entry, which consists of two 512 blocks of zero bytes. \n     * POSIX.1 requires two EOF records, like some other implementations.\n     * \n     * @throws IOException on error\n     */\n    public void finish() throws IOException;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testFinish() throws Exception {\n        OutputStream out1 = new ByteArrayOutputStream();\n        \n        ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n        aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n        aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n        aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n        aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n        aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An input stream that decompresses from the BZip2 format to be read as any other stream.\n * \n * @NotThreadSafe\n */\npublic class BZip2CompressorInputStream extends CompressorInputStream implements\n                                                                          BZip2Constants {\n    private int last;\n    private int origPtr;\n    private int blockSize100k;\n    private boolean blockRandomised;\n    private int bsBuff;\n    private int bsLive;\n    private final CRC crc = new CRC();\n    private int nInUse;\n    private InputStream in;\n    private final boolean decompressConcatenated;\n    private static final int EOF = 0;\n    private static final int START_BLOCK_STATE = 1;\n    private static final int RAND_PART_A_STATE = 2;\n    private static final int RAND_PART_B_STATE = 3;\n    private static final int RAND_PART_C_STATE = 4;\n    private static final int NO_RAND_PART_A_STATE = 5;\n    private static final int NO_RAND_PART_B_STATE = 6;\n    private static final int NO_RAND_PART_C_STATE = 7;\n    private int currentState = START_BLOCK_STATE;\n    private int storedBlockCRC, storedCombinedCRC;\n    private int computedBlockCRC, computedCombinedCRC;\n    private int su_count;\n    private int su_ch2;\n    private int su_chPrev;\n    private int su_i2;\n    private int su_j2;\n    private int su_rNToGo;\n    private int su_rTPos;\n    private int su_tPos;\n    private char su_z;\n    private BZip2CompressorInputStream.Data data;\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException;\n    @Override\n    public int read() throws IOException;\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An input stream that decompresses from the BZip2 format to be read as any other stream.\n * \n * @NotThreadSafe\n */\npublic class BZip2CompressorInputStream extends CompressorInputStream implements\n                                                                          BZip2Constants {\n    private int last;\n    private int origPtr;\n    private int blockSize100k;\n    private boolean blockRandomised;\n    private int bsBuff;\n    private int bsLive;\n    private final CRC crc = new CRC();\n    private int nInUse;\n    private InputStream in;\n    private final boolean decompressConcatenated;\n    private static final int EOF = 0;\n    private static final int START_BLOCK_STATE = 1;\n    private static final int RAND_PART_A_STATE = 2;\n    private static final int RAND_PART_B_STATE = 3;\n    private static final int RAND_PART_C_STATE = 4;\n    private static final int NO_RAND_PART_A_STATE = 5;\n    private static final int NO_RAND_PART_B_STATE = 6;\n    private static final int NO_RAND_PART_C_STATE = 7;\n    private int currentState = START_BLOCK_STATE;\n    private int storedBlockCRC, storedCombinedCRC;\n    private int computedBlockCRC, computedCombinedCRC;\n    private int su_count;\n    private int su_ch2;\n    private int su_chPrev;\n    private int su_i2;\n    private int su_j2;\n    private int su_rNToGo;\n    private int su_rTPos;\n    private int su_tPos;\n    private char su_z;\n    private BZip2CompressorInputStream.Data data;\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException;\n    @Override\n    public int read() throws IOException;\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void readOfLength0ShouldReturn0() throws Exception {\n        // Create a big random piece of data\n        byte[] rawData = new byte[1048576];\n        for (int i=0; i < rawData.length; ++i) {\n            rawData[i] = (byte) Math.floor(Math.random()*256);\n        }\n\n        // Compress it\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n        bzipOut.write(rawData);\n        bzipOut.flush();\n        bzipOut.close();\n        baos.flush();\n        baos.close();\n\n        // Try to read it back in\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n        byte[] buffer = new byte[1024];\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n        Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n        Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n        bzipIn.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        }\n        in.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers);\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers);\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void datePriorToEpoch(String archive) throws Exception {\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(getFile(archive)));\n            TarArchiveEntry tae = in.getNextTarEntry();\n            assertEquals(\"foo\", tae.getName());\n            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n            cal.set(1969, 11, 31, 23, 59, 59);\n            cal.set(Calendar.MILLISECOND, 0);\n            assertEquals(cal.getTime(), tae.getLastModifiedDate());\n            assertTrue(tae.isCheckSumOK());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n    private TarArchiveInputStream getTestStream(String name) {\n        return new TarArchiveInputStream(\n                TarArchiveInputStreamTest.class.getResourceAsStream(name));\n    }\n    public void shouldReadBigGid() throws Exception {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n        TarArchiveEntry t = new TarArchiveEntry(\"name\");\n        t.setGroupId(4294967294l);\n        t.setSize(1);\n        tos.putArchiveEntry(t);\n        tos.write(30);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        TarArchiveInputStream tis =\n            new TarArchiveInputStream(bis);\n        t = tis.getNextTarEntry();\n        assertEquals(4294967294l, t.getLongGroupId());\n        tis.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deflate decompressor.\n * @since 1.9\n */\npublic class DeflateCompressorInputStream extends CompressorInputStream {\n    private final InputStream in;\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException;\n}\n/**\n * <p>Factory to create Compressor[In|Out]putStreams from names. To add other\n * implementations you should extend CompressorStreamFactory and override the\n * appropriate methods (and call their implementation from super of course).</p>\n * \n * Example (Compressing a file):\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * CompressorOutputStream cos = \n *      new CompressorStreamFactory().createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n * IOUtils.copy(new FileInputStream(input), cos);\n * cos.close();\n * </pre>\n * \n * Example (Decompressing a file):\n * <pre>\n * final InputStream is = new FileInputStream(input); \n * CompressorInputStream in = \n *      new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.BZIP2, is);\n * IOUtils.copy(in, new FileOutputStream(output));\n * in.close();\n * </pre>\n * @Immutable provided that the deprecated method setDecompressConcatenated is not used.\n * @ThreadSafe even if the deprecated method setDecompressConcatenated is used\n */\npublic class CompressorStreamFactory {\n    public static final String BZIP2 = \"bzip2\";\n    public static final String GZIP = \"gz\";\n    public static final String PACK200 = \"pack200\";\n    public static final String XZ = \"xz\";\n    public static final String LZMA = \"lzma\";\n    public static final String SNAPPY_FRAMED = \"snappy-framed\";\n    public static final String SNAPPY_RAW = \"snappy-raw\";\n    public static final String Z = \"z\";\n    public static final String DEFLATE = \"deflate\";\n    private final Boolean decompressUntilEOF;\n    private volatile boolean decompressConcatenated = false;\n    /**\n     * Create an compressor input stream from an input stream, autodetecting\n     * the compressor type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the compressor input stream\n     * @throws CompressorException if the compressor name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     * @since 1.1\n     */\n    public CompressorInputStream createCompressorInputStream(final InputStream in)\n            throws CompressorException;\n    /**\n     * Create a compressor input stream from a compressor name and an input stream.\n     * \n     * @param name of the compressor,\n     * i.e. {@value #GZIP}, {@value #BZIP2}, {@value #XZ}, {@value #LZMA},\n     * {@value #PACK200}, {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, \n     * {@value #Z} or {@value #DEFLATE} \n     * @param in the input stream\n     * @return compressor input stream\n     * @throws CompressorException if the compressor name is not known\n     * @throws IllegalArgumentException if the name or input stream is null\n     */\n    public CompressorInputStream createCompressorInputStream(final String name,\n            final InputStream in) throws CompressorException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deflate decompressor.\n * @since 1.9\n */\npublic class DeflateCompressorInputStream extends CompressorInputStream {\n    private final InputStream in;\n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException;\n}\n/**\n * <p>Factory to create Compressor[In|Out]putStreams from names. To add other\n * implementations you should extend CompressorStreamFactory and override the\n * appropriate methods (and call their implementation from super of course).</p>\n * \n * Example (Compressing a file):\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * CompressorOutputStream cos = \n *      new CompressorStreamFactory().createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n * IOUtils.copy(new FileInputStream(input), cos);\n * cos.close();\n * </pre>\n * \n * Example (Decompressing a file):\n * <pre>\n * final InputStream is = new FileInputStream(input); \n * CompressorInputStream in = \n *      new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.BZIP2, is);\n * IOUtils.copy(in, new FileOutputStream(output));\n * in.close();\n * </pre>\n * @Immutable provided that the deprecated method setDecompressConcatenated is not used.\n * @ThreadSafe even if the deprecated method setDecompressConcatenated is used\n */\npublic class CompressorStreamFactory {\n    public static final String BZIP2 = \"bzip2\";\n    public static final String GZIP = \"gz\";\n    public static final String PACK200 = \"pack200\";\n    public static final String XZ = \"xz\";\n    public static final String LZMA = \"lzma\";\n    public static final String SNAPPY_FRAMED = \"snappy-framed\";\n    public static final String SNAPPY_RAW = \"snappy-raw\";\n    public static final String Z = \"z\";\n    public static final String DEFLATE = \"deflate\";\n    private final Boolean decompressUntilEOF;\n    private volatile boolean decompressConcatenated = false;\n    /**\n     * Create an compressor input stream from an input stream, autodetecting\n     * the compressor type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the compressor input stream\n     * @throws CompressorException if the compressor name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     * @since 1.1\n     */\n    public CompressorInputStream createCompressorInputStream(final InputStream in)\n            throws CompressorException;\n    /**\n     * Create a compressor input stream from a compressor name and an input stream.\n     * \n     * @param name of the compressor,\n     * i.e. {@value #GZIP}, {@value #BZIP2}, {@value #XZ}, {@value #LZMA},\n     * {@value #PACK200}, {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, \n     * {@value #Z} or {@value #DEFLATE} \n     * @param in the input stream\n     * @return compressor input stream\n     * @throws CompressorException if the compressor name is not known\n     * @throws IllegalArgumentException if the name or input stream is null\n     */\n    public CompressorInputStream createCompressorInputStream(final String name,\n            final InputStream in) throws CompressorException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private CompressorInputStream getStreamFor(String resource)\n            throws CompressorException, IOException {\n        return factory.createCompressorInputStream(\n                   new BufferedInputStream(new FileInputStream(\n                       getFile(resource))));\n    }\n    private CompressorInputStream getStreamFor(String resource, CompressorStreamFactory factory)\n            throws CompressorException, IOException {\n        return factory.createCompressorInputStream(\n                   new BufferedInputStream(new FileInputStream(\n                       getFile(resource))));\n    }\n    public void testDetection() throws Exception {\n        CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n        assertNotNull(bzip2);\n        assertTrue(bzip2 instanceof BZip2CompressorInputStream);\n\n        CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n        assertNotNull(gzip);\n        assertTrue(gzip instanceof GzipCompressorInputStream);\n        \n        CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n        assertNotNull(pack200);\n        assertTrue(pack200 instanceof Pack200CompressorInputStream);\n\n        CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n        assertNotNull(xz);\n        assertTrue(xz instanceof XZCompressorInputStream);\n\n        CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n        assertNotNull(zlib);\n        assertTrue(zlib instanceof DeflateCompressorInputStream);\n\n        try {\n            factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));\n            fail(\"No exception thrown for an empty input stream\");\n        } catch (CompressorException e) {\n            // expected\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An extra field that stores UNIX UID/GID data (owner &amp; group ownership) for a given\n * zip entry.  We're using the field definition given in Info-Zip's source archive:\n * zip-3.0.tar.gz/proginfo/extrafld.txt\n *\n * <pre>\n * Local-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7875        Short       tag for this extra block type (\"ux\")\n * TSize         Short       total data size for this block\n * Version       1 byte      version of this extra field, currently 1\n * UIDSize       1 byte      Size of UID field\n * UID           Variable    UID for this entry (little endian)\n * GIDSize       1 byte      Size of GID field\n * GID           Variable    GID for this entry (little endian)\n *\n * Central-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7855        Short       tag for this extra block type (\"Ux\")\n * TSize         Short       total data size for this block (0)\n * </pre>\n * @since 1.5\n */\npublic class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n    private static final long serialVersionUID = 1L;\n    private int version = 1; // always '1' according to current info-zip spec.\n    private BigInteger uid;\n    private BigInteger gid;\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    public void parseFromLocalFileData(\n            byte[] data, int offset, int length\n    ) throws ZipException;\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it.   Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array);\n    /**\n     * The Header-ID.\n     *\n     * @return the value for the header id for this extrafield\n     */\n    public ZipShort getHeaderId();\n    /**\n     * Gets the GID as a long.  GID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the GID value.\n     */\n    public long getGID()  return ZipUtil.bigToLong(gid); };\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getLocalFileDataData();\n    /**\n     * Sets the GID.\n     *\n     * @param l GID value to set on this extra field.\n     */\n    public void setGID(long l);\n    public void parseFromCentralDirectoryData(\n            byte[] buffer, int offset, int length\n    ) throws ZipException;\n    /**\n     * Sets the UID.\n     *\n     * @param l UID value to set on this extra field.\n     */\n    public void setUID(long l);\n    @Override\n    public boolean equals(Object o);\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getCentralDirectoryData();\n    /**\n     * Length of the extra field in the central directory data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getCentralDirectoryLength();\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getLocalFileDataLength();\n    /**\n     * Gets the UID as a long.  UID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the UID value.\n     */\n    public long getUID()  return ZipUtil.bigToLong(uid); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An extra field that stores UNIX UID/GID data (owner &amp; group ownership) for a given\n * zip entry.  We're using the field definition given in Info-Zip's source archive:\n * zip-3.0.tar.gz/proginfo/extrafld.txt\n *\n * <pre>\n * Local-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7875        Short       tag for this extra block type (\"ux\")\n * TSize         Short       total data size for this block\n * Version       1 byte      version of this extra field, currently 1\n * UIDSize       1 byte      Size of UID field\n * UID           Variable    UID for this entry (little endian)\n * GIDSize       1 byte      Size of GID field\n * GID           Variable    GID for this entry (little endian)\n *\n * Central-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7855        Short       tag for this extra block type (\"Ux\")\n * TSize         Short       total data size for this block (0)\n * </pre>\n * @since 1.5\n */\npublic class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n    private static final long serialVersionUID = 1L;\n    private int version = 1; // always '1' according to current info-zip spec.\n    private BigInteger uid;\n    private BigInteger gid;\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    public void parseFromLocalFileData(\n            byte[] data, int offset, int length\n    ) throws ZipException;\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it.   Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array);\n    /**\n     * The Header-ID.\n     *\n     * @return the value for the header id for this extrafield\n     */\n    public ZipShort getHeaderId();\n    /**\n     * Gets the GID as a long.  GID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the GID value.\n     */\n    public long getGID()  return ZipUtil.bigToLong(gid); };\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getLocalFileDataData();\n    /**\n     * Sets the GID.\n     *\n     * @param l GID value to set on this extra field.\n     */\n    public void setGID(long l);\n    public void parseFromCentralDirectoryData(\n            byte[] buffer, int offset, int length\n    ) throws ZipException;\n    /**\n     * Sets the UID.\n     *\n     * @param l UID value to set on this extra field.\n     */\n    public void setUID(long l);\n    @Override\n    public boolean equals(Object o);\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getCentralDirectoryData();\n    /**\n     * Length of the extra field in the central directory data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getCentralDirectoryLength();\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getLocalFileDataLength();\n    /**\n     * Gets the UID as a long.  UID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the UID value.\n     */\n    public long getUID()  return ZipUtil.bigToLong(uid); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static byte[] trimTest(byte[] b) { return X7875_NewUnix.trimLeadingZeroesForceMinLength(b); }\n    private void parseReparse(\n            final long uid,\n            final long gid,\n            final byte[] expected,\n            final long expectedUID,\n            final long expectedGID\n    ) throws ZipException {\n\n        // Initial local parse (init with garbage to avoid defaults causing test to pass).\n        xf.setUID(54321);\n        xf.setGID(12345);\n        xf.parseFromLocalFileData(expected, 0, expected.length);\n        assertEquals(expectedUID, xf.getUID());\n        assertEquals(expectedGID, xf.getGID());\n\n        xf.setUID(uid);\n        xf.setGID(gid);\n        if (expected.length < 5) {\n            // We never emit zero-length entries.\n            assertEquals(5, xf.getLocalFileDataLength().getValue());\n        } else {\n            assertEquals(expected.length, xf.getLocalFileDataLength().getValue());\n        }\n        byte[] result = xf.getLocalFileDataData();\n        if (expected.length < 5) {\n            // We never emit zero-length entries.\n            assertTrue(Arrays.equals(new byte[]{1,1,0,1,0}, result));\n        } else {\n            assertTrue(Arrays.equals(expected, result));\n        }\n\n\n\n        // And now we re-parse:\n        xf.parseFromLocalFileData(result, 0, result.length);\n\n        // Did uid/gid change from re-parse?  They shouldn't!\n        assertEquals(expectedUID, xf.getUID());\n        assertEquals(expectedGID, xf.getGID());\n\n        assertEquals(0, xf.getCentralDirectoryLength().getValue());\n        result = xf.getCentralDirectoryData();\n        assertArrayEquals(new byte[0], result);\n\n        // And now we re-parse:\n        xf.parseFromCentralDirectoryData(result, 0, result.length);\n\n        // Did uid/gid change from 2nd re-parse?  They shouldn't!\n        assertEquals(expectedUID, xf.getUID());\n        assertEquals(expectedGID, xf.getGID());\n    }\n    public void testParseReparse() throws ZipException {\n\n        // Version=1, Len=0, Len=0.\n        final byte[] ZERO_LEN = {1, 0, 0};\n\n        // Version=1, Len=1, zero, Len=1, zero.\n        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n\n        // Version=1, Len=1, one, Len=1, one\n        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n\n        // Version=1, Len=2, one thousand, Len=2, one thousand\n        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n\n        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n        // two's complement, and -1 often has a special meaning.\n        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n\n        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n        // Esoteric test:  can we handle 40 bit numbers?\n        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n\n        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n        // Esoteric test:  can we handle 64 bit numbers?\n        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n\n        final long TWO_TO_32 = 0x100000000L;\n        final long MAX = TWO_TO_32 - 2;\n\n        parseReparse(0, 0, ZERO_LEN, 0, 0);\n        parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n        parseReparse(1, 1, ONE_UID_GID, 1, 1);\n        parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n        parseReparse(MAX, MAX, UNIX_MAX_UID_GID, MAX, MAX);\n        parseReparse(-2, -2, UNIX_MAX_UID_GID, MAX, MAX);\n        parseReparse(TWO_TO_32, TWO_TO_32 + 1, LENGTH_5, TWO_TO_32, TWO_TO_32 + 1);\n        parseReparse(Long.MAX_VALUE - 1, Long.MAX_VALUE, LENGTH_8, Long.MAX_VALUE - 1, Long.MAX_VALUE);\n\n        // We never emit this, but we should be able to parse it:\n        final byte[] SPURIOUS_ZEROES_1 = {1, 4, -1, 0, 0, 0, 4, -128, 0, 0, 0};\n        final byte[] EXPECTED_1 = {1, 1, -1, 1, -128};\n        xf.parseFromLocalFileData(SPURIOUS_ZEROES_1, 0, SPURIOUS_ZEROES_1.length);\n\n        assertEquals(255, xf.getUID());\n        assertEquals(128, xf.getGID());\n        assertTrue(Arrays.equals(EXPECTED_1, xf.getLocalFileDataData()));\n\n        final byte[] SPURIOUS_ZEROES_2 = {1, 4, -1, -1, 0, 0, 4, 1, 2, 0, 0};\n        final byte[] EXPECTED_2 = {1, 2, -1, -1, 2, 1, 2};\n        xf.parseFromLocalFileData(SPURIOUS_ZEROES_2, 0, SPURIOUS_ZEROES_2.length);\n\n        assertEquals(65535, xf.getUID());\n        assertEquals(513, xf.getGID());\n        assertTrue(Arrays.equals(EXPECTED_2, xf.getLocalFileDataData()));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Compute the checksum of a tar entry header.\n     *\n     * @param buf The tar entry's header buffer.\n     * @return The computed checksum.\n     */\n    public static long computeCheckSum(final byte[] buf);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Compute the checksum of a tar entry header.\n     *\n     * @param buf The tar entry's header buffer.\n     * @return The computed checksum.\n     */\n    public static long computeCheckSum(final byte[] buf);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private ArchiveInputStream getStreamFor(String resource)\n            throws ArchiveException, IOException {\n        return factory.createArchiveInputStream(\n                   new BufferedInputStream(new FileInputStream(\n                       getFile(resource))));\n    }\n    private void checkEmptyArchive(String type) throws Exception{\n        File ar = createEmptyArchive(type); // will be deleted by tearDown()\n        ar.deleteOnExit(); // Just in case file cannot be deleted\n        ArchiveInputStream ais = null;\n        BufferedInputStream in = null;\n        try {\n            in = new BufferedInputStream(new FileInputStream(ar));\n            ais = factory.createArchiveInputStream(in);\n        } catch (ArchiveException ae) {\n            fail(\"Should have recognised empty archive for \"+type);\n        } finally {\n            if (ais != null) {\n                ais.close(); // will close input as well\n            } else if (in != null){\n                in.close();\n            }\n        }\n    }\n    public void testCOMPRESS335() throws Exception {\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n        assertNotNull(tar);\n        assertTrue(tar instanceof TarArchiveInputStream);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Reads a 7z file, using RandomAccessFile under\n * the covers.\n * <p>\n * The 7z file format is a flexible container\n * that can contain many compression and\n * encryption types, but at the moment only\n * only Copy, LZMA, LZMA2, BZIP2, Deflate and AES-256 + SHA-256\n * are supported.\n * <p>\n * The format is very Windows/Intel specific,\n * so it uses little-endian byte order,\n * doesn't store user/group or permission bits,\n * and represents times using NTFS timestamps\n * (100 nanosecond units since 1 January 1601).\n * Hence the official tools recommend against\n * using it for backup purposes on *nix, and\n * recommend .tar.7z or .tar.lzma or .tar.xz\n * instead.  \n * <p>\n * Both the header and file contents may be\n * compressed and/or encrypted. With both\n * encrypted, neither file names nor file\n * contents can be read, but the use of\n * encryption isn't plausibly deniable.\n * \n * @NotThreadSafe\n * @since 1.6\n */\npublic class SevenZFile implements Closeable {\n    private final String fileName;\n    private RandomAccessFile file;\n    private final Archive archive;\n    private int currentEntryIndex = -1;\n    private int currentFolderIndex = -1;\n    private InputStream currentFolderInputStream = null;\n    private byte[] password;\n    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @param off offset into the buffer to start filling at\n     * @param len of bytes to read\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b, final int off, final int len) throws IOException;\n    /**\n     * Closes the archive.\n     * @throws IOException if closing the file fails\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Reads a byte of data.\n     * \n     * @return the byte read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read() throws IOException;\n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b) throws IOException;\n    /**\n     * Returns the next Archive Entry in this archive.\n     *\n     * @return the next entry,\n     *         or {@code null} if there are no more entries\n     * @throws IOException if the next entry could not be read\n     */\n    public SevenZArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Reads a 7z file, using RandomAccessFile under\n * the covers.\n * <p>\n * The 7z file format is a flexible container\n * that can contain many compression and\n * encryption types, but at the moment only\n * only Copy, LZMA, LZMA2, BZIP2, Deflate and AES-256 + SHA-256\n * are supported.\n * <p>\n * The format is very Windows/Intel specific,\n * so it uses little-endian byte order,\n * doesn't store user/group or permission bits,\n * and represents times using NTFS timestamps\n * (100 nanosecond units since 1 January 1601).\n * Hence the official tools recommend against\n * using it for backup purposes on *nix, and\n * recommend .tar.7z or .tar.lzma or .tar.xz\n * instead.  \n * <p>\n * Both the header and file contents may be\n * compressed and/or encrypted. With both\n * encrypted, neither file names nor file\n * contents can be read, but the use of\n * encryption isn't plausibly deniable.\n * \n * @NotThreadSafe\n * @since 1.6\n */\npublic class SevenZFile implements Closeable {\n    private final String fileName;\n    private RandomAccessFile file;\n    private final Archive archive;\n    private int currentEntryIndex = -1;\n    private int currentFolderIndex = -1;\n    private InputStream currentFolderInputStream = null;\n    private byte[] password;\n    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @param off offset into the buffer to start filling at\n     * @param len of bytes to read\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b, final int off, final int len) throws IOException;\n    /**\n     * Closes the archive.\n     * @throws IOException if closing the file fails\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Reads a byte of data.\n     * \n     * @return the byte read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read() throws IOException;\n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b) throws IOException;\n    /**\n     * Returns the next Archive Entry in this archive.\n     *\n     * @return the next entry,\n     *         or {@code null} if there are no more entries\n     * @throws IOException if the next entry could not be read\n     */\n    public SevenZArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private byte[] readFully(final SevenZFile archive) throws IOException {\n        final byte [] buf = new byte [1024];\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (int len = 0; (len = archive.read(buf)) > 0;) {\n            baos.write(buf, 0, len);\n        }\n        return baos.toByteArray();\n    }\n    private void test7zUnarchive(final File f, final SevenZMethod m) throws Exception {\n        test7zUnarchive(f, m, null);\n    }\n    private void test7zUnarchive(final File f, final SevenZMethod m, final byte[] password) throws Exception {\n        final SevenZFile sevenZFile = new SevenZFile(f, password);\n        try {\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            assertEquals(\"test1.xml\", entry.getName());\n            assertEquals(m, entry.getContentMethods().iterator().next().getMethod());\n            entry = sevenZFile.getNextEntry();\n            assertEquals(\"test2.xml\", entry.getName());\n            assertEquals(m, entry.getContentMethods().iterator().next().getMethod());\n            final byte[] contents = new byte[(int)entry.getSize()];\n            int off = 0;\n            while ((off < contents.length)) {\n                final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                assert(bytesRead >= 0);\n                off += bytesRead;\n            }\n            assertEquals(TEST2_CONTENT, new String(contents, \"UTF-8\"));\n            assertNull(sevenZFile.getNextEntry());\n        } finally {\n            sevenZFile.close();\n        }\n    }\n    private void checkHelloWorld(final String filename) throws Exception {\n        final SevenZFile sevenZFile = new SevenZFile(getFile(filename));\n        try {\n            final SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            assertEquals(\"Hello world.txt\", entry.getName());\n            final byte[] contents = new byte[(int)entry.getSize()];\n            int off = 0;\n            while ((off < contents.length)) {\n                final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                assert(bytesRead >= 0);\n                off += bytesRead;\n            }\n            assertEquals(\"Hello, world!\\n\", new String(contents, \"UTF-8\"));\n            assertNull(sevenZFile.getNextEntry());\n        } finally {\n            sevenZFile.close();\n        }\n    }\n    private static boolean isStrongCryptoAvailable() throws NoSuchAlgorithmException {\n        return Cipher.getMaxAllowedKeyLength(\"AES/ECB/PKCS5Padding\") >= 256;\n    }\n    public void readEntriesOfSize0() throws IOException {\n        final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n        try {\n            int entries = 0;\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            while (entry != null) {\n                entries++;\n                int b = sevenZFile.read();\n                if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n                    assertEquals(-1, b);\n                } else {\n                    assertNotEquals(-1, b);\n                }\n                entry = sevenZFile.getNextEntry();\n            }\n            assertEquals(5, entries);\n        } finally {\n            sevenZFile.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    private Map<String, String> globalPaxHeaders = new HashMap<String, String>();\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException;\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarInputStream reads a UNIX tar archive as an InputStream.\n * methods are provided to position at each successive entry in\n * the archive, and the read each entry as a normal input stream\n * using read().\n * @NotThreadSafe\n */\npublic class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n    private final int recordSize;\n    private final int blockSize;\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private final InputStream is;\n    private TarArchiveEntry currEntry;\n    private final ZipEncoding zipEncoding;\n    private Map<String, String> globalPaxHeaders = new HashMap<String, String>();\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException;\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException;\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void datePriorToEpoch(final String archive) throws Exception {\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(getFile(archive)));\n            final TarArchiveEntry tae = in.getNextTarEntry();\n            assertEquals(\"foo\", tae.getName());\n            final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n            cal.set(1969, 11, 31, 23, 59, 59);\n            cal.set(Calendar.MILLISECOND, 0);\n            assertEquals(cal.getTime(), tae.getLastModifiedDate());\n            assertTrue(tae.isCheckSumOK());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n    private TarArchiveInputStream getTestStream(final String name) {\n        return new TarArchiveInputStream(\n                TarArchiveInputStreamTest.class.getResourceAsStream(name));\n    }\n    public void survivesBlankLinesInPaxHeader() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class represents an entry in a Tar archive. It consists\n * of the entry's header, as well as the entry's File. Entries\n * can be instantiated in one of three ways, depending on how\n * they are to be used.\n * <p>\n * TarEntries that are created from the header bytes read from\n * an archive are instantiated with the TarEntry( byte[] )\n * constructor. These entries will be used when extracting from\n * or listing the contents of an archive. These entries have their\n * header filled in using the header bytes. They also set the File\n * to null, since they reference an archive entry not a file.\n * <p>\n * TarEntries that are created from Files that are to be written\n * into an archive are instantiated with the TarEntry( File )\n * constructor. These entries have their header filled in using\n * the File's information. They also keep a reference to the File\n * for convenience when writing entries.\n * <p>\n * Finally, TarEntries can be constructed from nothing but a name.\n * This allows the programmer to construct the entry by hand, for\n * instance when only an InputStream is available for writing to\n * the archive, and the header information is constructed from\n * other information. In this case the header fields are set to\n * defaults and the File is set to null.\n *\n * <p>\n * The C structure for a Tar Entry's header is:\n * <pre>\n * struct header {\n * char name[100];     // TarConstants.NAMELEN    - offset   0\n * char mode[8];       // TarConstants.MODELEN    - offset 100\n * char uid[8];        // TarConstants.UIDLEN     - offset 108\n * char gid[8];        // TarConstants.GIDLEN     - offset 116\n * char size[12];      // TarConstants.SIZELEN    - offset 124\n * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\n * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\n * char linkflag[1];   //                         - offset 156\n * char linkname[100]; // TarConstants.NAMELEN    - offset 157\n * The following fields are only present in new-style POSIX tar archives:\n * char magic[6];      // TarConstants.MAGICLEN   - offset 257\n * char version[2];    // TarConstants.VERSIONLEN - offset 263\n * char uname[32];     // TarConstants.UNAMELEN   - offset 265\n * char gname[32];     // TarConstants.GNAMELEN   - offset 297\n * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\n * char devminor[8];   // TarConstants.DEVLEN     - offset 337\n * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\n * // Used if \"name\" field is not long enough to hold the path\n * char pad[12];       // NULs                    - offset 500\n * } header;\n * All unused bytes are set to null.\n * New-style GNU tar files are slightly different from the above.\n * For values of size larger than 077777777777L (11 7s)\n * or uid and gid larger than 07777777L (7 7s)\n * the sign bit of the first byte is set, and the rest of the\n * field is the binary representation of the number.\n * See TarUtils.parseOctalOrBinary.\n * </pre>\n *\n * <p>\n * The C structure for a old GNU Tar Entry's header is:\n * <pre>\n * struct oldgnu_header {\n * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n * };\n * </pre>\n * Whereas, \"struct sparse\" is:\n * <pre>\n * struct sparse {\n * char offset[12];   // offset 0\n * char numbytes[12]; // offset 12\n * };\n * </pre>\n *\n * <p>\n * The C structure for a xstar (J\u00f6rg Schilling star) Tar Entry's header is:\n * <pre>\n * struct star_header {\n *  char name[100];\t\t// offset   0\n *  char mode[8];\t\t// offset 100\n *  char uid[8];\t\t// offset 108\n *  char gid[8];\t\t// offset 116\n *  char size[12];\t\t// offset 124\n *  char mtime[12];\t\t// offset 136\n *  char chksum[8];\t\t// offset 148\n *  char typeflag;\t\t// offset 156\n *  char linkname[100];\t\t// offset 157\n *  char magic[6];\t\t// offset 257\n *  char version[2];\t\t// offset 263\n *  char uname[32];\t\t// offset 265\n *  char gname[32];\t\t// offset 297\n *  char devmajor[8];\t\t// offset 329\n *  char devminor[8];\t\t// offset 337\n *  char prefix[131];\t\t// offset 345\n *  char atime[12];             // offset 476\n *  char ctime[12];             // offset 488\n *  char mfill[8];              // offset 500 \n *  char xmagic[4];             // offset 508  \"tar\"\n * };\n * </pre>\n * <p>which is identical to new-style POSIX up to the first 130 bytes of the prefix.</p>\n *\n * @NotThreadSafe\n */\npublic class TarArchiveEntry implements TarConstants, ArchiveEntry {\n    private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n    private String name = \"\";\n    private boolean preserveLeadingSlashes;\n    private int mode;\n    private long userId = 0;\n    private long groupId = 0;\n    private long size = 0;\n    private long modTime;\n    private boolean checkSumOK;\n    private byte linkFlag;\n    private String linkName = \"\";\n    private String magic = MAGIC_POSIX;\n    private String version = VERSION_POSIX;\n    private String userName;\n    private String groupName = \"\";\n    private int devMajor = 0;\n    private int devMinor = 0;\n    private boolean isExtended;\n    private long realSize;\n    private boolean paxGNUSparse;\n    private boolean starSparse;\n    private final File file;\n    public static final int MAX_NAMELEN = 31;\n    public static final int DEFAULT_DIR_MODE = 040755;\n    public static final int DEFAULT_FILE_MODE = 0100644;\n    public static final int MILLIS_PER_SECOND = 1000;\n    /**\n     * Get this entry's name.\n     *\n     * @return This entry's name.\n     */\n    @Override\n    public String getName();\n    /**\n     * Get this entry's checksum status.\n     *\n     * @return if the header checksum is reasonably correct\n     * @see TarUtils#verifyCheckSum(byte[])\n     * @since 1.5\n     */\n    public boolean isCheckSumOK();\n    @Override\n    public Date getLastModifiedDate();\n    /**\n     * Get this entry's file.\n     *\n     * @return This entry's file.\n     */\n    public File getFile();\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class represents an entry in a Tar archive. It consists\n * of the entry's header, as well as the entry's File. Entries\n * can be instantiated in one of three ways, depending on how\n * they are to be used.\n * <p>\n * TarEntries that are created from the header bytes read from\n * an archive are instantiated with the TarEntry( byte[] )\n * constructor. These entries will be used when extracting from\n * or listing the contents of an archive. These entries have their\n * header filled in using the header bytes. They also set the File\n * to null, since they reference an archive entry not a file.\n * <p>\n * TarEntries that are created from Files that are to be written\n * into an archive are instantiated with the TarEntry( File )\n * constructor. These entries have their header filled in using\n * the File's information. They also keep a reference to the File\n * for convenience when writing entries.\n * <p>\n * Finally, TarEntries can be constructed from nothing but a name.\n * This allows the programmer to construct the entry by hand, for\n * instance when only an InputStream is available for writing to\n * the archive, and the header information is constructed from\n * other information. In this case the header fields are set to\n * defaults and the File is set to null.\n *\n * <p>\n * The C structure for a Tar Entry's header is:\n * <pre>\n * struct header {\n * char name[100];     // TarConstants.NAMELEN    - offset   0\n * char mode[8];       // TarConstants.MODELEN    - offset 100\n * char uid[8];        // TarConstants.UIDLEN     - offset 108\n * char gid[8];        // TarConstants.GIDLEN     - offset 116\n * char size[12];      // TarConstants.SIZELEN    - offset 124\n * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\n * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\n * char linkflag[1];   //                         - offset 156\n * char linkname[100]; // TarConstants.NAMELEN    - offset 157\n * The following fields are only present in new-style POSIX tar archives:\n * char magic[6];      // TarConstants.MAGICLEN   - offset 257\n * char version[2];    // TarConstants.VERSIONLEN - offset 263\n * char uname[32];     // TarConstants.UNAMELEN   - offset 265\n * char gname[32];     // TarConstants.GNAMELEN   - offset 297\n * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\n * char devminor[8];   // TarConstants.DEVLEN     - offset 337\n * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\n * // Used if \"name\" field is not long enough to hold the path\n * char pad[12];       // NULs                    - offset 500\n * } header;\n * All unused bytes are set to null.\n * New-style GNU tar files are slightly different from the above.\n * For values of size larger than 077777777777L (11 7s)\n * or uid and gid larger than 07777777L (7 7s)\n * the sign bit of the first byte is set, and the rest of the\n * field is the binary representation of the number.\n * See TarUtils.parseOctalOrBinary.\n * </pre>\n *\n * <p>\n * The C structure for a old GNU Tar Entry's header is:\n * <pre>\n * struct oldgnu_header {\n * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n * };\n * </pre>\n * Whereas, \"struct sparse\" is:\n * <pre>\n * struct sparse {\n * char offset[12];   // offset 0\n * char numbytes[12]; // offset 12\n * };\n * </pre>\n *\n * <p>\n * The C structure for a xstar (J\u00f6rg Schilling star) Tar Entry's header is:\n * <pre>\n * struct star_header {\n *  char name[100];\t\t// offset   0\n *  char mode[8];\t\t// offset 100\n *  char uid[8];\t\t// offset 108\n *  char gid[8];\t\t// offset 116\n *  char size[12];\t\t// offset 124\n *  char mtime[12];\t\t// offset 136\n *  char chksum[8];\t\t// offset 148\n *  char typeflag;\t\t// offset 156\n *  char linkname[100];\t\t// offset 157\n *  char magic[6];\t\t// offset 257\n *  char version[2];\t\t// offset 263\n *  char uname[32];\t\t// offset 265\n *  char gname[32];\t\t// offset 297\n *  char devmajor[8];\t\t// offset 329\n *  char devminor[8];\t\t// offset 337\n *  char prefix[131];\t\t// offset 345\n *  char atime[12];             // offset 476\n *  char ctime[12];             // offset 488\n *  char mfill[8];              // offset 500 \n *  char xmagic[4];             // offset 508  \"tar\"\n * };\n * </pre>\n * <p>which is identical to new-style POSIX up to the first 130 bytes of the prefix.</p>\n *\n * @NotThreadSafe\n */\npublic class TarArchiveEntry implements TarConstants, ArchiveEntry {\n    private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n    private String name = \"\";\n    private boolean preserveLeadingSlashes;\n    private int mode;\n    private long userId = 0;\n    private long groupId = 0;\n    private long size = 0;\n    private long modTime;\n    private boolean checkSumOK;\n    private byte linkFlag;\n    private String linkName = \"\";\n    private String magic = MAGIC_POSIX;\n    private String version = VERSION_POSIX;\n    private String userName;\n    private String groupName = \"\";\n    private int devMajor = 0;\n    private int devMinor = 0;\n    private boolean isExtended;\n    private long realSize;\n    private boolean paxGNUSparse;\n    private boolean starSparse;\n    private final File file;\n    public static final int MAX_NAMELEN = 31;\n    public static final int DEFAULT_DIR_MODE = 040755;\n    public static final int DEFAULT_FILE_MODE = 0100644;\n    public static final int MILLIS_PER_SECOND = 1000;\n    /**\n     * Get this entry's name.\n     *\n     * @return This entry's name.\n     */\n    @Override\n    public String getName();\n    /**\n     * Get this entry's checksum status.\n     *\n     * @return if the header checksum is reasonably correct\n     * @see TarUtils#verifyCheckSum(byte[])\n     * @since 1.5\n     */\n    public boolean isCheckSumOK();\n    @Override\n    public Date getLastModifiedDate();\n    /**\n     * Get this entry's file.\n     *\n     * @return This entry's file.\n     */\n    public File getFile();\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void datePriorToEpoch(final String archive) throws Exception {\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(getFile(archive)));\n            final TarArchiveEntry tae = in.getNextTarEntry();\n            assertEquals(\"foo\", tae.getName());\n            final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n            cal.set(1969, 11, 31, 23, 59, 59);\n            cal.set(Calendar.MILLISECOND, 0);\n            assertEquals(cal.getTime(), tae.getLastModifiedDate());\n            assertTrue(tae.isCheckSumOK());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n    private TarArchiveInputStream getTestStream(final String name) {\n        return new TarArchiveInputStream(\n                TarArchiveInputStreamTest.class.getResourceAsStream(name));\n    }\n    public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Generic Archive utilities\n */\npublic class ArchiveUtils {\n    /**\n     * Convert a string to Ascii bytes.\n     * Used for comparing \"magic\" strings which need to be independent of the default Locale.\n     * \n     * @param inputString string to convert\n     * @return the bytes\n     */\n    public static byte[] toAsciiBytes(final String inputString);\n    /**\n     * Returns true if the first N bytes of an array are all zero\n     * \n     * @param a\n     *            The array to check\n     * @param size\n     *            The number of characters to check (not the size of the array)\n     * @return true if the first N bytes are zero\n     */\n    public static boolean isArrayZero(final byte[] a, final int size);\n    /**\n     * Generates a string containing the name, isDirectory setting and size of an entry.\n     * <p>\n     * For example:\n     * <pre>\n     * -    2000 main.c\n     * d     100 testfiles\n     * </pre>\n     * \n     * @param entry the entry\n     * @return the representation of the entry\n     */\n    public static String toString(final ArchiveEntry entry);\n    /**\n     * Convert an input byte array to a String using the ASCII character set.\n     * \n     * @param inputBytes bytes to convert\n     * @return the bytes, interpreted as an Ascii string\n     */\n    public static String toAsciiString(final byte[] inputBytes);\n    /**\n     * Convert an input byte array to a String using the ASCII character set.\n     * \n     * @param inputBytes input byte array\n     * @param offset offset within array\n     * @param length length of array\n     * @return the bytes, interpreted as an Ascii string\n     */\n    public static String toAsciiString(final byte[] inputBytes, final int offset, final int length);\n    /**\n     * Returns a \"sanitized\" version of the string given as arguments,\n     * where sanitized means non-printable characters have been\n     * replaced with a question mark and the outcome is not longer\n     * than 255 chars.\n     *\n     * <p>This method is used to clean up file names when they are\n     * used in exception messages as they may end up in log files or\n     * as console output and may have been read from a corrupted\n     * input.</p>\n     *\n     * @param s the string to sanitize\n     * @return a sanitized version of the argument\n     * @since Compress 1.12\n     */\n    public static String sanitize(String s);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Generic Archive utilities\n */\npublic class ArchiveUtils {\n    /**\n     * Convert a string to Ascii bytes.\n     * Used for comparing \"magic\" strings which need to be independent of the default Locale.\n     * \n     * @param inputString string to convert\n     * @return the bytes\n     */\n    public static byte[] toAsciiBytes(final String inputString);\n    /**\n     * Returns true if the first N bytes of an array are all zero\n     * \n     * @param a\n     *            The array to check\n     * @param size\n     *            The number of characters to check (not the size of the array)\n     * @return true if the first N bytes are zero\n     */\n    public static boolean isArrayZero(final byte[] a, final int size);\n    /**\n     * Generates a string containing the name, isDirectory setting and size of an entry.\n     * <p>\n     * For example:\n     * <pre>\n     * -    2000 main.c\n     * d     100 testfiles\n     * </pre>\n     * \n     * @param entry the entry\n     * @return the representation of the entry\n     */\n    public static String toString(final ArchiveEntry entry);\n    /**\n     * Convert an input byte array to a String using the ASCII character set.\n     * \n     * @param inputBytes bytes to convert\n     * @return the bytes, interpreted as an Ascii string\n     */\n    public static String toAsciiString(final byte[] inputBytes);\n    /**\n     * Convert an input byte array to a String using the ASCII character set.\n     * \n     * @param inputBytes input byte array\n     * @param offset offset within array\n     * @param length length of array\n     * @return the bytes, interpreted as an Ascii string\n     */\n    public static String toAsciiString(final byte[] inputBytes, final int offset, final int length);\n    /**\n     * Returns a \"sanitized\" version of the string given as arguments,\n     * where sanitized means non-printable characters have been\n     * replaced with a question mark and the outcome is not longer\n     * than 255 chars.\n     *\n     * <p>This method is used to clean up file names when they are\n     * used in exception messages as they may end up in log files or\n     * as console output and may have been read from a corrupted\n     * input.</p>\n     *\n     * @param s the string to sanitize\n     * @return a sanitized version of the argument\n     * @since Compress 1.12\n     */\n    public static String sanitize(String s);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void asciiToByteAndBackOK(final String inputString) {\n        assertEquals(inputString, ArchiveUtils.toAsciiString(ArchiveUtils.toAsciiBytes(inputString)));\n    }\n    private void asciiToByteAndBackFail(final String inputString) {\n        assertFalse(inputString.equals(ArchiveUtils.toAsciiString(ArchiveUtils.toAsciiBytes(inputString))));\n    }\n    public void sanitizeShortensString() {\n        String input = \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\";\n        String expected = \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901...\";\n        assertEquals(expected, ArchiveUtils.sanitize(input));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private final OutputStream out;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    public void close() throws IOException;\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * \n     * An archive consists of a series of file entries terminated by an\n     * end-of-archive entry, which consists of two 512 blocks of zero bytes. \n     * POSIX.1 requires two EOF records, like some other implementations.\n     * \n     * @throws IOException on error\n     */\n    public void finish() throws IOException;\n}\n/**\n * Performs ChangeSet operations on a stream.\n * This class is thread safe and can be used multiple times.\n * It operates on a copy of the ChangeSet. If the ChangeSet changes,\n * a new Performer must be created.\n * \n * @ThreadSafe\n * @Immutable\n */\npublic class ChangeSetPerformer {\n    private final Set changes;\n    /**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException;\n}\n/**\n * Reimplementation of {@link java.util.zip.ZipOutputStream\n * java.util.zip.ZipOutputStream} that does handle the extended\n * functionality of this package, especially internal/external file\n * attributes and extra fields with different layouts for local file\n * data and central directory entries.\n *\n * <p>This class will try to use {@link java.io.RandomAccessFile\n * RandomAccessFile} when you know that the output is going to go to a\n * file.</p>\n *\n * <p>If RandomAccessFile cannot be used, this implementation will use\n * a Data Descriptor to store size and CRC information for {@link\n * #DEFLATED DEFLATED} entries, this means, you don't need to\n * calculate them yourself.  Unfortunately this is not possible for\n * the {@link #STORED STORED} method, here setting the CRC and\n * uncompressed size information is required before {@link\n * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n * @NotThreadSafe\n */\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    private static final int DEFLATER_BLOCK_SIZE = 8192;\n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n    public static final int EFS_FLAG = 1 << 11;\n    private ZipArchiveEntry entry;\n    private String comment = \"\";\n    private int level = DEFAULT_COMPRESSION;\n    private boolean hasCompressionLevelChanged = false;\n    private int method = java.util.zip.ZipEntry.DEFLATED;\n    private final List entries = new LinkedList();\n    private final CRC32 crc = new CRC32();\n    private long written = 0;\n    private long dataStart = 0;\n    private long localDataStart = 0;\n    private long cdOffset = 0;\n    private long cdLength = 0;\n    private final Map offsets = new HashMap();\n    private String encoding = DEFAULT_ENCODING;\n    /** {@inheritDoc} */\n // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException;\n    /* (non-Javadoc)\n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#finish()\n     */\n    public void finish() throws IOException;\n    /**\n     * Writes bytes to ZIP entry.\n     * @param b the byte array to write\n     * @param offset the start position to write from\n     * @param length the number of bytes to write\n     * @throws IOException on error\n     */\n    public void write(byte[] b, int offset, int length) throws IOException;\n    /**\n     * Writes all necessary data for this entry.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n * <p/>\n * <p/>\n * An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.\n * <p/>\n * <code><pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(\"testfile\");\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * entry.setMode(CpioConstants.C_ISREG); // regular file\n * ... set other attributes, e.g. time, number of links\n * out.putNextEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered threadsafe.\n * \n * based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry entry;\n    private boolean closed = false;\n    private boolean finished;\n    private final short entryFormat;\n    private final HashMap names = new HashMap();\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Begins writing a new CPIO file entry and positions the stream to the\n     * start of the entry data. Closes the current entry if still active. The\n     * current time will be used if the entry has no set modification time and\n     * the default header format will be used if no other format is specified in\n     * the entry.\n     * \n     * @param entry\n     *            the CPIO cpioEntry to be written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException;\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException;\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private final OutputStream out;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    public void close() throws IOException;\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * \n     * An archive consists of a series of file entries terminated by an\n     * end-of-archive entry, which consists of two 512 blocks of zero bytes. \n     * POSIX.1 requires two EOF records, like some other implementations.\n     * \n     * @throws IOException on error\n     */\n    public void finish() throws IOException;\n}\n/**\n * Performs ChangeSet operations on a stream.\n * This class is thread safe and can be used multiple times.\n * It operates on a copy of the ChangeSet. If the ChangeSet changes,\n * a new Performer must be created.\n * \n * @ThreadSafe\n * @Immutable\n */\npublic class ChangeSetPerformer {\n    private final Set changes;\n    /**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException;\n}\n/**\n * Reimplementation of {@link java.util.zip.ZipOutputStream\n * java.util.zip.ZipOutputStream} that does handle the extended\n * functionality of this package, especially internal/external file\n * attributes and extra fields with different layouts for local file\n * data and central directory entries.\n *\n * <p>This class will try to use {@link java.io.RandomAccessFile\n * RandomAccessFile} when you know that the output is going to go to a\n * file.</p>\n *\n * <p>If RandomAccessFile cannot be used, this implementation will use\n * a Data Descriptor to store size and CRC information for {@link\n * #DEFLATED DEFLATED} entries, this means, you don't need to\n * calculate them yourself.  Unfortunately this is not possible for\n * the {@link #STORED STORED} method, here setting the CRC and\n * uncompressed size information is required before {@link\n * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n * @NotThreadSafe\n */\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    private static final int DEFLATER_BLOCK_SIZE = 8192;\n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n    public static final int EFS_FLAG = 1 << 11;\n    private ZipArchiveEntry entry;\n    private String comment = \"\";\n    private int level = DEFAULT_COMPRESSION;\n    private boolean hasCompressionLevelChanged = false;\n    private int method = java.util.zip.ZipEntry.DEFLATED;\n    private final List entries = new LinkedList();\n    private final CRC32 crc = new CRC32();\n    private long written = 0;\n    private long dataStart = 0;\n    private long localDataStart = 0;\n    private long cdOffset = 0;\n    private long cdLength = 0;\n    private final Map offsets = new HashMap();\n    private String encoding = DEFAULT_ENCODING;\n    /** {@inheritDoc} */\n // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException;\n    /* (non-Javadoc)\n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#finish()\n     */\n    public void finish() throws IOException;\n    /**\n     * Writes bytes to ZIP entry.\n     * @param b the byte array to write\n     * @param offset the start position to write from\n     * @param length the number of bytes to write\n     * @throws IOException on error\n     */\n    public void write(byte[] b, int offset, int length) throws IOException;\n    /**\n     * Writes all necessary data for this entry.\n     * @throws IOException on error\n     */\n    public void closeArchiveEntry() throws IOException;\n}\n/**\n * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n * CPIO are supported (old ASCII, old binary, new portable format and the new\n * portable format with CRC).\n * <p/>\n * <p/>\n * An entry can be written by creating an instance of CpioArchiveEntry and fill\n * it with the necessary values and put it into the CPIO stream. Afterwards\n * write the contents of the file into the CPIO stream. Either close the stream\n * by calling finish() or put a next entry into the cpio stream.\n * <p/>\n * <code><pre>\n * CpioArchiveOutputStream out = new CpioArchiveOutputStream(\n *         new FileOutputStream(new File(\"test.cpio\")));\n * CpioArchiveEntry entry = new CpioArchiveEntry();\n * entry.setName(\"testfile\");\n * String contents = &quot;12345&quot;;\n * entry.setFileSize(contents.length());\n * entry.setMode(CpioConstants.C_ISREG); // regular file\n * ... set other attributes, e.g. time, number of links\n * out.putNextEntry(entry);\n * out.write(testContents.getBytes());\n * out.close();\n * </pre></code>\n * <p/>\n * Note: This implementation should be compatible to cpio 2.5\n * \n * This class uses mutable fields and is not considered threadsafe.\n * \n * based on code from the jRPM project (jrpm.sourceforge.net)\n */\npublic class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n    private CpioArchiveEntry entry;\n    private boolean closed = false;\n    private boolean finished;\n    private final short entryFormat;\n    private final HashMap names = new HashMap();\n    private long crc = 0;\n    private long written;\n    private final OutputStream out;\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Begins writing a new CPIO file entry and positions the stream to the\n     * start of the entry data. Closes the current entry if still active. The\n     * current time will be used if the entry has no set modification time and\n     * the default header format will be used if no other format is specified in\n     * the entry.\n     * \n     * @param entry\n     *            the CPIO cpioEntry to be written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n     */\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException;\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException;\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    private void readFully(final byte[] b) throws IOException;\n    @Override\n    public void close() throws IOException;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    private void readFully(final byte[] b) throws IOException;\n    @Override\n    public void close() throws IOException;\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private File createReferenceFile(final File directory, final Zip64Mode zipMode, final String prefix) throws IOException {\n        final File reference = File.createTempFile(prefix, \".zip\", directory);\n        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(reference);\n        zos.setUseZip64(zipMode);\n        createFirstEntry(zos);\n        createSecondEntry(zos);\n        zos.close();\n        return reference;\n    }\n    private ZipArchiveOutputStream createFirstEntry(final ZipArchiveOutputStream zos) throws IOException {\n        createArchiveEntry(first_payload, zos, \"file1.txt\");\n        return zos;\n    }\n    private ZipArchiveOutputStream createSecondEntry(final ZipArchiveOutputStream zos) throws IOException {\n        createArchiveEntry(second_payload, zos, \"file2.txt\");\n        return zos;\n    }\n    private void assertSameFileContents(final File expectedFile, final File actualFile) throws IOException {\n        final int size = (int) Math.max(expectedFile.length(), actualFile.length());\n        final ZipFile expected = new ZipFile(expectedFile);\n        final ZipFile actual = new ZipFile(actualFile);\n        final byte[] expectedBuf = new byte[size];\n        final byte[] actualBuf = new byte[size];\n\n        final Enumeration<ZipArchiveEntry> actualInOrder = actual.getEntriesInPhysicalOrder();\n        final Enumeration<ZipArchiveEntry> expectedInOrder = expected.getEntriesInPhysicalOrder();\n\n        while (actualInOrder.hasMoreElements()){\n            final ZipArchiveEntry actualElement = actualInOrder.nextElement();\n            final ZipArchiveEntry expectedElement = expectedInOrder.nextElement();\n            assertEquals( expectedElement.getName(), actualElement.getName());\n            // Don't compare timestamps since they may vary;\n            // there's no support for stubbed out clock (TimeSource) in ZipArchiveOutputStream\n            assertEquals( expectedElement.getMethod(), actualElement.getMethod());\n            assertEquals( expectedElement.getGeneralPurposeBit(), actualElement.getGeneralPurposeBit());\n            assertEquals( expectedElement.getCrc(), actualElement.getCrc());\n            assertEquals( expectedElement.getCompressedSize(), actualElement.getCompressedSize());\n            assertEquals( expectedElement.getSize(), actualElement.getSize());\n            assertEquals( expectedElement.getExternalAttributes(), actualElement.getExternalAttributes());\n            assertEquals( expectedElement.getInternalAttributes(), actualElement.getInternalAttributes());\n\n            final InputStream actualIs = actual.getInputStream(actualElement);\n            final InputStream expectedIs = expected.getInputStream(expectedElement);\n            IOUtils.readFully(expectedIs, expectedBuf);\n            IOUtils.readFully(actualIs, actualBuf);\n            expectedIs.close();\n            actualIs.close();\n            Assert.assertArrayEquals(expectedBuf, actualBuf); // Buffers are larger than payload. dont care\n        }\n\n        expected.close();\n        actual.close();\n    }\n    private void createArchiveEntry(final String payload, final ZipArchiveOutputStream zos, final String name)\n            throws IOException {\n        final ZipArchiveEntry in = new ZipArchiveEntry(name);\n        zos.putArchiveEntry(in);\n\n        zos.write(payload.getBytes());\n        zos.closeArchiveEntry();\n    }\n    public void testListAllFilesWithNestedArchive() throws Exception {\n        final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n\n        final List<String> results = new ArrayList<>();\n        final List<ZipException> expectedExceptions = new ArrayList<>();\n\n        final InputStream is = new FileInputStream(input);\n        ArchiveInputStream in = null;\n        try {\n            in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n\n            ZipArchiveEntry entry = null;\n            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n                results.add(entry.getName());\n\n                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n                try {\n                    ZipArchiveEntry nestedEntry = null;\n                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n                        results.add(nestedEntry.getName());\n                    }\n                } catch (ZipException ex) {\n                    // expected since you cannot create a final ArchiveInputStream from test3.xml\n                    expectedExceptions.add(ex);\n                }\n                // nested stream must not be closed here\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n        is.close();\n\n        assertTrue(results.contains(\"NestedArchiv.zip\"));\n        assertTrue(results.contains(\"test1.xml\"));\n        assertTrue(results.contains(\"test2.xml\"));\n        assertTrue(results.contains(\"test3.xml\"));\n        assertEquals(1, expectedExceptions.size());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">APPNOTE.TXT</a>:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    public static final int CRC_UNKNOWN = -1;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private static final byte[] EMPTY = new byte[0];\n    private int method = ZipMethod.UNKNOWN_CODE;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int versionRequired;\n    private int versionMadeBy;\n    private int platform = PLATFORM_FAT;\n    private int rawFlag;\n    private long externalAttributes = 0;\n    private ZipExtraField[] extraFields;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    private static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\n    /**\n     * Returns true if this entry represents a unix symlink,\n     * in which case the entry's content contains the target path\n     * for the symlink.\n     *\n     * @since 1.5\n     * @return true if the entry represents a unix symlink, false otherwise.\n     */\n    public boolean isUnixSymlink();\n    /**\n     * Unix permission.\n     * @return the unix permissions\n     */\n    public int getUnixMode();\n}\n/**\n * Constants from stat.h on Unix systems.\n */\npublic interface UnixStat {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * <p>The extra data is expected to follow the recommendation of\n * <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">APPNOTE.TXT</a>:</p>\n * <ul>\n *   <li>the extra byte array consists of a sequence of extra fields</li>\n *   <li>each extra fields starts by a two byte header id followed by\n *   a two byte sequence holding the length of the remainder of\n *   data.</li>\n * </ul>\n *\n * <p>Any extra data that cannot be parsed by the rules above will be\n * consumed as \"unparseable\" extra data and treated differently by the\n * methods of this class.  Versions prior to Apache Commons Compress\n * 1.1 would have thrown an exception if any attempt was made to read\n * or write extra data not conforming to the recommendation.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    public static final int CRC_UNKNOWN = -1;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private static final byte[] EMPTY = new byte[0];\n    private int method = ZipMethod.UNKNOWN_CODE;\n    private long size = SIZE_UNKNOWN;\n    private int internalAttributes = 0;\n    private int versionRequired;\n    private int versionMadeBy;\n    private int platform = PLATFORM_FAT;\n    private int rawFlag;\n    private long externalAttributes = 0;\n    private ZipExtraField[] extraFields;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n    private static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\n    /**\n     * Returns true if this entry represents a unix symlink,\n     * in which case the entry's content contains the target path\n     * for the symlink.\n     *\n     * @since 1.5\n     * @return true if the entry represents a unix symlink, false otherwise.\n     */\n    public boolean isUnixSymlink();\n    /**\n     * Unix permission.\n     * @return the unix permissions\n     */\n    public int getUnixMode();\n}\n/**\n * Constants from stat.h on Unix systems.\n */\npublic interface UnixStat {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception {\n        try (ZipFile zf = new ZipFile(getFile(\"COMPRESS-379.jar\"))) {\n            ZipArchiveEntry ze = zf.getEntry(\"META-INF/maven/\");\n            assertFalse(ze.isUnixSymlink());\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Reimplementation of {@link java.util.zip.ZipOutputStream\n * java.util.zip.ZipOutputStream} that does handle the extended\n * functionality of this package, especially internal/external file\n * attributes and extra fields with different layouts for local file\n * data and central directory entries.\n *\n * <p>This class will try to use {@link\n * java.nio.channels.SeekableByteChannel} when it knows that the\n * output is going to go to a file.</p>\n *\n * <p>If SeekableByteChannel cannot be used, this implementation will use\n * a Data Descriptor to store size and CRC information for {@link\n * #DEFLATED DEFLATED} entries, this means, you don't need to\n * calculate them yourself.  Unfortunately this is not possible for\n * the {@link #STORED STORED} method, here setting the CRC and\n * uncompressed size information is required before {@link\n * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n *\n * <p>As of Apache Commons Compress 1.3 it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries in most cases but explicit\n * control is provided via {@link #setUseZip64}.  If the stream can not\n * use SeekableByteChannel and you try to write a ZipArchiveEntry of\n * unknown size then Zip64 extensions will be disabled by default.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n    private static final int LFH_SIG_OFFSET = 0;\n    private static final int LFH_VERSION_NEEDED_OFFSET = 4;\n    private static final int LFH_GPB_OFFSET = 6;\n    private static final int LFH_METHOD_OFFSET = 8;\n    private static final int LFH_TIME_OFFSET = 10;\n    private static final int LFH_CRC_OFFSET = 14;\n    private static final int LFH_COMPRESSED_SIZE_OFFSET = 18;\n    private static final int LFH_ORIGINAL_SIZE_OFFSET = 22;\n    private static final int LFH_FILENAME_LENGTH_OFFSET = 26;\n    private static final int LFH_EXTRA_LENGTH_OFFSET = 28;\n    private static final int LFH_FILENAME_OFFSET = 30;\n    private static final int CFH_SIG_OFFSET = 0;\n    private static final int CFH_VERSION_MADE_BY_OFFSET = 4;\n    private static final int CFH_VERSION_NEEDED_OFFSET = 6;\n    private static final int CFH_GPB_OFFSET = 8;\n    private static final int CFH_METHOD_OFFSET = 10;\n    private static final int CFH_TIME_OFFSET = 12;\n    private static final int CFH_CRC_OFFSET = 16;\n    private static final int CFH_COMPRESSED_SIZE_OFFSET = 20;\n    private static final int CFH_ORIGINAL_SIZE_OFFSET = 24;\n    private static final int CFH_FILENAME_LENGTH_OFFSET = 28;\n    private static final int CFH_EXTRA_LENGTH_OFFSET = 30;\n    private static final int CFH_COMMENT_LENGTH_OFFSET = 32;\n    private static final int CFH_DISK_NUMBER_OFFSET = 34;\n    private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36;\n    private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38;\n    private static final int CFH_LFH_OFFSET = 42;\n    private static final int CFH_FILENAME_OFFSET = 46;\n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n    public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n    private static final byte[] EMPTY = new byte[0];\n    private CurrentEntry entry;\n    private String comment = \"\";\n    private int level = DEFAULT_COMPRESSION;\n    private boolean hasCompressionLevelChanged = false;\n    private int method = java.util.zip.ZipEntry.DEFLATED;\n    private final StreamCompressor streamCompressor;\n    private long cdOffset = 0;\n    private long cdLength = 0;\n    private static final byte[] ONE = ZipLong.getBytes(1L);\n    private String encoding = DEFAULT_ENCODING;\n    /**\n     * Writes bytes to ZIP entry.\n     * @param b the byte array to write\n     * @param offset the start position to write from\n     * @param length the number of bytes to write\n     * @throws IOException on error\n     */\n    @Override\n    public void write(final byte[] b, final int offset, final int length) throws IOException;\n    /**\n     * Adds an archive entry with a raw input stream.\n     *\n     * If crc, size and compressed size are supplied on the entry, these values will be used as-is.\n     * Zip64 status is re-established based on the settings in this stream, and the supplied value\n     * is ignored.\n     *\n     * The entry is put and closed immediately.\n     *\n     * @param entry The archive entry to add\n     * @param rawStream The raw input stream of a different entry. May be compressed/encrypted.\n     * @throws IOException If copying fails\n     */\n    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\n            throws IOException;\n    /**\n     * Adds UnicodeExtra fields for name and file comment if mode is\n     * ALWAYS or the data cannot be encoded using the configured\n     * encoding.\n     */\n    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable,\n                                       final ByteBuffer name)\n        throws IOException;\n    /**\n     * Writes all necessary data for this entry.\n     * @throws IOException on error\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size exceeds 4 GByte and {@link #setUseZip64} \n     * is {@link Zip64Mode#Never}.\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException;\n    /**\n     * Writes the headers for an archive entry to the output stream.\n     * The caller must then write the content to the stream and call\n     * {@link #closeArchiveEntry()} to complete the process.\n\n     * @param archiveEntry The archiveEntry\n     * @param phased If true size, compressedSize and crc required to be known up-front in the archiveEntry\n     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size is known to exceed 4 GByte and {@link #setUseZip64}\n     * is {@link Zip64Mode#Never}.\n     */\n    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException;\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException;\n    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor);\n    /**\n     * {@inheritDoc} \n     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size is known to exceed 4 GByte and {@link #setUseZip64} \n     * is {@link Zip64Mode#Never}.\n     */\n    @Override\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Reimplementation of {@link java.util.zip.ZipOutputStream\n * java.util.zip.ZipOutputStream} that does handle the extended\n * functionality of this package, especially internal/external file\n * attributes and extra fields with different layouts for local file\n * data and central directory entries.\n *\n * <p>This class will try to use {@link\n * java.nio.channels.SeekableByteChannel} when it knows that the\n * output is going to go to a file.</p>\n *\n * <p>If SeekableByteChannel cannot be used, this implementation will use\n * a Data Descriptor to store size and CRC information for {@link\n * #DEFLATED DEFLATED} entries, this means, you don't need to\n * calculate them yourself.  Unfortunately this is not possible for\n * the {@link #STORED STORED} method, here setting the CRC and\n * uncompressed size information is required before {@link\n * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n *\n * <p>As of Apache Commons Compress 1.3 it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries in most cases but explicit\n * control is provided via {@link #setUseZip64}.  If the stream can not\n * use SeekableByteChannel and you try to write a ZipArchiveEntry of\n * unknown size then Zip64 extensions will be disabled by default.</p>\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveOutputStream extends ArchiveOutputStream {\n    private static final int LFH_SIG_OFFSET = 0;\n    private static final int LFH_VERSION_NEEDED_OFFSET = 4;\n    private static final int LFH_GPB_OFFSET = 6;\n    private static final int LFH_METHOD_OFFSET = 8;\n    private static final int LFH_TIME_OFFSET = 10;\n    private static final int LFH_CRC_OFFSET = 14;\n    private static final int LFH_COMPRESSED_SIZE_OFFSET = 18;\n    private static final int LFH_ORIGINAL_SIZE_OFFSET = 22;\n    private static final int LFH_FILENAME_LENGTH_OFFSET = 26;\n    private static final int LFH_EXTRA_LENGTH_OFFSET = 28;\n    private static final int LFH_FILENAME_OFFSET = 30;\n    private static final int CFH_SIG_OFFSET = 0;\n    private static final int CFH_VERSION_MADE_BY_OFFSET = 4;\n    private static final int CFH_VERSION_NEEDED_OFFSET = 6;\n    private static final int CFH_GPB_OFFSET = 8;\n    private static final int CFH_METHOD_OFFSET = 10;\n    private static final int CFH_TIME_OFFSET = 12;\n    private static final int CFH_CRC_OFFSET = 16;\n    private static final int CFH_COMPRESSED_SIZE_OFFSET = 20;\n    private static final int CFH_ORIGINAL_SIZE_OFFSET = 24;\n    private static final int CFH_FILENAME_LENGTH_OFFSET = 28;\n    private static final int CFH_EXTRA_LENGTH_OFFSET = 30;\n    private static final int CFH_COMMENT_LENGTH_OFFSET = 32;\n    private static final int CFH_DISK_NUMBER_OFFSET = 34;\n    private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36;\n    private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38;\n    private static final int CFH_LFH_OFFSET = 42;\n    private static final int CFH_FILENAME_OFFSET = 46;\n    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n    public static final int STORED = java.util.zip.ZipEntry.STORED;\n    public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n    private static final byte[] EMPTY = new byte[0];\n    private CurrentEntry entry;\n    private String comment = \"\";\n    private int level = DEFAULT_COMPRESSION;\n    private boolean hasCompressionLevelChanged = false;\n    private int method = java.util.zip.ZipEntry.DEFLATED;\n    private final StreamCompressor streamCompressor;\n    private long cdOffset = 0;\n    private long cdLength = 0;\n    private static final byte[] ONE = ZipLong.getBytes(1L);\n    private String encoding = DEFAULT_ENCODING;\n    /**\n     * Writes bytes to ZIP entry.\n     * @param b the byte array to write\n     * @param offset the start position to write from\n     * @param length the number of bytes to write\n     * @throws IOException on error\n     */\n    @Override\n    public void write(final byte[] b, final int offset, final int length) throws IOException;\n    /**\n     * Adds an archive entry with a raw input stream.\n     *\n     * If crc, size and compressed size are supplied on the entry, these values will be used as-is.\n     * Zip64 status is re-established based on the settings in this stream, and the supplied value\n     * is ignored.\n     *\n     * The entry is put and closed immediately.\n     *\n     * @param entry The archive entry to add\n     * @param rawStream The raw input stream of a different entry. May be compressed/encrypted.\n     * @throws IOException If copying fails\n     */\n    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\n            throws IOException;\n    /**\n     * Adds UnicodeExtra fields for name and file comment if mode is\n     * ALWAYS or the data cannot be encoded using the configured\n     * encoding.\n     */\n    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable,\n                                       final ByteBuffer name)\n        throws IOException;\n    /**\n     * Writes all necessary data for this entry.\n     * @throws IOException on error\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size exceeds 4 GByte and {@link #setUseZip64} \n     * is {@link Zip64Mode#Never}.\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException;\n    /**\n     * Writes the headers for an archive entry to the output stream.\n     * The caller must then write the content to the stream and call\n     * {@link #closeArchiveEntry()} to complete the process.\n\n     * @param archiveEntry The archiveEntry\n     * @param phased If true size, compressedSize and crc required to be known up-front in the archiveEntry\n     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size is known to exceed 4 GByte and {@link #setUseZip64}\n     * is {@link Zip64Mode#Never}.\n     */\n    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException;\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException;\n    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor);\n    /**\n     * {@inheritDoc} \n     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     * @throws Zip64RequiredException if the entry's uncompressed or\n     * compressed size is known to exceed 4 GByte and {@link #setUseZip64} \n     * is {@link Zip64Mode#Never}.\n     */\n    @Override\n    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private int findCentralDirectory(byte[] data) {\n        // not a ZIP64 archive, no comment, \"End of central directory record\" at the end\n        return (int) ZipLong.getValue(data, data.length - 22 + 16);\n    }\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     * @throws IOException on error\n     */\n    public static int formatNameBytes(final String name, final byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length);\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     * @throws IOException on error\n     */\n    public static String parseName(final byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The updated offset, i.e. offset + length\n     * @throws IOException on error\n     */\n    public static int formatNameBytes(final String name, final byte[] buf, final int offset,\n                                      final int length,\n                                      final ZipEncoding encoding)\n        throws IOException;\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length);\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length);\n    /**\n     * Copy a name into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length);\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @param encoding name of the encoding to use for file names\n     * @since 1.4\n     * @return The entry name.\n     * @throws IOException on error\n     */\n    public static String parseName(final byte[] buffer, final int offset,\n                                   final int length,\n                                   final ZipEncoding encoding)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void checkRoundTripOctal(final long value, final int bufsize) {\n        final byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void checkRoundTripOctal(final long value) {\n        checkRoundTripOctal(value, TarConstants.SIZELEN);\n    }\n    private void checkRoundTripOctalOrBinary(final long value, final int bufsize) {\n        final byte [] buffer = new byte[bufsize];\n        long parseValue;\n        TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctalOrBinary(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void testRoundTripOctalOrBinary(final int length) {\n        checkRoundTripOctalOrBinary(0, length);\n        checkRoundTripOctalOrBinary(1, length);\n        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, length); // will need binary format\n        checkRoundTripOctalOrBinary(-1, length); // will need binary format\n        checkRoundTripOctalOrBinary(0xff00000000000001l, length);\n    }\n    private void checkName(final String string) {\n        final byte buff[] = new byte[100];\n        final int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n        assertEquals(string, TarUtils.parseName(buff, 0, len));\n    }\n    public void testRoundTripOctalOrBinary8() {\n        testRoundTripOctalOrBinary(8);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * <p>An extra field that stores additional file and directory timestamp data\n * for zip entries.   Each zip entry can include up to three timestamps\n * (modify, access, create*).  The timestamps are stored as 32 bit signed\n * integers representing seconds since UNIX epoch (Jan 1st, 1970, UTC).\n * This field improves on zip's default timestamp granularity, since it\n * allows one to store additional timestamps, and, in addition, the timestamps\n * are stored using per-second granularity (zip's default behaviour can only store\n * timestamps to the nearest <em>even</em> second).\n * </p><p>\n * Unfortunately, 32 (signed) bits can only store dates up to the year 2037,\n * and so this extra field will eventually be obsolete.  Enjoy it while it lasts!\n * </p>\n * <ul>\n * <li><b>modifyTime:</b>\n * most recent time of file/directory modification\n * (or file/dir creation if the entry has not been\n * modified since it was created).\n * </li>\n * <li><b>accessTime:</b>\n * most recent time file/directory was opened\n * (e.g., read from disk).  Many people disable\n * their operating systems from updating this value\n * using the NOATIME mount option to optimize disk behaviour,\n * and thus it's not always reliable.  In those cases\n * it's always equal to modifyTime.\n * </li>\n * <li><b>*createTime:</b>\n * modern linux file systems (e.g., ext2 and newer)\n * do not appear to store a value like this, and so\n * it's usually omitted altogether in the zip extra\n * field.  Perhaps other unix systems track this.\n * </li></ul>\n * <p>\n * We're using the field definition given in Info-Zip's source archive:\n * zip-3.0.tar.gz/proginfo/extrafld.txt\n * </p>\n * <pre>\n * Value         Size        Description\n * -----         ----        -----------\n * 0x5455        Short       tag for this extra block type (\"UT\")\n * TSize         Short       total data size for this block\n * Flags         Byte        info bits\n * (ModTime)     Long        time of last modification (UTC/GMT)\n * (AcTime)      Long        time of last access (UTC/GMT)\n * (CrTime)      Long        time of original creation (UTC/GMT)\n *\n * Central-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x5455        Short       tag for this extra block type (\"UT\")\n * TSize         Short       total data size for this block\n * Flags         Byte        info bits (refers to local header!)\n * (ModTime)     Long        time of last modification (UTC/GMT)\n * </pre>\n * @since 1.5\n */\npublic class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x5455);\n    private static final long serialVersionUID = 1L;\n    public static final byte MODIFY_TIME_BIT = 1;\n    public static final byte ACCESS_TIME_BIT = 2;\n    public static final byte CREATE_TIME_BIT = 4;\n    private byte flags;\n    private boolean bit0_modifyTimePresent;\n    private boolean bit1_accessTimePresent;\n    private boolean bit2_createTimePresent;\n    private ZipLong modifyTime;\n    private ZipLong accessTime;\n    private ZipLong createTime;\n    /**\n     * <p>\n     * Sets the create time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the create time (seconds per epoch)\n     */\n    public void setCreateTime(final ZipLong l);\n    /**\n     * <p>\n     * Sets the modify time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d modify time as java.util.Date\n     */\n    public void setModifyJavaTime(final Date d)  setModifyTime(dateToZipLong(d)); };\n    /**\n     * <p>\n     * Sets the access time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d access time as java.util.Date\n     */\n    public void setAccessJavaTime(final Date d)  setAccessTime(dateToZipLong(d)); };\n    /**\n     * <p>\n     * Returns the create time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time (seconds since epoch) or null.\n     */\n    public ZipLong getCreateTime()  return createTime; };\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    @Override\n    public byte[] getLocalFileDataData();\n    /**\n     * Sets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @param flags flags byte indicating which of the\n     *              three datestamp fields are present.\n     */\n    public void setFlags(final byte flags);\n    /**\n     * <p>\n     * Sets the access time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the access time (seconds per epoch)\n     */\n    public void setAccessTime(final ZipLong l);\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    @Override\n    public void parseFromLocalFileData(\n            final byte[] data, int offset, final int length\n    ) throws ZipException;\n    /**\n     * Returns the modify time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return modify time as java.util.Date or null.\n     */\n    public Date getModifyJavaTime();\n    /**\n     * Returns whether bit1 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a \"last access\" timestamp in this particular zip entry.\n     *\n     * @return true if bit1 of the flags byte is set.\n     */\n    public boolean isBit1_accessTimePresent()  return bit1_accessTimePresent; };\n    /**\n     * <p>\n     * Returns the create time as a a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time as java.util.Date or null.\n     */\n    public Date getCreateJavaTime();\n    /**\n     * <p>\n     * Sets the modify time (seconds since epoch) of this zip entry\n     * using a ZipLong object.\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the modify time (seconds per epoch)\n     */\n    public void setModifyTime(final ZipLong l);\n    /**\n     * Gets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @return flags byte indicating which of the\n     *         three datestamp fields are present.\n     */\n    public byte getFlags()  return flags; };\n    /**\n     * Returns the access time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return access time (seconds since epoch) or null.\n     */\n    public ZipLong getAccessTime()  return accessTime; };\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getLocalFileDataLength();\n    /**\n     * Returns whether bit0 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a modify timestamp in this particular zip entry.\n     *\n     * @return true if bit0 of the flags byte is set.\n     */\n    public boolean isBit0_modifyTimePresent()  return bit0_modifyTimePresent; };\n    /**\n     * Returns whether bit2 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a create timestamp in this particular zip entry.\n     *\n     * @return true if bit2 of the flags byte is set.\n     */\n    public boolean isBit2_createTimePresent()  return bit2_createTimePresent; };\n    /**\n     * <p>\n     * Sets the create time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d create time as java.util.Date\n     */\n    public void setCreateJavaTime(final Date d)  setCreateTime(dateToZipLong(d)); };\n    @Override\n    public void parseFromCentralDirectoryData(\n            final byte[] buffer, final int offset, final int length\n    ) throws ZipException;\n    @Override\n    public boolean equals(final Object o);\n    /**\n     * Returns the modify time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return modify time (seconds since epoch) or null.\n     */\n    public ZipLong getModifyTime()  return modifyTime; };\n    /**\n     * Utility method converts java.util.Date (milliseconds since epoch)\n     * into a ZipLong (seconds since epoch).\n     * <p/>\n     * Also makes sure the converted ZipLong is not too big to fit\n     * in 32 unsigned bits.\n     *\n     * @param d java.util.Date to convert to ZipLong\n     * @return ZipLong\n     */\n    private static ZipLong dateToZipLong(final Date d);\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return the central directory data\n     */\n    @Override\n    public byte[] getCentralDirectoryData();\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * <p>For X5455 the central length is often smaller than the\n     * local length, because central cannot contain access or create\n     * timestamps.</p>\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getCentralDirectoryLength();\n    /**\n     * Returns the access time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return access time as java.util.Date or null.\n     */\n    public Date getAccessJavaTime();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * <p>An extra field that stores additional file and directory timestamp data\n * for zip entries.   Each zip entry can include up to three timestamps\n * (modify, access, create*).  The timestamps are stored as 32 bit signed\n * integers representing seconds since UNIX epoch (Jan 1st, 1970, UTC).\n * This field improves on zip's default timestamp granularity, since it\n * allows one to store additional timestamps, and, in addition, the timestamps\n * are stored using per-second granularity (zip's default behaviour can only store\n * timestamps to the nearest <em>even</em> second).\n * </p><p>\n * Unfortunately, 32 (signed) bits can only store dates up to the year 2037,\n * and so this extra field will eventually be obsolete.  Enjoy it while it lasts!\n * </p>\n * <ul>\n * <li><b>modifyTime:</b>\n * most recent time of file/directory modification\n * (or file/dir creation if the entry has not been\n * modified since it was created).\n * </li>\n * <li><b>accessTime:</b>\n * most recent time file/directory was opened\n * (e.g., read from disk).  Many people disable\n * their operating systems from updating this value\n * using the NOATIME mount option to optimize disk behaviour,\n * and thus it's not always reliable.  In those cases\n * it's always equal to modifyTime.\n * </li>\n * <li><b>*createTime:</b>\n * modern linux file systems (e.g., ext2 and newer)\n * do not appear to store a value like this, and so\n * it's usually omitted altogether in the zip extra\n * field.  Perhaps other unix systems track this.\n * </li></ul>\n * <p>\n * We're using the field definition given in Info-Zip's source archive:\n * zip-3.0.tar.gz/proginfo/extrafld.txt\n * </p>\n * <pre>\n * Value         Size        Description\n * -----         ----        -----------\n * 0x5455        Short       tag for this extra block type (\"UT\")\n * TSize         Short       total data size for this block\n * Flags         Byte        info bits\n * (ModTime)     Long        time of last modification (UTC/GMT)\n * (AcTime)      Long        time of last access (UTC/GMT)\n * (CrTime)      Long        time of original creation (UTC/GMT)\n *\n * Central-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x5455        Short       tag for this extra block type (\"UT\")\n * TSize         Short       total data size for this block\n * Flags         Byte        info bits (refers to local header!)\n * (ModTime)     Long        time of last modification (UTC/GMT)\n * </pre>\n * @since 1.5\n */\npublic class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x5455);\n    private static final long serialVersionUID = 1L;\n    public static final byte MODIFY_TIME_BIT = 1;\n    public static final byte ACCESS_TIME_BIT = 2;\n    public static final byte CREATE_TIME_BIT = 4;\n    private byte flags;\n    private boolean bit0_modifyTimePresent;\n    private boolean bit1_accessTimePresent;\n    private boolean bit2_createTimePresent;\n    private ZipLong modifyTime;\n    private ZipLong accessTime;\n    private ZipLong createTime;\n    /**\n     * <p>\n     * Sets the create time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the create time (seconds per epoch)\n     */\n    public void setCreateTime(final ZipLong l);\n    /**\n     * <p>\n     * Sets the modify time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d modify time as java.util.Date\n     */\n    public void setModifyJavaTime(final Date d)  setModifyTime(dateToZipLong(d)); };\n    /**\n     * <p>\n     * Sets the access time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d access time as java.util.Date\n     */\n    public void setAccessJavaTime(final Date d)  setAccessTime(dateToZipLong(d)); };\n    /**\n     * <p>\n     * Returns the create time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time (seconds since epoch) or null.\n     */\n    public ZipLong getCreateTime()  return createTime; };\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    @Override\n    public byte[] getLocalFileDataData();\n    /**\n     * Sets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @param flags flags byte indicating which of the\n     *              three datestamp fields are present.\n     */\n    public void setFlags(final byte flags);\n    /**\n     * <p>\n     * Sets the access time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the access time (seconds per epoch)\n     */\n    public void setAccessTime(final ZipLong l);\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    @Override\n    public void parseFromLocalFileData(\n            final byte[] data, int offset, final int length\n    ) throws ZipException;\n    /**\n     * Returns the modify time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return modify time as java.util.Date or null.\n     */\n    public Date getModifyJavaTime();\n    /**\n     * Returns whether bit1 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a \"last access\" timestamp in this particular zip entry.\n     *\n     * @return true if bit1 of the flags byte is set.\n     */\n    public boolean isBit1_accessTimePresent()  return bit1_accessTimePresent; };\n    /**\n     * <p>\n     * Returns the create time as a a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time as java.util.Date or null.\n     */\n    public Date getCreateJavaTime();\n    /**\n     * <p>\n     * Sets the modify time (seconds since epoch) of this zip entry\n     * using a ZipLong object.\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the modify time (seconds per epoch)\n     */\n    public void setModifyTime(final ZipLong l);\n    /**\n     * Gets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @return flags byte indicating which of the\n     *         three datestamp fields are present.\n     */\n    public byte getFlags()  return flags; };\n    /**\n     * Returns the access time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return access time (seconds since epoch) or null.\n     */\n    public ZipLong getAccessTime()  return accessTime; };\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getLocalFileDataLength();\n    /**\n     * Returns whether bit0 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a modify timestamp in this particular zip entry.\n     *\n     * @return true if bit0 of the flags byte is set.\n     */\n    public boolean isBit0_modifyTimePresent()  return bit0_modifyTimePresent; };\n    /**\n     * Returns whether bit2 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a create timestamp in this particular zip entry.\n     *\n     * @return true if bit2 of the flags byte is set.\n     */\n    public boolean isBit2_createTimePresent()  return bit2_createTimePresent; };\n    /**\n     * <p>\n     * Sets the create time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d create time as java.util.Date\n     */\n    public void setCreateJavaTime(final Date d)  setCreateTime(dateToZipLong(d)); };\n    @Override\n    public void parseFromCentralDirectoryData(\n            final byte[] buffer, final int offset, final int length\n    ) throws ZipException;\n    @Override\n    public boolean equals(final Object o);\n    /**\n     * Returns the modify time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return modify time (seconds since epoch) or null.\n     */\n    public ZipLong getModifyTime()  return modifyTime; };\n    /**\n     * Utility method converts java.util.Date (milliseconds since epoch)\n     * into a ZipLong (seconds since epoch).\n     * <p/>\n     * Also makes sure the converted ZipLong is not too big to fit\n     * in 32 unsigned bits.\n     *\n     * @param d java.util.Date to convert to ZipLong\n     * @return ZipLong\n     */\n    private static ZipLong dateToZipLong(final Date d);\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return the central directory data\n     */\n    @Override\n    public byte[] getCentralDirectoryData();\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * <p>For X5455 the central length is often smaller than the\n     * local length, because central cannot contain access or create\n     * timestamps.</p>\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getCentralDirectoryLength();\n    /**\n     * Returns the access time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return access time as java.util.Date or null.\n     */\n    public Date getAccessJavaTime();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void parseReparse(\n            final ZipLong time,\n            final byte[] expectedLocal,\n            final byte[] almostExpectedCentral\n    ) throws ZipException {\n        parseReparse(expectedLocal[0], time, expectedLocal[0], expectedLocal, almostExpectedCentral);\n    }\n    private void parseReparse(\n            final byte providedFlags,\n            final ZipLong time,\n            final byte expectedFlags,\n            final byte[] expectedLocal,\n            final byte[] almostExpectedCentral\n    ) throws ZipException {\n\n        // We're responsible for expectedCentral's flags.  Too annoying to set in caller.\n        final byte[] expectedCentral = new byte[almostExpectedCentral.length];\n        System.arraycopy(almostExpectedCentral, 0, expectedCentral, 0, almostExpectedCentral.length);\n        expectedCentral[0] = expectedFlags;\n\n        xf.setModifyTime(time);\n        xf.setAccessTime(time);\n        xf.setCreateTime(time);\n        xf.setFlags(providedFlags);\n        byte[] result = xf.getLocalFileDataData();\n        assertTrue(Arrays.equals(expectedLocal, result));\n\n        // And now we re-parse:\n        xf.parseFromLocalFileData(result, 0, result.length);\n        assertEquals(expectedFlags, xf.getFlags());\n        if (isFlagSet(expectedFlags, MODIFY_TIME_BIT)) {\n            assertTrue(xf.isBit0_modifyTimePresent());\n            assertEquals(time, xf.getModifyTime());\n        }\n        if (isFlagSet(expectedFlags, ACCESS_TIME_BIT)) {\n            assertTrue(xf.isBit1_accessTimePresent());\n            assertEquals(time, xf.getAccessTime());\n        }\n        if (isFlagSet(expectedFlags, CREATE_TIME_BIT)) {\n            assertTrue(xf.isBit2_createTimePresent());\n            assertEquals(time, xf.getCreateTime());\n        }\n\n        // Do the same as above, but with Central Directory data:\n        xf.setModifyTime(time);\n        xf.setAccessTime(time);\n        xf.setCreateTime(time);\n        xf.setFlags(providedFlags);\n        result = xf.getCentralDirectoryData();\n        assertTrue(Arrays.equals(expectedCentral, result));\n\n        // And now we re-parse:\n        xf.parseFromCentralDirectoryData(result, 0, result.length);\n        assertEquals(expectedFlags, xf.getFlags());\n        // Central Directory never contains ACCESS or CREATE, but\n        // may contain MODIFY.\n        if (isFlagSet(expectedFlags, MODIFY_TIME_BIT)) {\n            assertTrue(xf.isBit0_modifyTimePresent());\n            assertEquals(time, xf.getModifyTime());\n        }\n    }\n    private static boolean isFlagSet(final byte data, final byte flag) { return (data & flag) == flag; }\n    private static Date adjustFromGMTToExpectedOffset(final Date from) {\n        final Calendar cal = Calendar.getInstance();\n        cal.setTime(from);\n        cal.add(Calendar.MILLISECOND, cal.get(Calendar.ZONE_OFFSET));\n        if (cal.getTimeZone().inDaylightTime(from)) {\n            cal.add(Calendar.MILLISECOND, cal.get(Calendar.DST_OFFSET));\n        }\n        cal.add(Calendar.HOUR, 8);\n        return cal.getTime();\n    }\n    public void testGettersSetters() {\n        // X5455 is concerned with time, so let's\n        // get a timestamp to play with (Jan 1st, 2000).\n        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n        cal.set(Calendar.YEAR, 2000);\n        cal.set(Calendar.MONTH, Calendar.JANUARY);\n        cal.set(Calendar.DATE, 1);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        final long timeMillis = cal.getTimeInMillis();\n        final ZipLong time = new ZipLong(timeMillis / 1000);\n\n        // set too big\n        try {\n            // Java time is 1000 x larger (milliseconds).\n            xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n            fail(\"Time too big for 32 bits!\");\n        } catch (final IllegalArgumentException iae) {\n            // All is good.\n        }\n\n        // get/set modify time\n        xf.setModifyTime(time);\n        assertEquals(time, xf.getModifyTime());\n        Date xfModifyJavaTime = xf.getModifyJavaTime();\n        assertEquals(timeMillis, xfModifyJavaTime.getTime());\n        xf.setModifyJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getModifyTime());\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setModifyJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getModifyTime());\n        assertEquals(timeMillis, xf.getModifyJavaTime().getTime());\n        // Null\n        xf.setModifyTime(null);\n        assertNull(xf.getModifyJavaTime());\n        xf.setModifyJavaTime(null);\n        assertNull(xf.getModifyTime());\n\n        // get/set access time\n        xf.setAccessTime(time);\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        xf.setAccessJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setAccessJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getAccessTime());\n        assertEquals(timeMillis, xf.getAccessJavaTime().getTime());\n        // Null\n        xf.setAccessTime(null);\n        assertNull(xf.getAccessJavaTime());\n        xf.setAccessJavaTime(null);\n        assertNull(xf.getAccessTime());\n\n        // get/set create time\n        xf.setCreateTime(time);\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        xf.setCreateJavaTime(new Date(timeMillis));\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        // Make sure milliseconds get zeroed out:\n        xf.setCreateJavaTime(new Date(timeMillis + 123));\n        assertEquals(time, xf.getCreateTime());\n        assertEquals(timeMillis, xf.getCreateJavaTime().getTime());\n        // Null\n        xf.setCreateTime(null);\n        assertNull(xf.getCreateJavaTime());\n        xf.setCreateJavaTime(null);\n        assertNull(xf.getCreateTime());\n\n\n        // initialize for flags\n        xf.setModifyTime(time);\n        xf.setAccessTime(time);\n        xf.setCreateTime(time);\n\n        // get/set flags: 000\n        xf.setFlags((byte) 0);\n        assertEquals(0, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=1, Central length=1 (flags only!)\n        assertEquals(1, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 001\n        xf.setFlags((byte) 1);\n        assertEquals(1, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=5 (flags + mod)\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 010\n        xf.setFlags((byte) 2);\n        assertEquals(2, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertFalse(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=1\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 100\n        xf.setFlags((byte) 4);\n        assertEquals(4, xf.getFlags());\n        assertFalse(xf.isBit0_modifyTimePresent());\n        assertFalse(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=5, Central length=1\n        assertEquals(5, xf.getLocalFileDataLength().getValue());\n        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 111\n        xf.setFlags((byte) 7);\n        assertEquals(7, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=13, Central length=5\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n\n        // get/set flags: 11111111\n        xf.setFlags((byte) -1);\n        assertEquals(-1, xf.getFlags());\n        assertTrue(xf.isBit0_modifyTimePresent());\n        assertTrue(xf.isBit1_accessTimePresent());\n        assertTrue(xf.isBit2_createTimePresent());\n        // Local length=13, Central length=5\n        assertEquals(13, xf.getLocalFileDataLength().getValue());\n        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] lfhBuf = new byte[LFH_LEN];\n    private final byte[] skipBuf = new byte[1024];\n    private final byte[] shortBuf = new byte[SHORT];\n    private final byte[] wordBuf = new byte[WORD];\n    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    /**\n     * Whether this entry requires a data descriptor this library can work with.\n     *\n     * @return true if allowStoredEntriesWithDataDescriptor is true,\n     * the entry doesn't require any data descriptor or the method is\n     * DEFLATED or ENHANCED_DEFLATED.\n     */\n    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry);\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException;\n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n *\n * <p>As of Apache Commons Compress it transparently supports Zip64\n * extensions and thus individual entries and archives larger than 4\n * GB or with more than 65536 entries.</p>\n *\n * <p>The {@link ZipFile} class is preferred when reading from files\n * as {@link ZipArchiveInputStream} is limited by not being able to\n * read the central directory header before returning entries.  In\n * particular {@link ZipArchiveInputStream}</p>\n *\n * <ul>\n *\n *  <li>may return entries that are not part of the central directory\n *  at all and shouldn't be considered part of the archive.</li>\n *\n *  <li>may return several entries with the same name.</li>\n *\n *  <li>will not return internal or external attributes.</li>\n *\n *  <li>may return incomplete extra field data.</li>\n *\n *  <li>may return unknown sizes and CRC values for entries until the\n *  next entry has been reached if the archive uses the data\n *  descriptor feature.</li>\n *\n * </ul>\n *\n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n    private CurrentEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private ByteArrayInputStream lastStoredEntry = null;\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    private static final int CFH_LEN = 46;\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n    private final byte[] lfhBuf = new byte[LFH_LEN];\n    private final byte[] skipBuf = new byte[1024];\n    private final byte[] shortBuf = new byte[SHORT];\n    private final byte[] wordBuf = new byte[WORD];\n    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n    private int entriesRead = 0;\n    /**\n     * Whether this entry requires a data descriptor this library can work with.\n     *\n     * @return true if allowStoredEntriesWithDataDescriptor is true,\n     * the entry doesn't require any data descriptor or the method is\n     * DEFLATED or ENHANCED_DEFLATED.\n     */\n    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry);\n    public ZipArchiveEntry getNextZipEntry() throws IOException;\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException;\n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void extractZipInputStream(final ZipArchiveInputStream in)\n        throws IOException {\n        ZipArchiveEntry zae = in.getNextZipEntry();\n        while (zae != null) {\n            if (zae.getName().endsWith(\".zip\")) {\n                extractZipInputStream(new ZipArchiveInputStream(in));\n            }\n            zae = in.getNextZipEntry();\n        }\n    }\n    private static byte[] readEntry(ZipArchiveInputStream zip, ZipArchiveEntry zae) throws IOException {\n        final int len = (int)zae.getSize();\n        final byte[] buff = new byte[len];\n        zip.read(buff, 0, len);\n\n        return buff;\n    }\n    private static void nameSource(String archive, String entry, ZipArchiveEntry.NameSource expected) throws Exception {\n        nameSource(archive, entry, 1, expected);\n    }\n    private static void nameSource(String archive, String entry, int entryNo, ZipArchiveEntry.NameSource expected)\n        throws Exception {\n        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new FileInputStream(getFile(archive)))) {\n            ZipArchiveEntry ze;\n            do {\n                ze = zis.getNextZipEntry();\n            } while (--entryNo > 0);\n            assertEquals(entry, ze.getName());\n            assertEquals(expected, ze.getNameSource());\n        }\n    }\n    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\n        // we never read any data\n        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {\n            ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\n            e.setMethod(ZipMethod.DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.BZIP2.getCode());\n            assertFalse(zis.canReadEntryData(e));\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n * <p>\n * Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information\n * is not available from the header.\n * <p>\n * The {@link ZipFile} class is preferred when reading from files.\n *  \n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final CRC32 crc = new CRC32();\n    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n    private ZipArchiveEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n    private int bytesReadFromStream = 0;\n    private int lengthOfLastRead = 0;\n    private boolean hasDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    public void close() throws IOException;\n    public ArchiveEntry getNextEntry() throws IOException;\n    public int read(byte[] buffer, int start, int length) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implements an input stream that can read Zip archives.\n * <p>\n * Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information\n * is not available from the header.\n * <p>\n * The {@link ZipFile} class is preferred when reading from files.\n *  \n * @see ZipFile\n * @NotThreadSafe\n */\npublic class ZipArchiveInputStream extends ArchiveInputStream {\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n    private final ZipEncoding zipEncoding;\n    private final boolean useUnicodeExtraFields;\n    private final InputStream in;\n    private final Inflater inf = new Inflater(true);\n    private final CRC32 crc = new CRC32();\n    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n    private ZipArchiveEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n    private int bytesReadFromStream = 0;\n    private int lengthOfLastRead = 0;\n    private boolean hasDataDescriptor = false;\n    private static final int LFH_LEN = 30;\n    public void close() throws IOException;\n    public ArchiveEntry getNextEntry() throws IOException;\n    public int read(byte[] buffer, int start, int length) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n\t    URISyntaxException {\n\t\n\tURL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n\tFileInputStream archive = new FileInputStream(\n\t\tnew File(new URI(zip.toString())));\n\tZipArchiveInputStream zi = null;\n\ttry {\n\t    zi = new ZipArchiveInputStream(archive,null,false);\n\t    \n\t    // these are the entries that are supposed to be processed\n\t    // correctly without any problems\n\t    for (int i = 0; i < ENTRIES.length; i++) {\n\t\tassertEquals(ENTRIES[i], zi.getNextEntry().getName());\n\t    }\n\t    \n\t    // this is the last entry that is truncated\n\t    ArchiveEntry lastEntry = zi.getNextEntry();\n\t    assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n\t    byte [] buffer = new byte [4096];\n\t    \n\t    // before the fix, we'd get 0 bytes on this read and all\n\t    // subsequent reads thus a client application might enter\n\t    // an infinite loop after the fix, we should get an\n\t    // exception\n\t    try {\n                int read = 0;\n\t\twhile ((read = zi.read(buffer)) > 0) { }\n\t\tfail(\"shouldn't be able to read from truncated entry\");\n\t    } catch (IOException e) {\n                assertEquals(\"Truncated ZIP file\", e.getMessage());\n\t    }\n\t    \n\t    // and now we get another entry, which should also yield\n\t    // an exception\n\t    try {\n\t\tzi.getNextEntry();\n\t\tfail(\"shouldn't be able to read another entry from truncated\" + \" file\");\n\t    } catch (IOException e) {\n\t\t// this is to be expected\n\t    }\n\t} finally {\n\t    if (zi != null) {\n\t\tzi.close();\n\t    }\n\t}\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry, Cloneable {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n    private String name = null;\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object obj);\n    /**\n     * Overwrite clone.\n     * @return a cloned copy of this ZipArchiveEntry\n     */\n    public Object clone();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Extension that adds better handling of extra fields and provides\n * access to the internal and external file attributes.\n *\n * @NotThreadSafe\n */\npublic class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry, Cloneable {\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n    private int method = -1;\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n    private String name = null;\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object obj);\n    /**\n     * Overwrite clone.\n     * @return a cloned copy of this ZipArchiveEntry\n     */\n    public Object clone();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNotEquals() {\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n        assertFalse(entry1.equals(entry2));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * Parsing stops when a NUL is found, or a trailing space,\n     * or the buffer length is reached.\n     *\n     * Behaviour with non-octal input is currently undefined.\n     * \n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal string.\n     */\n    public static long parseOctal(byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * Parsing stops when a NUL is found, or a trailing space,\n     * or the buffer length is reached.\n     *\n     * Behaviour with non-octal input is currently undefined.\n     * \n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal string.\n     */\n    public static long parseOctal(byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void fillBuff(byte []buffer, String input) throws Exception{\n        for(int i=0; i<buffer.length;i++){\n            buffer[i]=0;\n        }\n        System.arraycopy(input.getBytes(\"UTF-8\"),0,buffer,0,Math.min(buffer.length,input.length()));        \n    }\n    private void checkRoundTripOctal(final long value) {\n        byte [] buffer = new byte[12];\n        long parseValue;\n        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void checkName(String string) {\n        byte buff[] = new byte[100];\n        int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n        assertEquals(string, TarUtils.parseName(buff, 0, len));\n    }\n    public void testRoundTripNames(){\n        checkName(\"\");\n        checkName(\"The quick brown fox\\n\");\n        checkName(\"\\177\");\n        // checkName(\"\\0\"); // does not work, because NUL is ignored\n        // COMPRESS-114\n        checkName(\"0302-0601-3\u5317\u76d506\u76ec220\u76f3B\u76e0ALALA\u5317\u5317\u5317\u5317\u5317CAN\u5317DC\u531704060302\u76e1OE.model\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\npublic class TarUtils {\n    private static final int BYTE_MASK = 255;\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length);\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length);\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length);\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void checkRoundTripOctal(final long value) {\n        byte [] buffer = new byte[12];\n        long parseValue;\n        TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n        parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n        assertEquals(value,parseValue);\n    }\n    private void checkName(String string) {\n        byte buff[] = new byte[100];\n        int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n        assertEquals(string, TarUtils.parseName(buff, 0, len));\n    }\n    public void testParseOctalInvalid() throws Exception{\n        byte [] buffer;\n        buffer=new byte[0]; // empty byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{0}; // 1-byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{0,0,' '}; // not all NULs\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer=new byte[]{' ',0,0,0}; // not all NULs\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - not all NULs\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - no trailer\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded space\");\n        } catch (IllegalArgumentException expected) {\n        }\n        buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - embedded NUL\");\n        } catch (IllegalArgumentException expected) {\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     * @throws IOException on error\n     */\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n * @NotThreadSafe\n */\npublic class TarArchiveOutputStream extends ArchiveOutputStream {\n    public static final int LONGFILE_ERROR = 0;\n    public static final int LONGFILE_TRUNCATE = 1;\n    public static final int LONGFILE_GNU = 2;\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    private int       longFileMode = LONGFILE_ERROR;\n    private boolean closed = false;\n    private boolean haveUnclosedEntry = false;\n    private boolean finished = false;\n    private final OutputStream out;\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode);\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException;\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException;\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException;\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     * @throws IOException on error\n     */\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCount() throws Exception {\n        File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n        f.deleteOnExit();\n        FileOutputStream fos = new FileOutputStream(f);\n\n        ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n            .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n\n        File file1 = getFile(\"test1.xml\");\n        TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n        tarOut.putArchiveEntry(sEntry);\n\n        FileInputStream in = new FileInputStream(file1);\n        byte[] buf = new byte[8192];\n\n        int read = 0;\n        while ((read = in.read(buf)) > 0) {\n            tarOut.write(buf, 0, read);\n        }\n\n        in.close();\n        tarOut.closeArchiveEntry();\n        tarOut.close();\n\n        assertEquals(f.length(), tarOut.getBytesWritten());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * ExtendedBufferedReader\n *\n * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n    private int lastChar = UNDEFINED;\n    private int lineCounter = 0;\n    @Override\n    public int read() throws IOException;\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * ExtendedBufferedReader\n *\n * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n    private int lastChar = UNDEFINED;\n    private int lineCounter = 0;\n    @Override\n    public int read() throws IOException;\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testGetLineNumberWithCR() throws Exception {\n        CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n        \n        assertEquals(0, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(1, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(2, parser.getLineNumber());\n        assertNotNull(parser.getRecord());\n        assertEquals(2, parser.getLineNumber());\n        assertNull(parser.getRecord());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException;\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException;\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException;\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException;\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException;\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException;\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static String printable(final String s) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            final char ch = s.charAt(i);\n            if (ch <= ' ' || ch >= 128) {\n                sb.append(\"(\").append((int) ch).append(\")\");\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n    private void doOneRandom(final CSVFormat format) throws Exception {\n        final Random r = new Random();\n\n        final int nLines = r.nextInt(4) + 1;\n        final int nCol = r.nextInt(3) + 1;\n        // nLines=1;nCol=2;\n        final String[][] lines = new String[nLines][];\n        for (int i = 0; i < nLines; i++) {\n            final String[] line = new String[nCol];\n            lines[i] = line;\n            for (int j = 0; j < nCol; j++) {\n                line[j] = randStr();\n            }\n        }\n\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n\n        for (int i = 0; i < nLines; i++) {\n            // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n            printer.printRecord((Object[])lines[i]);\n        }\n\n        printer.flush();\n        printer.close();\n        final String result = sw.toString();\n        // System.out.println(\"### :\" + printable(result));\n\n        final CSVParser parser = CSVParser.parse(result, format);\n        final List<CSVRecord> parseResult = parser.getRecords();\n\n        Utils.compare(\"Printer output :\" + printable(result), lines, parseResult);\n        parser.close();\n    }\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    }\n    private String randStr() {\n        final Random r = new Random();\n\n        final int sz = r.nextInt(20);\n        // sz = r.nextInt(3);\n        final char[] buf = new char[sz];\n        for (int i = 0; i < sz; i++) {\n            // stick in special chars with greater frequency\n            char ch;\n            final int what = r.nextInt(20);\n            switch (what) {\n                case 0:\n                    ch = '\\r';\n                    break;\n                case 1:\n                    ch = '\\n';\n                    break;\n                case 2:\n                    ch = '\\t';\n                    break;\n                case 3:\n                    ch = '\\f';\n                    break;\n                case 4:\n                    ch = ' ';\n                    break;\n                case 5:\n                    ch = ',';\n                    break;\n                case 6:\n                    ch = '\"';\n                    break;\n                case 7:\n                    ch = '\\'';\n                    break;\n                case 8:\n                    ch = '\\\\';\n                    break;\n                default:\n                    ch = (char) r.nextInt(300);\n                    break;\n                // default: ch = 'a'; break;\n            }\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n    public void testHeader() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n                .withHeader(\"C1\", \"C2\", \"C3\"));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n        printer.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException;\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber();\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator();\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException;\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber();\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator();\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void validateLineNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        assertEquals(0, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(1, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n        parser.close();\n    }\n    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        CSVRecord record;\n        assertEquals(0, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(1, record.getRecordNumber());\n        assertEquals(1, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(2, record.getRecordNumber());\n        assertEquals(2, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(3, record.getRecordNumber());\n        assertEquals(3, parser.getRecordNumber());\n        assertNull(record = parser.nextRecord());\n        assertEquals(3, parser.getRecordNumber());\n        parser.close();\n    }\n    public void testHeaderMissingWithNull() throws Exception {\n        final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c);\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c);\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void validateLineNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        assertEquals(0, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(1, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n        parser.close();\n    }\n    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        CSVRecord record;\n        assertEquals(0, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(1, record.getRecordNumber());\n        assertEquals(1, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(2, record.getRecordNumber());\n        assertEquals(2, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(3, record.getRecordNumber());\n        assertEquals(3, parser.getRecordNumber());\n        assertNull(record = parser.nextRecord());\n        assertEquals(3, parser.getRecordNumber());\n        parser.close();\n    }\n    public void testExcelHeaderCountLessThanData() throws Exception {\n        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\n        try {\n            for (CSVRecord record : parser.getRecords()) {\n                Assert.assertEquals(\"a\", record.get(\"A\"));\n                Assert.assertEquals(\"b\", record.get(\"B\"));\n                Assert.assertEquals(\"c\", record.get(\"C\"));\n            }\n        } finally {\n            parser.close();\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    private void print(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException;\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException;\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException;\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException;\n}\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output\n     * @return a printer to an output\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString);\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator();\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c);\n    @Override\n    public String toString();\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy);\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Sets the header comments of the format. The comments will be printed first, before the headers. This setting is\n     * ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    private void print(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException;\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException;\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException;\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException;\n}\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output\n     * @return a printer to an output\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString);\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator();\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c);\n    @Override\n    public String toString();\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy);\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Sets the header comments of the format. The comments will be printed first, before the headers. This setting is\n     * ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static String printable(final String s) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            final char ch = s.charAt(i);\n            if (ch <= ' ' || ch >= 128) {\n                sb.append(\"(\").append((int) ch).append(\")\");\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n    private void doOneRandom(final CSVFormat format) throws Exception {\n        final Random r = new Random();\n\n        final int nLines = r.nextInt(4) + 1;\n        final int nCol = r.nextInt(3) + 1;\n        // nLines=1;nCol=2;\n        final String[][] lines = generateLines(nLines, nCol);\n\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, format);\n\n        for (int i = 0; i < nLines; i++) {\n            // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n            printer.printRecord((Object[]) lines[i]);\n        }\n\n        printer.flush();\n        printer.close();\n        final String result = sw.toString();\n        // System.out.println(\"### :\" + printable(result));\n\n        final CSVParser parser = CSVParser.parse(result, format);\n        final List<CSVRecord> parseResult = parser.getRecords();\n\n        String[][] expected = lines.clone();\n        for (int i = 0; i < expected.length; i++) {\n            expected[i] = expectNulls(expected[i], format);\n        }\n        Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n        parser.close();\n    }\n    private String[][] generateLines(final int nLines, final int nCol) {\n        final String[][] lines = new String[nLines][];\n        for (int i = 0; i < nLines; i++) {\n            final String[] line = new String[nCol];\n            lines[i] = line;\n            for (int j = 0; j < nCol; j++) {\n                line[j] = randStr();\n            }\n        }\n        return lines;\n    }\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    }\n    private String randStr() {\n        final Random r = new Random();\n\n        final int sz = r.nextInt(20);\n        // sz = r.nextInt(3);\n        final char[] buf = new char[sz];\n        for (int i = 0; i < sz; i++) {\n            // stick in special chars with greater frequency\n            char ch;\n            final int what = r.nextInt(20);\n            switch (what) {\n            case 0:\n                ch = '\\r';\n                break;\n            case 1:\n                ch = '\\n';\n                break;\n            case 2:\n                ch = '\\t';\n                break;\n            case 3:\n                ch = '\\f';\n                break;\n            case 4:\n                ch = ' ';\n                break;\n            case 5:\n                ch = ',';\n                break;\n            case 6:\n                ch = '\"';\n                break;\n            case 7:\n                ch = '\\'';\n                break;\n            case 8:\n                ch = '\\\\';\n                break;\n            default:\n                ch = (char) r.nextInt(300);\n                break;\n            // default: ch = 'a'; break;\n            }\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n        Class.forName(\"org.h2.Driver\");\n        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n    }\n    private void setUpTable(final Connection connection) throws SQLException {\n        final Statement statement = connection.createStatement();\n        try {\n            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n            statement.execute(\"insert into TEST values(1, 'r1')\");\n            statement.execute(\"insert into TEST values(2, 'r2')\");\n        } finally {\n            statement.close();\n        }\n    }\n    private <T> T[] expectNulls(T[] original, CSVFormat csvFormat) {\n        T[] fixed = original.clone();\n        for (int i = 0; i < fixed.length; i++) {\n            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n                fixed[i] = null;\n            }\n        }\n        return fixed;\n    }\n    private String[] toFirstRecordValues(final String expected, CSVFormat format) throws IOException {\n        return CSVParser.parse(expected, format).getRecords().get(0).values();\n    }\n    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n            throws IOException {\n        CSVFormat format = baseFormat;\n        // Use withHeaderComments first to test CSV-145\n        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n        format = format.withCommentMarker('#');\n        format = format.withHeader(\"Col1\", \"Col2\");\n        final CSVPrinter csvPrinter = format.print(sw);\n        csvPrinter.printRecord(\"A\", \"B\");\n        csvPrinter.printRecord(\"C\", \"D\");\n        csvPrinter.close();\n        return csvPrinter;\n    }\n    public void testMySqlNullOutput() throws IOException {\n        Object[] s = new String[] { \"NULL\", null };\n        CSVFormat format = CSVFormat.MYSQL.withQuote('\"').withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n        StringWriter writer = new StringWriter();\n        CSVPrinter printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n        assertEquals(expected, writer.toString());\n        String[] record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(new Object[2], record0);\n\n        s = new String[] { \"\\\\N\", null };\n        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\\\\\\\N\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\\\\N\", \"A\" };\n        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\\\\\\\N\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\\n\", \"A\" };\n        format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\\\n\\tA\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\", null };\n        format = CSVFormat.MYSQL.withNullString(\"NULL\");\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\tNULL\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\", null };\n        format = CSVFormat.MYSQL;\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\t\\\\N\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n        format = CSVFormat.MYSQL;\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"NULL\", \"\\\\\\r\" };\n        format = CSVFormat.MYSQL;\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n\n        s = new String[] { \"\\\\\\r\" };\n        format = CSVFormat.MYSQL;\n        writer = new StringWriter();\n        printer = new CSVPrinter(writer, format);\n        printer.printRecord(s);\n        printer.close();\n        expected = \"\\\\\\\\\\\\r\\n\";\n        assertEquals(expected, writer.toString());\n        record0 = toFirstRecordValues(expected, format);\n        assertArrayEquals(expectNulls(s, format), record0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum);\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape);\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape);\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset \n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, Charset charset) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum);\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape);\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape);\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset \n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, Charset charset) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static String printable(final String s) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            final char ch = s.charAt(i);\n            if (ch <= ' ' || ch >= 128) {\n                sb.append(\"(\").append((int) ch).append(\")\");\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n    private void doOneRandom(final CSVFormat format) throws Exception {\n        final Random r = new Random();\n\n        final int nLines = r.nextInt(4) + 1;\n        final int nCol = r.nextInt(3) + 1;\n        // nLines=1;nCol=2;\n        final String[][] lines = generateLines(nLines, nCol);\n\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n\n            for (int i = 0; i < nLines; i++) {\n                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n                printer.printRecord((Object[]) lines[i]);\n            }\n\n            printer.flush();\n        }\n        final String result = sw.toString();\n        // System.out.println(\"### :\" + printable(result));\n\n        try (final CSVParser parser = CSVParser.parse(result, format)) {\n            final List<CSVRecord> parseResult = parser.getRecords();\n\n            final String[][] expected = lines.clone();\n            for (int i = 0; i < expected.length; i++) {\n                expected[i] = expectNulls(expected[i], format);\n            }\n            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n        }\n    }\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    }\n    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n        final T[] fixed = original.clone();\n        for (int i = 0; i < fixed.length; i++) {\n            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\n                fixed[i] = null;\n            }\n        }\n        return fixed;\n    }\n    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n        Class.forName(\"org.h2.Driver\");\n        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n    }\n    private String[][] generateLines(final int nLines, final int nCol) {\n        final String[][] lines = new String[nLines][];\n        for (int i = 0; i < nLines; i++) {\n            final String[] line = new String[nCol];\n            lines[i] = line;\n            for (int j = 0; j < nCol; j++) {\n                line[j] = randStr();\n            }\n        }\n        return lines;\n    }\n    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n            throws IOException {\n        CSVFormat format = baseFormat;\n        // Use withHeaderComments first to test CSV-145\n        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n        format = format.withCommentMarker('#');\n        format = format.withHeader(\"Col1\", \"Col2\");\n        final CSVPrinter csvPrinter = format.print(sw);\n        csvPrinter.printRecord(\"A\", \"B\");\n        csvPrinter.printRecord(\"C\", \"D\");\n        csvPrinter.close();\n        return csvPrinter;\n    }\n    private String randStr() {\n        final Random r = new Random();\n\n        final int sz = r.nextInt(20);\n        // sz = r.nextInt(3);\n        final char[] buf = new char[sz];\n        for (int i = 0; i < sz; i++) {\n            // stick in special chars with greater frequency\n            char ch;\n            final int what = r.nextInt(20);\n            switch (what) {\n            case 0:\n                ch = '\\r';\n                break;\n            case 1:\n                ch = '\\n';\n                break;\n            case 2:\n                ch = '\\t';\n                break;\n            case 3:\n                ch = '\\f';\n                break;\n            case 4:\n                ch = ' ';\n                break;\n            case 5:\n                ch = ',';\n                break;\n            case 6:\n                ch = DQUOTE_CHAR;\n                break;\n            case 7:\n                ch = '\\'';\n                break;\n            case 8:\n                ch = BACKSLASH_CH;\n                break;\n            default:\n                ch = (char) r.nextInt(300);\n                break;\n            // default: ch = 'a'; break;\n            }\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n    private void setUpTable(final Connection connection) throws SQLException {\n        try (final Statement statement = connection.createStatement()) {\n            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n            statement.execute(\"insert into TEST values(1, 'r1')\");\n            statement.execute(\"insert into TEST values(2, 'r2')\");\n        }\n    }\n    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n        return CSVParser.parse(expected, format).getRecords().get(0).values();\n    }\n    public void testEscapeNull1() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\");\n        }\n        assertEquals(\"\\\\\", sw.toString()); }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException;\n    @Override\n    public String toString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum);\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException;\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException;\n    @Override\n    public String toString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum);\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException;\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker);\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker);\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException;\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString();\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException;\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException;\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static String printable(final String s) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            final char ch = s.charAt(i);\n            if (ch <= ' ' || ch >= 128) {\n                sb.append(\"(\").append((int) ch).append(\")\");\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n    private void doOneRandom(final CSVFormat format) throws Exception {\n        final Random r = new Random();\n\n        final int nLines = r.nextInt(4) + 1;\n        final int nCol = r.nextInt(3) + 1;\n        // nLines=1;nCol=2;\n        final String[][] lines = generateLines(nLines, nCol);\n\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n\n            for (int i = 0; i < nLines; i++) {\n                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n                printer.printRecord((Object[]) lines[i]);\n            }\n\n            printer.flush();\n        }\n        final String result = sw.toString();\n        // System.out.println(\"### :\" + printable(result));\n\n        try (final CSVParser parser = CSVParser.parse(result, format)) {\n            final List<CSVRecord> parseResult = parser.getRecords();\n\n            final String[][] expected = lines.clone();\n            for (int i = 0; i < expected.length; i++) {\n                expected[i] = expectNulls(expected[i], format);\n            }\n            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n        }\n    }\n    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n        for (int i = 0; i < iter; i++) {\n            doOneRandom(format);\n        }\n    }\n    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n        final T[] fixed = original.clone();\n        for (int i = 0; i < fixed.length; i++) {\n            if (Objects.equals(csvFormat.getNullString(), fixed[i])) {\n                fixed[i] = null;\n            }\n        }\n        return fixed;\n    }\n    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n        Class.forName(\"org.h2.Driver\");\n        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n    }\n    private String[][] generateLines(final int nLines, final int nCol) {\n        final String[][] lines = new String[nLines][];\n        for (int i = 0; i < nLines; i++) {\n            final String[] line = new String[nCol];\n            lines[i] = line;\n            for (int j = 0; j < nCol; j++) {\n                line[j] = randStr();\n            }\n        }\n        return lines;\n    }\n    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n            throws IOException {\n        CSVFormat format = baseFormat;\n        // Use withHeaderComments first to test CSV-145\n        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n        format = format.withCommentMarker('#');\n        format = format.withHeader(\"Col1\", \"Col2\");\n        final CSVPrinter csvPrinter = format.print(sw);\n        csvPrinter.printRecord(\"A\", \"B\");\n        csvPrinter.printRecord(\"C\", \"D\");\n        csvPrinter.close();\n        return csvPrinter;\n    }\n    private String randStr() {\n        final Random r = new Random();\n\n        final int sz = r.nextInt(20);\n        // sz = r.nextInt(3);\n        final char[] buf = new char[sz];\n        for (int i = 0; i < sz; i++) {\n            // stick in special chars with greater frequency\n            char ch;\n            final int what = r.nextInt(20);\n            switch (what) {\n            case 0:\n                ch = '\\r';\n                break;\n            case 1:\n                ch = '\\n';\n                break;\n            case 2:\n                ch = '\\t';\n                break;\n            case 3:\n                ch = '\\f';\n                break;\n            case 4:\n                ch = ' ';\n                break;\n            case 5:\n                ch = ',';\n                break;\n            case 6:\n                ch = DQUOTE_CHAR;\n                break;\n            case 7:\n                ch = '\\'';\n                break;\n            case 8:\n                ch = BACKSLASH_CH;\n                break;\n            default:\n                ch = (char) r.nextInt(300);\n                break;\n            // default: ch = 'a'; break;\n            }\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n    private void setUpTable(final Connection connection) throws SQLException {\n        try (final Statement statement = connection.createStatement()) {\n            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n            statement.execute(\"insert into TEST values(1, 'r1')\");\n            statement.execute(\"insert into TEST values(2, 'r2')\");\n        }\n    }\n    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n        return CSVParser.parse(expected, format).getRecords().get(0).values();\n    }\n    public void testDontQuoteEuroFirstChar() throws IOException {\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n            printer.printRecord(EURO_CH, \"Deux\");\n            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed();\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException;\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber();\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator();\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException;\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed();\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException;\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber();\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator();\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private BOMInputStream createBOMInputStream(final String resource) throws IOException {\n        final URL url = ClassLoader.getSystemClassLoader().getResource(resource);\n        return new BOMInputStream(url.openStream());\n    }\n    private void validateLineNumbers(final String lineSeparator) throws IOException {\n        try (final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n            assertEquals(0, parser.getCurrentLineNumber());\n            assertNotNull(parser.nextRecord());\n            assertEquals(1, parser.getCurrentLineNumber());\n            assertNotNull(parser.nextRecord());\n            assertEquals(2, parser.getCurrentLineNumber());\n            assertNotNull(parser.nextRecord());\n            // Still 2 because the last line is does not have EOL chars\n            assertEquals(2, parser.getCurrentLineNumber());\n            assertNull(parser.nextRecord());\n            // Still 2 because the last line is does not have EOL chars\n            assertEquals(2, parser.getCurrentLineNumber());\n        }\n    }\n    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n        try (final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n            CSVRecord record;\n            assertEquals(0, parser.getRecordNumber());\n            assertNotNull(record = parser.nextRecord());\n            assertEquals(1, record.getRecordNumber());\n            assertEquals(1, parser.getRecordNumber());\n            assertNotNull(record = parser.nextRecord());\n            assertEquals(2, record.getRecordNumber());\n            assertEquals(2, parser.getRecordNumber());\n            assertNotNull(record = parser.nextRecord());\n            assertEquals(3, record.getRecordNumber());\n            assertEquals(3, parser.getRecordNumber());\n            assertNull(record = parser.nextRecord());\n            assertEquals(3, parser.getRecordNumber());\n        }\n    }\n    private void validateRecordPosition(final String lineSeparator) throws IOException {\n        final String nl = lineSeparator; // used as linebreak in values for better distinction\n\n        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n                // to see if recordPosition correctly points to the enclosing quote\n                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n                // unicode test... not very relevant while operating on strings instead of bytes, but for\n                // completeness...\n                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\n\n        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\n        CSVParser parser = CSVParser.parse(code, format);\n\n        CSVRecord record;\n        assertEquals(0, parser.getRecordNumber());\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(1, record.getRecordNumber());\n        assertEquals(code.indexOf('a'), record.getCharacterPosition());\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(2, record.getRecordNumber());\n        assertEquals(code.indexOf('1'), record.getCharacterPosition());\n\n        assertNotNull(record = parser.nextRecord());\n        final long positionRecord3 = record.getCharacterPosition();\n        assertEquals(3, record.getRecordNumber());\n        assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n        assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n        assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n        assertEquals(\"CC\", record.get(2));\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(4, record.getRecordNumber());\n        assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(5, record.getRecordNumber());\n        assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\n\n        parser.close();\n\n        // now try to read starting at record 3\n        parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3);\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(3, record.getRecordNumber());\n        assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n        assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n        assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n        assertEquals(\"CC\", record.get(2));\n\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(4, record.getRecordNumber());\n        assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n        assertEquals(\"\\u00c4\", record.get(0));\n\n        parser.close();\n    }\n    public void testIteratorSequenceBreaking() throws IOException {\n        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n\n        // Iterator hasNext() shouldn't break sequence\n        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        int recordNumber = 0;\n        Iterator<CSVRecord> iter = parser.iterator();\n        recordNumber = 0;\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        iter.hasNext();\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n\n        // Consecutive enhanced for loops shouldn't break sequence\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n\n        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        parser.iterator().hasNext();\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic class CSVRecord implements Serializable, Iterable<String> {\n    private static final long serialVersionUID = 1L;\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private final String[] values;\n    private final Map<String, Integer> mapping;\n    private final String comment;\n    private final long recordNumber;\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic class CSVRecord implements Serializable, Iterable<String> {\n    private static final long serialVersionUID = 1L;\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private final String[] values;\n    private final Map<String, Integer> mapping;\n    private final String comment;\n    private final long recordNumber;\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testGetStringInconsistentRecord() {\n        header.put(\"fourth\", Integer.valueOf(4));\n        recordWithHeader.get(\"fourth\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstract lexer class; contains common utility routines shared by lexers\n *\n * @version $Id$\n */\nabstract class Lexer {\n    private static final char DISABLED = '\\ufffe';\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commmentStart;\n    abstract Token nextToken(Token reusableToken) throws IOException;\n\n    /**\n     * @return true if the given char is a whitespace character\n     */\n    boolean isWhitespace(final int c);\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstract lexer class; contains common utility routines shared by lexers\n *\n * @version $Id$\n */\nabstract class Lexer {\n    private static final char DISABLED = '\\ufffe';\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commmentStart;\n    abstract Token nextToken(Token reusableToken) throws IOException;\n\n    /**\n     * @return true if the given char is a whitespace character\n     */\n    boolean isWhitespace(final int c);\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private Lexer getLexer(final String input, final CSVFormat format) {\n        return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n    }\n    public void testEscapedMySqlNullValue() throws Exception {\n        // MySQL uses \\N to symbolize null values. We have to restore this\n        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h4>Creating instances</h4>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * <p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * </p>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n * \n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h4>Parsing record wise</h4>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h4>Parsing into memory</h4>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <p>\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n * </p>\n *\n * <h4>Notes</h4>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(String string, final CSVFormat format) throws IOException;\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber();\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap();\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(File file, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h4>Creating instances</h4>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * <p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * </p>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n * \n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h4>Parsing record wise</h4>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h4>Parsing into memory</h4>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <p>\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n * </p>\n *\n * <h4>Notes</h4>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber();\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(String string, final CSVFormat format) throws IOException;\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber();\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException;\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap();\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(File file, final CSVFormat format) throws IOException;\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void validateRecordNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        CSVRecord record;\n        assertEquals(0, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(1, record.getRecordNumber());\n        assertEquals(1, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(2, record.getRecordNumber());\n        assertEquals(2, parser.getRecordNumber());\n        assertNotNull(record = parser.nextRecord());\n        assertEquals(3, record.getRecordNumber());\n        assertEquals(3, parser.getRecordNumber());\n        assertNull(record = parser.nextRecord());\n        assertEquals(3, parser.getRecordNumber());\n    }\n    private void validateLineNumbers(final String lineSeparator) throws IOException {\n        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n        assertEquals(0, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(1, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNotNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n        assertNull(parser.nextRecord());\n        // Still 2 because the last line is does not have EOL chars\n        assertEquals(2, parser.getCurrentLineNumber());\n    }\n    public void testNoHeaderMap() throws Exception {\n        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n        Assert.assertNull(parser.getHeaderMap());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    /**\n     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n     * beginning of each new line in the comment.\n     * <p/>\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n    private final Appendable out;\n    private final CSVFormat format;\n    private boolean newRecord = true;\n    /**\n     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n     * beginning of each new line in the comment.\n     * <p/>\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static void assertNotEquals(final Object right, final Object left) {\n        assertFalse(right.equals(left));\n        assertFalse(left.equals(right));\n    }\n    private static CSVFormat copy(final CSVFormat format) {\n        return format.withDelimiter(format.getDelimiter());\n    }\n    public void testNullRecordSeparatorCsv106() {\n        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\", \"H2\");\n        final String formatStr = format.format(\"A\", \"B\");\n        assertNotNull(formatStr);\n        assertFalse(formatStr.endsWith(\"null\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private static final long serialVersionUID = 1L;\n    private final String comment;\n    private final Map<String, Integer> mapping;\n    private final long recordNumber;\n    private final String[] values;\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e);\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator();\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap();\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private static final long serialVersionUID = 1L;\n    private final String comment;\n    private final Map<String, Integer> mapping;\n    private final long recordNumber;\n    private final String[] values;\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e);\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator();\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap();\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void validateMap(final Map<String, String> map, final boolean allowsNulls) {\n        assertTrue(map.containsKey(\"first\"));\n        assertTrue(map.containsKey(\"second\"));\n        assertTrue(map.containsKey(\"third\"));\n        assertFalse(map.containsKey(\"fourth\"));\n        if (allowsNulls) {\n            assertFalse(map.containsKey(null));\n        }\n        assertEquals(\"A\", map.get(\"first\"));\n        assertEquals(\"B\", map.get(\"second\"));\n        assertEquals(\"C\", map.get(\"third\"));\n        assertEquals(null, map.get(\"fourth\"));\n    }\n    public void testToMapWithShortRecord() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n       final CSVRecord shortRec = parser.iterator().next();\n       shortRec.toMap();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVRecord} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final char delimiter;\n    private final Character quoteChar; // null if quoting is disabled\n    private final Quote quotePolicy;\n    private final Character commentStart; // null if commenting is disabled\n    private final Character escape; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter();\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter);\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    public static CSVFormat newFormat(final char delimiter);\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     */\n    void validate() throws IllegalStateException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVRecord} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private final char delimiter;\n    private final Character quoteChar; // null if quoting is disabled\n    private final Quote quotePolicy;\n    private final Character commentStart; // null if commenting is disabled\n    private final Character escape; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header);\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter();\n    @Override\n    public boolean equals(final Object obj);\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter);\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    public static CSVFormat newFormat(final char delimiter);\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     */\n    void validate() throws IllegalStateException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private static void assertNotEquals(final Object right, final Object left) {\n        assertFalse(right.equals(left));\n        assertFalse(left.equals(right));\n    }\n    private static CSVFormat copy(final CSVFormat format) {\n        return format.withDelimiter(format.getDelimiter());\n    }\n    public void testDuplicateHeaderElements() {\n        CSVFormat.DEFAULT.withHeader(\"A\", \"A\").validate();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private static final long serialVersionUID = 1L;\n    private final String comment;\n    private final Map<String, Integer> mapping;\n    private final long recordNumber;\n    private final String[] values;\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name);\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator();\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap();\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n    private static final long serialVersionUID = 1L;\n    private final String comment;\n    private final Map<String, Integer> mapping;\n    private final long recordNumber;\n    private final String[] values;\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name);\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator();\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap();\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e);\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void validateMap(final Map<String, String> map, final boolean allowsNulls) {\n        assertTrue(map.containsKey(\"first\"));\n        assertTrue(map.containsKey(\"second\"));\n        assertTrue(map.containsKey(\"third\"));\n        assertFalse(map.containsKey(\"fourth\"));\n        if (allowsNulls) {\n            assertFalse(map.containsKey(null));\n        }\n        assertEquals(\"A\", map.get(\"first\"));\n        assertEquals(\"B\", map.get(\"second\"));\n        assertEquals(\"C\", map.get(\"third\"));\n        assertEquals(null, map.get(\"fourth\"));\n    }\n    public void testToMapWithNoHeader() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n       final CSVRecord shortRec = parser.iterator().next();\n       Map<String, String> map = shortRec.toMap();\n       assertNotNull(\"Map is not null.\", map);\n       assertTrue(\"Map is empty.\", map.isEmpty());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException;\n    public void append(String str, int offset, int len);\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override\n    public String toString();\n    public void append(char c);\n    public void append(char[] c, int start, int len);\n}\npublic final class NumberInput\n{\n    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n    public static double parseDouble(String numStr) throws NumberFormatException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException;\n    public void append(String str, int offset, int len);\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override\n    public String toString();\n    public void append(char c);\n    public void append(char[] c, int start, int len);\n}\npublic final class NumberInput\n{\n    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n    public static double parseDouble(String numStr) throws NumberFormatException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.test.BaseTest\n{\n    private void _testLargeUnquoted(boolean useStream) throws Exception\n    {\n        StringBuilder sb = new StringBuilder(5000);\n        sb.append(\"[\\n\");\n        //final int REPS = 2000;\n        final int REPS = 1050;\n        for (int i = 0; i < REPS; ++i) {\n            if (i > 0) {\n                sb.append(',');\n                if ((i & 7) == 0) {\n                    sb.append('\\n');\n                }\n            }\n            sb.append(\"{\");\n            sb.append(\"abc\").append(i&127).append(':');\n            sb.append((i & 1) != 0);\n            sb.append(\"}\\n\");\n        }\n        sb.append(\"]\");\n        String JSON = sb.toString();\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        JsonParser jp = useStream ?\n            createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON)\n            ;\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        for (int i = 0; i < REPS; ++i) {\n            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            assertEquals(\"abc\"+(i&127), jp.getCurrentName());\n            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, jp.nextToken());\n            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        }\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n    }\n    private void _testSimpleUnquoted(boolean useStream) throws Exception\n    {\n        final String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        JsonParser jp = useStream ?\n            createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON)\n            ;\n\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"a\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"_foo\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"$\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"money!\", jp.getText());\n\n        // and then regular quoted one should still work too:\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\" \", jp.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n\n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        jp.close();\n    }\n    private void _testSingleQuotesDefault(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        // First, let's see that by default they are not allowed\n        String JSON = \"[ 'text' ]\";\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Expected exception\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"Unexpected character ('''\");\n        } finally {\n            jp.close();\n        }\n\n        JSON = \"{ 'a':1 }\";\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Expected exception\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"Unexpected character ('''\");\n        } finally {\n            jp.close();\n        }\n    }\n    private void _testSingleQuotesEnabled(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n        String JSON = \"{ 'a' : 1, \\\"foobar\\\": 'b', '_abcde1234':'d', '\\\"' : '\\\"\\\"', '':'' }\";\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"a\", jp.getText());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(\"1\", jp.getText());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"foobar\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"b\", jp.getText());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"_abcde1234\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"d\", jp.getText());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"\\\"\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        //assertEquals(\"\\\"\\\"\", jp.getText());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"\", jp.getText());\n\n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        jp.close();\n    }\n    private void _testSingleQuotesEscaped(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n        String JSON = \"[ '16\\\\'' ]\";\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"16'\", jp.getText());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n    }\n    private void _testNonStandardNameChars(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        String JSON = \"{ @type : \\\"mytype\\\", #color : 123, *error* : true, \"\n            +\" hyphen-ated : \\\"yes\\\", me+my : null\"\n            +\"}\";\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"@type\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"mytype\", jp.getText());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"#color\", jp.getText());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(123, jp.getIntValue());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"*error*\", jp.getText());\n        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"hyphen-ated\", jp.getText());\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"yes\", jp.getText());\n\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"me+my\", jp.getText());\n        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n    \n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        jp.close();\n    }\n    private void _testNonStandarBackslashQuoting(boolean useStream) throws Exception\n    {\n        // first: verify that we get an exception\n        JsonFactory f = new JsonFactory();\n        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER));\n        final String JSON = quote(\"\\\\'\");\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n                : createParserUsingReader(f, JSON);\n        try {      \n            jp.nextToken();\n            jp.getText();\n            fail(\"Should have thrown an exception for doc <\"+JSON+\">\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"unrecognized character escape\");\n        } finally {\n            jp.close();\n        }\n        // and then verify it's ok...\n        f.configure(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true);\n        assertTrue(f.isEnabled(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER));\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n                : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n        assertEquals(\"'\", jp.getText());\n        jp.close();\n    }\n    private void _testLeadingZeroes(boolean useStream, boolean appendSpace) throws Exception\n    {\n        // first: verify that we get an exception\n        JsonFactory f = new JsonFactory();\n        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS));\n        String JSON = \"00003\";\n        if (appendSpace) {\n            JSON += \" \";\n        }\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n                : createParserUsingReader(f, JSON);\n        try {      \n            jp.nextToken();\n            jp.getText();\n            fail(\"Should have thrown an exception for doc <\"+JSON+\">\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"invalid numeric value\");\n        } finally {\n            jp.close();\n        }\n        \n        // and then verify it's ok when enabled\n        f.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n        assertTrue(f.isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS));\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n                : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(3, jp.getIntValue());\n        assertEquals(\"3\", jp.getText());\n        jp.close();\n    \n        // Plus, also: verify that leading zero magnitude is ok:\n        JSON = \"0\"+Integer.MAX_VALUE;\n        if (appendSpace) {\n            JSON += \" \";\n        }\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(String.valueOf(Integer.MAX_VALUE), jp.getText());\n        assertEquals(Integer.MAX_VALUE, jp.getIntValue());\n        Number nr = jp.getNumberValue();\n        assertSame(Integer.class, nr.getClass());\n        jp.close();\n    }\n    private void _testAllowNaN(boolean useStream) throws Exception\n    {\n        final String JSON = \"[ NaN]\";\n        JsonFactory f = new JsonFactory();\n        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n\n        // without enabling, should get an exception\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Expected exception\");\n        } catch (Exception e) {\n            verifyException(e, \"non-standard\");\n        } finally {\n            jp.close();\n        }\n\n        // we can enable it dynamically (impl detail)\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n        \n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        \n        double d = jp.getDoubleValue();\n        assertTrue(Double.isNaN(d));\n        assertEquals(\"NaN\", jp.getText());\n\n        // [Issue#98]\n        try {\n            /*BigDecimal dec =*/ jp.getDecimalValue();\n            fail(\"Should fail when trying to access NaN as BigDecimal\");\n        } catch (NumberFormatException e) {\n            e.printStackTrace();\n            verifyException(e, \"can not be represented as BigDecimal\");\n        }\n       \n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n\n        // finally, should also work with skipping\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n    }\n    private void _testAllowInf(boolean useStream) throws Exception\n    {\n        final String JSON = \"[ -INF, +INF, +Infinity, Infinity, -Infinity ]\";\n        JsonFactory f = new JsonFactory();\n        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n\n        // without enabling, should get an exception\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Expected exception\");\n        } catch (Exception e) {\n            verifyException(e, \"Non-standard token '-INF'\");\n        } finally {\n            jp.close();\n        }\n\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        double d = jp.getDoubleValue();\n        assertEquals(\"-INF\", jp.getText());\n        assertTrue(Double.isInfinite(d));\n        assertTrue(d == Double.NEGATIVE_INFINITY);\n\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        d = jp.getDoubleValue();\n        assertEquals(\"+INF\", jp.getText());\n        assertTrue(Double.isInfinite(d));\n        assertTrue(d == Double.POSITIVE_INFINITY);\n\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        d = jp.getDoubleValue();\n        assertEquals(\"+Infinity\", jp.getText());\n        assertTrue(Double.isInfinite(d));\n        assertTrue(d == Double.POSITIVE_INFINITY);\n\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        d = jp.getDoubleValue();\n        assertEquals(\"Infinity\", jp.getText());\n        assertTrue(Double.isInfinite(d));\n        assertTrue(d == Double.POSITIVE_INFINITY);\n\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        d = jp.getDoubleValue();\n        assertEquals(\"-Infinity\", jp.getText());\n        assertTrue(Double.isInfinite(d));\n        assertTrue(d == Double.NEGATIVE_INFINITY);\n\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n\n        // finally, should also work with skipping\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        \n        jp.close();\n    }\n    private void _testAllowNaN(boolean useStream) throws Exception\n    {\n        final String JSON = \"[ NaN]\";\n        JsonFactory f = new JsonFactory();\n        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n\n        // without enabling, should get an exception\n        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n            : createParserUsingReader(f, JSON);\n\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Expected exception\");\n        } catch (Exception e) {\n            verifyException(e, \"non-standard\");\n        } finally {\n            jp.close();\n        }\n\n        // we can enable it dynamically (impl detail)\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n        \n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        \n        double d = jp.getDoubleValue();\n        assertTrue(Double.isNaN(d));\n        assertEquals(\"NaN\", jp.getText());\n\n        // [Issue#98]\n        try {\n            /*BigDecimal dec =*/ jp.getDecimalValue();\n            fail(\"Should fail when trying to access NaN as BigDecimal\");\n        } catch (NumberFormatException e) {\n            e.printStackTrace();\n            verifyException(e, \"can not be represented as BigDecimal\");\n        }\n       \n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n\n        // finally, should also work with skipping\n        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                : createParserUsingReader(f, JSON);\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        jp.close();\n    }\n    public void testAllowNaN() throws Exception {\n        _testAllowNaN(false);\n        _testAllowNaN(true);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n    final private int _seed;\n    private transient boolean _needRehash;\n    private boolean _hashShared;\n    @Override\n    public String toString();\n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot();\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash);\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed);\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n    final private int _seed;\n    private transient boolean _needRehash;\n    private boolean _hashShared;\n    @Override\n    public String toString();\n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot();\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash);\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed);\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private String createDoc(String[] fieldNames, boolean add)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{ \");\n\n        int len = fieldNames.length;\n        for (int i = 0; i < len; ++i) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append('\"');\n            sb.append(add ? fieldNames[i] : fieldNames[len - (i+1)]);\n            sb.append(\"\\\" : \");\n            sb.append(i);\n        }\n        sb.append(\" }\");\n        return sb.toString();\n    }\n    public void testIssue207() throws Exception\n    {\n        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\n        Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n        byteSymbolCanonicalizerField.setAccessible(true);\n        JsonFactory jsonF = new JsonFactory();\n        byteSymbolCanonicalizerField.set(jsonF, nc);\n\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"{\\n\");\n        stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n        for (int i = 0; i < 60; ++i) {\n            stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n        }\n        stringBuilder.append(\"\\n}\");\n\n        JsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\n        while (p.nextToken() != null) { }\n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n    final private int _seed;\n    private transient boolean _needRehash;\n    private boolean _hashShared;\n    /**********************************************************\n     */\n\n    public int size();\n    @Override\n    public String toString();\n    private void _verifySharing();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n    final private int _seed;\n    private transient boolean _needRehash;\n    private boolean _hashShared;\n    /**********************************************************\n     */\n\n    public int size();\n    @Override\n    public String toString();\n    private void _verifySharing();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _test17Chars(boolean useBytes) throws IOException\n    {\n        String doc = _createDoc17();\n        JsonFactory f = new JsonFactory();\n        \n        JsonParser p = useBytes\n                ? f.createParser(doc.getBytes(\"UTF-8\"))\n                : f.createParser(doc);\n        HashSet<String> syms = new HashSet<String>();\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        for (int i = 0; i < 50; ++i) {\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n            syms.add(p.getCurrentName());\n            assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n        }\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(50, syms.size());\n        p.close();\n    }\n    private String _createDoc17() {\n        StringBuilder sb = new StringBuilder(1000);\n        sb.append(\"{\\n\");\n        for (int i = 1; i <= 50; ++i) {\n            if (i > 1) {\n                sb.append(\",\\n\");\n            }\n            sb.append(\"\\\"lengthmatters\")\n                .append(1000 + i)\n                .append(\"\\\": true\");\n        }\n        sb.append(\"\\n}\");\n        return sb.toString();\n    }\n    public void testSymbolTableExpansionBytes() throws Exception {\n        _testSymbolTableExpansion(true);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException;\n    @Override\n    public String nextFieldName() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation();\n    private final void _isNextTokenNameYes(int i) throws IOException;\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    @Override\n    public String nextFieldName() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation();\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException;\n    @Override\n    public String nextFieldName() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation();\n    private final void _isNextTokenNameYes(int i) throws IOException;\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    @Override\n    public String nextFieldName() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation();\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testNotAllowMultipleMatches() throws Exception\n    {\n    \tString jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'value':4,'b':true}\");\n        JsonParser p0 = JSON_F.createParser(jsonString);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   false, // includePath\n                   false // multipleMatches -false\n                );\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"3\"), result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class that can be used to sequence multiple physical\n * {@link JsonParser}s to create a single logical sequence of\n * tokens, as a single {@link JsonParser}.\n *<p>\n * Fairly simple use of {@link JsonParserDelegate}: only need\n * to override {@link #nextToken} to handle transition\n */\npublic class JsonParserSequence extends JsonParserDelegate\n{\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    /**\n     * Method that will construct a parser (possibly a sequence) that\n     * contains all given sub-parsers.\n     * All parsers given are checked to see if they are sequences: and\n     * if so, they will be \"flattened\", that is, contained parsers are\n     * directly added in a new sequence instead of adding sequences\n     * within sequences. This is done to minimize delegation depth,\n     * ideally only having just a single level of delegation.\n     */\n    public static JsonParserSequence createFlattened(JsonParser first, JsonParser second);\n    /*\n     *******************************************************\n     * Overridden methods, needed: cases where default\n     * delegation does not work\n     *******************************************************\n     */\n    \n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class that can be used to sequence multiple physical\n * {@link JsonParser}s to create a single logical sequence of\n * tokens, as a single {@link JsonParser}.\n *<p>\n * Fairly simple use of {@link JsonParserDelegate}: only need\n * to override {@link #nextToken} to handle transition\n */\npublic class JsonParserSequence extends JsonParserDelegate\n{\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    /**\n     * Method that will construct a parser (possibly a sequence) that\n     * contains all given sub-parsers.\n     * All parsers given are checked to see if they are sequences: and\n     * if so, they will be \"flattened\", that is, contained parsers are\n     * directly added in a new sequence instead of adding sequences\n     * within sequences. This is done to minimize delegation depth,\n     * ideally only having just a single level of delegation.\n     */\n    public static JsonParserSequence createFlattened(JsonParser first, JsonParser second);\n    /*\n     *******************************************************\n     * Overridden methods, needed: cases where default\n     * delegation does not work\n     *******************************************************\n     */\n    \n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    public void testInitialized() throws Exception\n    {\n        JsonParser p1 = JSON_FACTORY.createParser(\"1 2\");\n        JsonParser p2 = JSON_FACTORY.createParser(\"3 false\");\n        // consume '1', move to '2'\n        assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken());\n\n        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);\n        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());\n        assertEquals(2, seq.getIntValue());\n        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());\n        assertEquals(3, seq.getIntValue());\n        seq.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n    private final static byte BYTE_0 = (byte) '0';\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException;\n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException;\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException;\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException;\n    @Override\n    public void close() throws IOException;\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n    private final static byte BYTE_0 = (byte) '0';\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException;\n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException;\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException;\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException;\n    @Override\n    public void close() throws IOException;\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testRawWithSurrogatesString(boolean useCharArray) throws Exception\n    {\n        // boundaries are not exact, may vary, so use this:\n\n        final int OFFSET = 3;\n        final int COUNT = 100;\n\n        for (int i = OFFSET; i < COUNT; ++i) {\n            StringBuilder sb = new StringBuilder(1000);\n            for (int j = 0; j < i; ++j) {\n                sb.append(' ');\n            }\n            sb.append(SURROGATES_307);\n            final String text = sb.toString();\n            ByteArrayOutputStream out = new ByteArrayOutputStream(1000);\n            JsonGenerator g = JSON_F.createGenerator(out);\n            if (useCharArray) {\n                char[] ch = text.toCharArray();\n                g.writeRawValue(ch, OFFSET, ch.length - OFFSET);\n            } else {\n                g.writeRawValue(text, OFFSET, text.length() - OFFSET);\n            }\n            g.close();\n            byte[] b = out.toByteArray();\n            assertNotNull(b);\n        }\n    }\n    private void _testRawWithSurrogatesString(boolean useCharArray) throws Exception\n    {\n        // boundaries are not exact, may vary, so use this:\n\n        final int OFFSET = 3;\n        final int COUNT = 100;\n\n        for (int i = OFFSET; i < COUNT; ++i) {\n            StringBuilder sb = new StringBuilder(1000);\n            for (int j = 0; j < i; ++j) {\n                sb.append(' ');\n            }\n            sb.append(SURROGATES_307);\n            final String text = sb.toString();\n            ByteArrayOutputStream out = new ByteArrayOutputStream(1000);\n            JsonGenerator g = JSON_F.createGenerator(out);\n            if (useCharArray) {\n                char[] ch = text.toCharArray();\n                g.writeRawValue(ch, OFFSET, ch.length - OFFSET);\n            } else {\n                g.writeRawValue(text, OFFSET, text.length() - OFFSET);\n            }\n            g.close();\n            byte[] b = out.toByteArray();\n            assertNotNull(b);\n        }\n    }\n    public void testRawWithSurrogatesString() throws Exception {\n        _testRawWithSurrogatesString(false);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testSimpleInt(int EXP_I, boolean useStream) throws Exception\n    {\n        String DOC = \"[ \"+EXP_I+\" ]\";\n        JsonParser jp = useStream\n                ? FACTORY.createParser(DOC)\n                : FACTORY.createParser(DOC.getBytes(\"UTF-8\"));\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n        assertEquals(\"\"+EXP_I, jp.getText());\n\n        assertEquals(EXP_I, jp.getIntValue());\n        assertEquals((long) EXP_I, jp.getLongValue());\n        assertEquals((double) EXP_I, jp.getDoubleValue());\n        assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n        assertNull(jp.nextToken());\n        jp.close();\n\n        DOC = String.valueOf(EXP_I);\n        jp = useStream\n                ? FACTORY.createParser(DOC)\n                : FACTORY.createParser(DOC.getBytes(\"UTF-8\"));\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(DOC, jp.getText());\n\n        int i = 0;\n        \n        try {\n            i = jp.getIntValue();\n        } catch (Exception e) {\n            throw new Exception(\"Failed to parse input '\"+DOC+\"' (parser of type \"+jp.getClass().getSimpleName()+\")\", e);\n        }\n        \n        assertEquals(EXP_I, i);\n\n        assertEquals((long) EXP_I, jp.getLongValue());\n        assertEquals((double) EXP_I, jp.getDoubleValue());\n        assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue());\n        assertNull(jp.nextToken());\n        jp.close();\n    }\n    private void _testLongNumbers(JsonFactory f, String num, boolean useStream) throws Exception\n    {\n        final String doc = \"[ \"+num+\" ]\";\n        JsonParser jp = useStream\n                ? f.createParser(doc.getBytes(\"UTF-8\"))\n                        : f.createParser(doc);\n        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(num, jp.getText());\n        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n    }\n    private void _testIssue160LongNumbers(JsonFactory f, String doc, boolean useStream) throws Exception\n    {\n        JsonParser jp = useStream\n                ? FACTORY.createParser(doc.getBytes(\"UTF-8\"))\n                        : FACTORY.createParser(doc);\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        BigInteger v = jp.getBigIntegerValue();\n        assertNull(jp.nextToken());\n        assertEquals(doc, v.toString());\n    }\n    private void _testLongerFloat(JsonParser p, String text) throws IOException\n    {\n        assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n        assertEquals(text, p.getText());\n        assertNull(p.nextToken());\n    }\n    private String toJsonArray(double v, int n) {\n        StringBuilder sb = new StringBuilder().append('[').append(v);\n        for (int i = 1; i < n; ++i) {\n            sb.append(',').append(v);\n        }\n        return sb.append(']').toString();\n    }\n    public void testLongerFloatingPoint() throws Exception\n    {\n        StringBuilder input = new StringBuilder();\n        for (int i = 1; i < 201; i++) {\n            input.append(1);\n        }\n        input.append(\".0\");\n        final String DOC = input.toString();\n\n        // test out with both Reader and ByteArrayInputStream\n        JsonParser p;\n\n        p = FACTORY.createParser(new StringReader(DOC));\n        _testLongerFloat(p, DOC);\n        p.close();\n        \n        p = FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")));\n        _testLongerFloat(p, DOC);\n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n */\npublic final class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    private int _quad1;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private int _skipColon() throws IOException;\n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException;\n    private int _skipWSOrEnd() throws IOException;\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n */\npublic final class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    private int _quad1;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException;\n    @Override\n    public void close() throws IOException;\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private int _skipColon() throws IOException;\n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException;\n    private int _skipWSOrEnd() throws IOException;\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.test.BaseTest\n{\n    private void _testInvalidKeywords(boolean useStream) throws Exception\n    {\n        doTestInvalidKeyword1(useStream, \"nul\");\n        doTestInvalidKeyword1(useStream, \"Null\");\n        doTestInvalidKeyword1(useStream, \"nulla\");\n        doTestInvalidKeyword1(useStream, \"fal\");\n        doTestInvalidKeyword1(useStream, \"False\");\n        doTestInvalidKeyword1(useStream, \"fals0\");\n        doTestInvalidKeyword1(useStream, \"falsett0\");\n        doTestInvalidKeyword1(useStream, \"tr\");\n        doTestInvalidKeyword1(useStream, \"truE\");\n        doTestInvalidKeyword1(useStream, \"treu\");\n        doTestInvalidKeyword1(useStream, \"trueenough\");\n        doTestInvalidKeyword1(useStream, \"C\");\n    }\n    private void doTestInvalidKeyword1(boolean useStream, String value)\n        throws IOException\n    {\n        final String doc = \"{ \\\"key1\\\" : \"+value+\" }\";\n        JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n                : createParserUsingReader(doc);\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        /* 24-Nov-2008, tatu: Note that depending on parser impl, we may\n         *   get the exception early or late...\n         */\n        try {\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            jp.nextToken();\n            fail(\"Expected an exception for malformed value keyword\");\n        } catch (JsonParseException jex) {\n            verifyException(jex, \"Unrecognized token\");\n            verifyException(jex, value);\n        } finally {\n            jp.close();\n        }\n\n        // Try as root-level value as well:\n        jp = useStream ? createParserUsingStream(value, \"UTF-8\")\n                : createParserUsingReader(value);\n        try {\n            jp.nextToken();\n            fail(\"Expected an exception for malformed value keyword\");\n        } catch (JsonParseException jex) {\n            verifyException(jex, \"Unrecognized token\");\n            verifyException(jex, value);\n        } finally {\n            jp.close();\n        }\n    }\n    private void _testMangledNumbers(boolean useStream) throws Exception\n    {\n        String doc = \"123true\";\n        JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n                : createParserUsingReader(doc);\n        try {\n            JsonToken t = jp.nextToken();\n            fail(\"Should have gotten an exception; instead got token: \"+t);\n        } catch (JsonParseException e) {\n            verifyException(e, \"expected space\");\n        }\n        jp.close();\n\n        // Also test with floats\n        doc = \"1.5false\";\n        jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n                : createParserUsingReader(doc);\n        try {\n            JsonToken t = jp.nextToken();\n            fail(\"Should have gotten an exception; instead got token: \"+t);\n        } catch (JsonParseException e) {\n            verifyException(e, \"expected space\");\n        }\n        jp.close();\n    }\n    public void testMangledNumbersBytes() throws Exception {\n        _testMangledNumbers(true);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class that defines public API for writing JSON content.\n * Instances are created using factory methods of\n * a {@link JsonFactory} instance.\n *\n * @author Tatu Saloranta\n */\npublic abstract class JsonGenerator\n    implements Closeable, Flushable, Versioned\n{\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Method called to close this generator, so that no more content\n     * can be written.\n     *<p>\n     * Whether the underlying target (stream, writer) gets closed depends\n     * on whether this generator either manages the target (i.e. is the\n     * only one with access to the target -- case if caller passes a\n     * reference to the resource such as File, but not stream); or\n     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.\n     * If either of above is true, the target is also closed. Otherwise\n     * (not managing, feature not enabled), target is not closed.\n     */\n    @Override\n    public abstract void close() throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used for constructing and throwing\n     * @link JsonGenerationException} with given base message.;\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to @link #writeFieldName(String)}, main difference;\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to {@link #writeStartArray()}, but also specifying how many\n     * elements will be written for the array before calling\n     * {@link #writeEndArray()}.\n     *<p>\n     * Default implementation simply calls {@link #writeStartArray()}.\n     * \n     * @param size Number of elements this array will have: actual\n     *   number of values written (before matching call to\n     *   {@link #writeEndArray()} MUST match; generator MAY verify\n     *   this is the case.\n     *   \n     * @since 2.4\n     */\n    public void writeStartArray(int size) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     */\n    public void writeBinary(byte[] data, int offset, int len) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n     * assumes that whole byte array is to be output.\n     */\n    public void writeBinary(byte[] data) throws IOException;\n    /**\n     * Method for writing closing marker of a JSON Object value\n     * (character '}'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Object, and the last written event was either a\n     * complete value, or START-OBJECT marker (see JSON specification\n     * for more details).\n     */\n    public abstract void writeEndObject() throws IOException;\n\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to @link #writeFieldName(String)}, main difference;\n    /**\n     * Method that will output given chunk of binary data as base64\n     * encoded, as a complete String value (surrounded by double quotes).\n     * This method defaults\n     *<p>\n     * Note: because JSON Strings can not contain unescaped linefeeds,\n     * if linefeeds are included (as per last argument), they must be\n     * escaped. This adds overhead for decoding without improving\n     * readability.\n     * Alternatively if linefeeds are not included,\n     * resulting String value may violate the requirement of base64\n     * RFC which mandates line-length of 76 characters and use of\n     * linefeeds. However, all {@link JsonParser} implementations\n     * are required to accept such \"long line base64\"; as do\n     * typical production-level base64 decoders.\n     *\n     * @param bv Base64 variant to use: defines details such as\n     *   whether padding is used (and if so, using which character);\n     *   what is the maximum line length before adding linefeed,\n     *   and also the underlying alphabet to use.\n     */\n    public abstract void writeBinary(Base64Variant bv,\n            byte[] data, int offset, int len) throws IOException;\n\n    /**\n     * Similar to @link #writeBinary(Base64Variant,byte[],int,int)},;\n    /**\n     * Method for writing closing marker of a JSON Array value\n     * (character ']'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Array.\n     */\n    public abstract void writeEndArray() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     * \n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known. Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may\n     */\n    public int writeBinary(InputStream data, int dataLength)\n        throws IOException;\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Method similar to {@link #writeFieldName(String)}, main difference\n     * being that it may perform better as some of processing (such as\n     * quoting of certain characters, or encoding into external encoding\n     * if supported by generator) can be done just once and reused for\n     * later calls.\n     *<p>\n     * Default implementation simple uses unprocessed name container in\n     * serialized String; implementations are strongly encouraged to make\n     * use of more efficient methods argument object has.\n     */\n    public abstract void writeFieldName(SerializableString name) throws IOException;\n\n    /**\n     * Alternative to @link #writeFieldName(String)} that may be used;\n    /**\n     * Method similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but where input is provided through a stream, allowing for incremental\n     * writes without holding the whole input in memory.\n     * \n     * @param bv Base64 variant to use\n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known.\n     *    If a positive length is given, <code>data</code> MUST provide at least\n     *    that many bytes: if not, an exception will be thrown.\n     *    Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may.\n     * \n     * @return Number of bytes read from <code>data</code> and written as binary payload\n     * \n     * @since 2.1\n     */\n    public abstract int writeBinary(Base64Variant bv,\n            InputStream data, int dataLength) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, numeric\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     *\n     * @since 2.2\n     */\n    public void writeNumber(short v) throws IOException  writeNumber((int) v); };\n    /**\n     * Method for writing starting marker of a Array value\n     * (for JSON this is character '['; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Array values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartArray() throws IOException;\n\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to @link #writeStartArray()}, but also specifying how many;\n    /**\n     * Method for outputting literal JSON null value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeNull() throws IOException;\n\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException;\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class that defines public API for writing JSON content.\n * Instances are created using factory methods of\n * a {@link JsonFactory} instance.\n *\n * @author Tatu Saloranta\n */\npublic abstract class JsonGenerator\n    implements Closeable, Flushable, Versioned\n{\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Method called to close this generator, so that no more content\n     * can be written.\n     *<p>\n     * Whether the underlying target (stream, writer) gets closed depends\n     * on whether this generator either manages the target (i.e. is the\n     * only one with access to the target -- case if caller passes a\n     * reference to the resource such as File, but not stream); or\n     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.\n     * If either of above is true, the target is also closed. Otherwise\n     * (not managing, feature not enabled), target is not closed.\n     */\n    @Override\n    public abstract void close() throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used for constructing and throwing\n     * @link JsonGenerationException} with given base message.;\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to @link #writeFieldName(String)}, main difference;\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to {@link #writeStartArray()}, but also specifying how many\n     * elements will be written for the array before calling\n     * {@link #writeEndArray()}.\n     *<p>\n     * Default implementation simply calls {@link #writeStartArray()}.\n     * \n     * @param size Number of elements this array will have: actual\n     *   number of values written (before matching call to\n     *   {@link #writeEndArray()} MUST match; generator MAY verify\n     *   this is the case.\n     *   \n     * @since 2.4\n     */\n    public void writeStartArray(int size) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     */\n    public void writeBinary(byte[] data, int offset, int len) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n     * assumes that whole byte array is to be output.\n     */\n    public void writeBinary(byte[] data) throws IOException;\n    /**\n     * Method for writing closing marker of a JSON Object value\n     * (character '}'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Object, and the last written event was either a\n     * complete value, or START-OBJECT marker (see JSON specification\n     * for more details).\n     */\n    public abstract void writeEndObject() throws IOException;\n\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to @link #writeFieldName(String)}, main difference;\n    /**\n     * Method that will output given chunk of binary data as base64\n     * encoded, as a complete String value (surrounded by double quotes).\n     * This method defaults\n     *<p>\n     * Note: because JSON Strings can not contain unescaped linefeeds,\n     * if linefeeds are included (as per last argument), they must be\n     * escaped. This adds overhead for decoding without improving\n     * readability.\n     * Alternatively if linefeeds are not included,\n     * resulting String value may violate the requirement of base64\n     * RFC which mandates line-length of 76 characters and use of\n     * linefeeds. However, all {@link JsonParser} implementations\n     * are required to accept such \"long line base64\"; as do\n     * typical production-level base64 decoders.\n     *\n     * @param bv Base64 variant to use: defines details such as\n     *   whether padding is used (and if so, using which character);\n     *   what is the maximum line length before adding linefeed,\n     *   and also the underlying alphabet to use.\n     */\n    public abstract void writeBinary(Base64Variant bv,\n            byte[] data, int offset, int len) throws IOException;\n\n    /**\n     * Similar to @link #writeBinary(Base64Variant,byte[],int,int)},;\n    /**\n     * Method for writing closing marker of a JSON Array value\n     * (character ']'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Array.\n     */\n    public abstract void writeEndArray() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     * \n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known. Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may\n     */\n    public int writeBinary(InputStream data, int dataLength)\n        throws IOException;\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException;\n    /**\n     * Method similar to {@link #writeFieldName(String)}, main difference\n     * being that it may perform better as some of processing (such as\n     * quoting of certain characters, or encoding into external encoding\n     * if supported by generator) can be done just once and reused for\n     * later calls.\n     *<p>\n     * Default implementation simple uses unprocessed name container in\n     * serialized String; implementations are strongly encouraged to make\n     * use of more efficient methods argument object has.\n     */\n    public abstract void writeFieldName(SerializableString name) throws IOException;\n\n    /**\n     * Alternative to @link #writeFieldName(String)} that may be used;\n    /**\n     * Method similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but where input is provided through a stream, allowing for incremental\n     * writes without holding the whole input in memory.\n     * \n     * @param bv Base64 variant to use\n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known.\n     *    If a positive length is given, <code>data</code> MUST provide at least\n     *    that many bytes: if not, an exception will be thrown.\n     *    Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may.\n     * \n     * @return Number of bytes read from <code>data</code> and written as binary payload\n     * \n     * @since 2.1\n     */\n    public abstract int writeBinary(Base64Variant bv,\n            InputStream data, int dataLength) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, numeric\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     *\n     * @since 2.2\n     */\n    public void writeNumber(short v) throws IOException  writeNumber((int) v); };\n    /**\n     * Method for writing starting marker of a Array value\n     * (for JSON this is character '['; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Array values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartArray() throws IOException;\n\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to @link #writeStartArray()}, but also specifying how many;\n    /**\n     * Method for outputting literal JSON null value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeNull() throws IOException;\n\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException;\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testSimpleBinaryWrite(boolean useCharBased) throws Exception\n    {\n        /* Let's only test the standard base64 variant; but write\n         * values in root, array and object contexts.\n         */\n        Base64Variant b64v = Base64Variants.getDefaultVariant();\n        JsonFactory jf = new JsonFactory();\n\n        for (int i = 0; i < 3; ++i) {\n            JsonGenerator gen;\n            ByteArrayOutputStream bout = new ByteArrayOutputStream(200);\n            if (useCharBased) {\n                gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n            } else {\n                gen = jf.createGenerator(bout, JsonEncoding.UTF8);\n            }\n\n            switch (i) {\n            case 0: // root\n                gen.writeBinary(b64v, WIKIPEDIA_BASE64_AS_BYTES, 0, WIKIPEDIA_BASE64_AS_BYTES.length);\n                break;\n            case 1: // array\n                gen.writeStartArray();\n                gen.writeBinary(b64v, WIKIPEDIA_BASE64_AS_BYTES, 0, WIKIPEDIA_BASE64_AS_BYTES.length);\n                gen.writeEndArray();\n                break;\n            default: // object\n                gen.writeStartObject();\n                gen.writeFieldName(\"field\");\n                gen.writeBinary(b64v, WIKIPEDIA_BASE64_AS_BYTES, 0, WIKIPEDIA_BASE64_AS_BYTES.length);\n                gen.writeEndObject();\n                break;\n            }\n            gen.close();\n\n            JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray()));\n            \n            // Need to skip other events before binary data:\n            switch (i) {\n            case 0:\n                break;\n            case 1:\n                assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n                break;\n            default:\n                assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n                assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n                break;\n            }\n            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n            String actualValue = jp.getText();\n            jp.close();\n            assertEquals(WIKIPEDIA_BASE64_ENCODED, actualValue);\n        }\n    }\n    private void _testStreamingWrites(JsonFactory jf, boolean useBytes) throws Exception\n    {\n        final byte[] INPUT = TEXT4.getBytes(\"UTF-8\");\n        for (Base64Variant variant : VARIANTS) {\n            final String EXP_OUTPUT = \"[\" + quote(variant.encode(INPUT))+\"]\";\n            for (boolean passLength : new boolean[] { true, false }) {\n                for (int chunkSize : new int[] { 1, 2, 3, 4, 7, 11, 29, 5000 }) {\n//System.err.println(\"\"+variant+\", length \"+passLength+\", chunk \"+chunkSize);\n                    \n                    JsonGenerator jgen;\n                    \n                    final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n                    if (useBytes) {\n                        jgen = jf.createGenerator(bytes);\n                    } else {\n                        jgen = jf.createGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n                    }\n                    jgen.writeStartArray();\n                    int length = passLength ? INPUT.length : -1;\n                    InputStream data = new ThrottledInputStream(INPUT, chunkSize);\n                    jgen.writeBinary(variant, data, length);\n                    jgen.writeEndArray();\n                    jgen.close();\n                    String JSON = bytes.toString(\"UTF-8\");\n                    assertEquals(EXP_OUTPUT, JSON);\n                }\n            }\n        }\n    }\n    public void testBinaryAsEmbeddedObject() throws Exception\n    {\n        JsonGenerator g;\n\n        StringWriter sw = new StringWriter();\n        g = JSON_F.createGenerator(sw);\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n        g.close();\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), sw.toString());\n\n        ByteArrayOutputStream bytes =  new ByteArrayOutputStream(100);\n        g = JSON_F.createGenerator(bytes);\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES);\n        g.close();\n        assertEquals(quote(WIKIPEDIA_BASE64_ENCODED), bytes.toString(\"UTF-8\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    @Override public boolean hasCurrentToken()  return _currToken != null; };\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId();\n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken()  return _currToken == JsonToken.START_OBJECT; };\n    @Override public boolean isExpectedStartArrayToken()  return _currToken == JsonToken.START_ARRAY; };\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken();\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException  return delegate.getNumberType(); };\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken()  return _currToken; };\n    @Override\n    public String getCurrentName() throws IOException;\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException  return delegate.getText();  };\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException  return delegate.getIntValue(); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    @Override public boolean hasCurrentToken()  return _currToken != null; };\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId();\n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken()  return _currToken == JsonToken.START_OBJECT; };\n    @Override public boolean isExpectedStartArrayToken()  return _currToken == JsonToken.START_ARRAY; };\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken();\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException  return delegate.getNumberType(); };\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken()  return _currToken; };\n    @Override\n    public String getCurrentName() throws IOException;\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException  return delegate.getText();  };\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException  return delegate.getIntValue(); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testTokensSingleMatchWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n        assertFalse(p.hasCurrentToken());\n        assertNull(p.getCurrentToken());\n        assertEquals(JsonTokenId.ID_NO_TOKEN, p.getCurrentTokenId());\n        assertFalse(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n        \n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n//      String result = readAndWrite(JSON_F, p);\n//      assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);  assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(JsonToken.START_OBJECT, p.getCurrentToken());\n        assertTrue(p.isExpectedStartObjectToken());\n        assertFalse(p.isExpectedStartArrayToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(JsonToken.FIELD_NAME, p.getCurrentToken());\n        assertEquals(\"ob\", p.getCurrentName());\n//        assertEquals(\"ob\", p.getText());  assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertEquals(\"ob\", p.getCurrentName());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"value\", p.getCurrentName());\n        assertEquals(\"value\", p.getText());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.getCurrentToken());\n        assertEquals(NumberType.INT, p.getNumberType());\n        assertEquals(3, p.getIntValue());\n        assertEquals(\"value\", p.getCurrentName());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertEquals(JsonToken.END_OBJECT, p.getCurrentToken());\n\n        p.clearCurrentToken();\n        assertNull(p.getCurrentToken());\n        \n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount();\n    @Override\n    public JsonToken nextValue() throws IOException;\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException;\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount();\n    @Override\n    public JsonToken nextValue() throws IOException;\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException;\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSingleMatchFilteringWithPath() throws Exception\n    {\n        String jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\");\n        JsonParser p0 = JSON_F.createParser(jsonString);\n        FilteringParserDelegate p = new FilteringParserDelegate(p0,\n                new NameMatchFilter(\"a\"),\n                true, // includePath\n                false // multipleMatches\n        );\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"{'a':123}\"), result);\n        assertEquals(1, p.getMatchCount());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link PrettyPrinter} implementation that uses 2-space\n * indentation with platform-default linefeeds.\n * Usually this class is not instantiated directly, but instead\n * method {@link JsonGenerator#useDefaultPrettyPrinter} is\n * used, which will use an instance of this class for operation.\n */\npublic class DefaultPrettyPrinter\n    implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    public final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n    /**\n     * @since 2.9\n     */\n    public DefaultPrettyPrinter withSeparators(Separators separators);\n    @Override\n    public void writeEndObject(JsonGenerator g, int nrOfEntries) throws IOException;\n    @Override\n    public void writeStartObject(JsonGenerator g) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public DefaultPrettyPrinter createInstance();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link PrettyPrinter} implementation that uses 2-space\n * indentation with platform-default linefeeds.\n * Usually this class is not instantiated directly, but instead\n * method {@link JsonGenerator#useDefaultPrettyPrinter} is\n * used, which will use an instance of this class for operation.\n */\npublic class DefaultPrettyPrinter\n    implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    public final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n    /**\n     * @since 2.9\n     */\n    public DefaultPrettyPrinter withSeparators(Separators separators);\n    @Override\n    public void writeEndObject(JsonGenerator g, int nrOfEntries) throws IOException;\n    @Override\n    public void writeStartObject(JsonGenerator g) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public DefaultPrettyPrinter createInstance();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private String _printTestData(PrettyPrinter pp, boolean useBytes) throws IOException\n    {\n        JsonGenerator gen;\n        StringWriter sw;\n        ByteArrayOutputStream bytes;\n\n        if (useBytes) {\n            sw = null;\n            bytes = new ByteArrayOutputStream();\n            gen = JSON_F.createGenerator(bytes);\n        } else {\n            sw = new StringWriter();\n            bytes = null;\n            gen = JSON_F.createGenerator(sw);\n        }\n        gen.setPrettyPrinter(pp);\n        gen.writeStartObject();\n        gen.writeFieldName(\"name\");\n        gen.writeString(\"John Doe\");\n        gen.writeFieldName(\"age\");\n        gen.writeNumber(3.14);\n        gen.writeEndObject();\n        gen.close();\n\n        if (useBytes) {\n            return bytes.toString(\"UTF-8\");\n        }\n        return sw.toString();\n    }\n    public void testInvalidSubClass() throws Exception\n    {\n        DefaultPrettyPrinter pp = new MyPrettyPrinter();\n        try {\n            pp.createInstance();\n            fail(\"Should not pass\");\n        } catch (IllegalStateException e) {\n            verifyException(e, \"does not override\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n\n    @Override public JsonToken currentToken()  return _currToken; };\n    // @since 2.10\n    protected void reportOverflowLong(String numDesc) throws IOException;\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 64-bit range when requested as {@link long}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowLong() throws IOException;\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 32-bit range when requested as {@link int}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowInt() throws IOException;\n}\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations. Contains most common things that are independent\n * of actual underlying input source.\n */\npublic abstract class ParserBase extends ParserMinimalBase\n{\n    @Override\n    public long getLongValue() throws IOException;\n    /**********************************************************\n     */\n    \n    @Override\n    public Number getNumberValue() throws IOException;\n    /**********************************************************\n     */    \n    \n    protected void convertNumberToInt() throws IOException;\n    @Override\n    public NumberType getNumberType() throws IOException;\n    private void _parseSlowInt(int expType) throws IOException;\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n\n    @Override public JsonToken currentToken()  return _currToken; };\n    // @since 2.10\n    protected void reportOverflowLong(String numDesc) throws IOException;\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 64-bit range when requested as {@link long}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowLong() throws IOException;\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 32-bit range when requested as {@link int}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowInt() throws IOException;\n}\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations. Contains most common things that are independent\n * of actual underlying input source.\n */\npublic abstract class ParserBase extends ParserMinimalBase\n{\n    @Override\n    public long getLongValue() throws IOException;\n    /**********************************************************\n     */\n    \n    @Override\n    public Number getNumberValue() throws IOException;\n    /**********************************************************\n     */    \n    \n    protected void convertNumberToInt() throws IOException;\n    @Override\n    public NumberType getNumberType() throws IOException;\n    private void _parseSlowInt(int expType) throws IOException;\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private AsyncReaderWrapper createParser(String doc) throws IOException\n    {\n        return asyncForBytes(JSON_F, 1, _jsonDoc(doc), 1);\n    }\n    public void testToLongFailing() throws Exception\n    {\n        AsyncReaderWrapper p;\n\n        // BigInteger -> error\n        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n        p = createParser(String.valueOf(big));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n        assertEquals(big, p.getBigIntegerValue());\n        assertEquals(big, p.getNumberValue());\n        try {\n            p.getLongValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of long\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Long.TYPE, e.getTargetType());\n        }\n        BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);\n        p = createParser(String.valueOf(small));\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(small, p.getBigIntegerValue());\n        try {\n            p.getLongValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of long\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Long.TYPE, e.getTargetType());\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testLargeUnquoted(int mode) throws Exception\n    {\n        StringBuilder sb = new StringBuilder(5000);\n        sb.append(\"[\\n\");\n        //final int REPS = 2000;\n        final int REPS = 1050;\n        for (int i = 0; i < REPS; ++i) {\n            if (i > 0) {\n                sb.append(',');\n                if ((i & 7) == 0) {\n                    sb.append('\\n');\n                }\n            }\n            sb.append(\"{\");\n            sb.append(\"abc\").append(i&127).append(':');\n            sb.append((i & 1) != 0);\n            sb.append(\"}\\n\");\n        }\n        sb.append(\"]\");\n        String JSON = sb.toString();\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n        assertToken(JsonToken.START_ARRAY, p.nextToken());\n        for (int i = 0; i < REPS; ++i) {\n            assertToken(JsonToken.START_OBJECT, p.nextToken());\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n            assertEquals(\"abc\"+(i&127), p.getCurrentName());\n            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, p.nextToken());\n            assertToken(JsonToken.END_OBJECT, p.nextToken());\n        }\n        assertToken(JsonToken.END_ARRAY, p.nextToken());\n        p.close();\n    }\n    private void _testSimpleUnquoted(int mode) throws Exception\n    {\n        String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"a\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"_foo\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"$\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(\"money!\", p.getText());\n\n        // and then regular quoted one should still work too:\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\" \", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        p.close();\n\n        // Another thing, as per [Issue#102]: numbers\n\n        JSON = \"{ 123:true,4:false }\";\n        p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"123\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"4\", p.getCurrentName());\n        assertToken(JsonToken.VALUE_FALSE, p.nextToken());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        p.close();\n    }\n    public void testUnquotedIssue510() throws Exception\n    {\n        // NOTE! Requires longer input buffer to trigger longer codepath\n        char[] fullChars = new char[4001];\n        for (int i = 0; i < 3998; i++) {\n             fullChars[i] = ' ';\n        }\n        fullChars[3998] = '{';\n        fullChars[3999] = 'a';\n        fullChars[4000] = 256;\n\n        JsonParser p = UNQUOTED_FIELDS_F.createParser(new java.io.StringReader(new String(fullChars)));\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        try {\n            p.nextToken();\n            fail(\"Should not pass\");\n        } catch (JsonParseException e) {\n            ; // should fail here\n        }\n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder();\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder();\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException;\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testLocationOffsets() throws Exception\n    {\n        JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser();\n        ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n\n        byte[] input = utf8Bytes(\"[[[\");\n\n        feeder.feedInput(input, 2, 3);\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n        assertEquals(1, parser.getCurrentLocation().getByteOffset());\n        assertEquals(1, parser.getTokenLocation().getByteOffset());\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n        assertEquals(2, parser.getCurrentLocation().getColumnNr());\n        assertEquals(1, parser.getTokenLocation().getColumnNr());\n\n        feeder.feedInput(input, 0, 1);\n        assertEquals(JsonToken.START_ARRAY, parser.nextToken());\n        assertEquals(2, parser.getCurrentLocation().getByteOffset());\n        assertEquals(2, parser.getTokenLocation().getByteOffset());\n        assertEquals(1, parser.getCurrentLocation().getLineNr());\n        assertEquals(1, parser.getTokenLocation().getLineNr());\n        assertEquals(3, parser.getCurrentLocation().getColumnNr());\n        assertEquals(2, parser.getTokenLocation().getColumnNr());\n        parser.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    private int _quad1;\n    @Override\n    public JsonLocation getCurrentLocation();\n    @Override\n    public ObjectCodec getCodec();\n    @Override\n    public JsonLocation getTokenLocation();\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    private int _quad1;\n    @Override\n    public JsonLocation getCurrentLocation();\n    @Override\n    public ObjectCodec getCodec();\n    @Override\n    public JsonLocation getTokenLocation();\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testOffsetWithInputOffset() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        JsonLocation loc;\n        JsonParser p;\n        // 3 spaces before, 2 after, just for padding\n        byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n\n        // and then peel them off\n        p = f.createParser(b, 3, b.length-5);\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        loc = p.getTokenLocation();\n        assertEquals(0L, loc.getByteOffset());\n        assertEquals(-1L, loc.getCharOffset());\n        assertEquals(1, loc.getLineNr());\n        assertEquals(1, loc.getColumnNr());\n        \n        loc = p.getCurrentLocation();\n        assertEquals(1L, loc.getByteOffset());\n        assertEquals(-1L, loc.getCharOffset());\n        assertEquals(1, loc.getLineNr());\n        assertEquals(2, loc.getColumnNr());\n\n        p.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment();\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize);\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment();\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize);\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n      public void testExpand()\n      {\n          TextBuffer tb = new TextBuffer(new BufferRecycler());\n          char[] buf = tb.getCurrentSegment();\n\n          while (buf.length < 500 * 1000) {\n              char[] old = buf;\n              buf = tb.expandCurrentSegment();\n              if (old.length >= buf.length) {\n                  fail(\"Expected buffer of \"+old.length+\" to expand, did not, length now \"+buf.length);\n              }\n          }\n      }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str);\n    /**********************************************************\n     */\n\n    public boolean matches()  return _nextSegment == null; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str);\n    /**********************************************************\n     */\n\n    public boolean matches()  return _nextSegment == null; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testWonkyNumber173() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/1e0\");\n        assertFalse(ptr.matches());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex()  return _matchingElementIndex; };\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex()  return _matchingElementIndex; };\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIZeroIndex() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/0\");\n        assertEquals(0, ptr.getMatchingIndex());\n        ptr = JsonPointer.compile(\"/00\");\n        assertEquals(-1, ptr.getMatchingIndex());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Extension of {@link JsonStreamContext}, which implements\n * core methods needed, and also exposes\n * more complete API to generator implementation classes.\n */\npublic class JsonWriteContext extends JsonStreamContext\n{\n    public final static int STATUS_OK_AS_IS = 0;\n    public final static int STATUS_OK_AFTER_COMMA = 1;\n    public final static int STATUS_OK_AFTER_COLON = 2;\n    public final static int STATUS_OK_AFTER_SPACE = 3; // in root context\n    public final static int STATUS_EXPECT_VALUE = 4;\n    public final static int STATUS_EXPECT_NAME = 5;\n    /**\n     * Overridden to provide developer writeable \"JsonPath\" representation\n     * of the context.\n     */\n    @Override public String toString();\n    public int writeValue();\n    /**\n     * Method that writer is to call before it writes a field name.\n     *\n     * @return Index of the field entry (0-based)\n     */\n    public int writeFieldName(String name) throws JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Extension of {@link JsonStreamContext}, which implements\n * core methods needed, and also exposes\n * more complete API to generator implementation classes.\n */\npublic class JsonWriteContext extends JsonStreamContext\n{\n    public final static int STATUS_OK_AS_IS = 0;\n    public final static int STATUS_OK_AFTER_COMMA = 1;\n    public final static int STATUS_OK_AFTER_COLON = 2;\n    public final static int STATUS_OK_AFTER_SPACE = 3; // in root context\n    public final static int STATUS_EXPECT_VALUE = 4;\n    public final static int STATUS_EXPECT_NAME = 5;\n    /**\n     * Overridden to provide developer writeable \"JsonPath\" representation\n     * of the context.\n     */\n    @Override public String toString();\n    public int writeValue();\n    /**\n     * Method that writer is to call before it writes a field name.\n     *\n     * @return Index of the field entry (0-based)\n     */\n    public int writeFieldName(String name) throws JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n    {\n        JsonGenerator gen;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        if (useReader) {\n            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n        } else {\n            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n        }\n        gen.writeStartObject();\n        gen.writeFieldName(\"a\");\n        \n        try {\n            gen.writeFieldName(\"b\");\n            gen.flush();\n            String json = bout.toString(\"UTF-8\");\n            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n        } catch (JsonProcessingException e) {\n            verifyException(e, \"can not write a field name, expecting a value\");\n        }\n        gen.close();\n    }\n    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n    {\n        JsonGenerator gen;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        if (useReader) {\n            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n        } else {\n            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n        }\n        gen.writeStartObject();\n        \n        try {\n            gen.writeString(\"a\");\n            gen.flush();\n            String json = bout.toString(\"UTF-8\");\n            fail(\"Should not have let \"+gen.getClass().getName()+\".writeString() be used in place of 'writeFieldName()': output = \"+json);\n        } catch (JsonProcessingException e) {\n            verifyException(e, \"can not write a String\");\n        }\n        gen.close();\n    }\n    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n        _testFailOnWritingStringNotFieldName(F, false);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**********************************************************\n     */\n\n    public String contentsAsString();\n    public char[] getTextBuffer();\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    private final BufferRecycler _allocator;\n    private char[] _inputBuffer;\n    private int _inputStart;\n    private int _inputLen;\n    private ArrayList<char[]> _segments;\n    private boolean _hasSegments = false;\n    private int _segmentSize;\n    private char[] _currentSegment;\n    private int _currentSize;\n    private String _resultString;\n    private char[] _resultArray;\n    /**********************************************************\n     */\n\n    public String contentsAsString();\n    public char[] getTextBuffer();\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    public void testEmpty() {\n        TextBuffer tb = new TextBuffer(new BufferRecycler());\n        tb.resetWithEmpty();\n\n        assertTrue(tb.getTextBuffer().length == 0);\n        tb.contentsAsString();\n        assertTrue(tb.getTextBuffer().length == 0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException;\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n}\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n    @Override public JsonToken getCurrentToken()  return _currToken; };\n    @Override\n    public String getValueAsString(String defaultValue) throws IOException;\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken();\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException;\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken();\n    @Override\n    public String getValueAsString() throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException;\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException;\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException;\n}\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n    @Override public JsonToken getCurrentToken()  return _currToken; };\n    @Override\n    public String getValueAsString(String defaultValue) throws IOException;\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken();\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException;\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken();\n    @Override\n    public String getValueAsString() throws IOException;\n}\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n    private int _quad1;\n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException;\n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.core.BaseTest\n{\n    private void _testIntern(boolean useStream, boolean enableIntern, String expName) throws IOException\n    {\n        JsonFactory f = new JsonFactory();\n        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, enableIntern);\n        assertEquals(enableIntern, f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n        final String JSON = \"{ \\\"\"+expName+\"\\\" : 1}\";\n        JsonParser jp = useStream ?\n            createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n            \n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        // needs to be same of cours\n        String actName = jp.getCurrentName();\n        assertEquals(expName, actName);\n        if (enableIntern) {\n            assertSame(expName, actName);\n        } else {\n            assertNotSame(expName, actName);\n        }\n        jp.close();\n    }\n    private void _testNameEscaping(boolean useStream) throws IOException\n    {\n        final Map<String,String> NAME_MAP = new LinkedHashMap<String,String>();\n        NAME_MAP.put(\"\", \"\");\n        NAME_MAP.put(\"\\\\\\\"funny\\\\\\\"\", \"\\\"funny\\\"\");\n        NAME_MAP.put(\"\\\\\\\\\", \"\\\\\");\n        NAME_MAP.put(\"\\\\r\", \"\\r\");\n        NAME_MAP.put(\"\\\\n\", \"\\n\");\n        NAME_MAP.put(\"\\\\t\", \"\\t\");\n        NAME_MAP.put(\"\\\\r\\\\n\", \"\\r\\n\");\n        NAME_MAP.put(\"\\\\\\\"\\\\\\\"\", \"\\\"\\\"\");\n        NAME_MAP.put(\"Line\\\\nfeed\", \"Line\\nfeed\");\n        NAME_MAP.put(\"Yet even longer \\\\\\\"name\\\\\\\"!\", \"Yet even longer \\\"name\\\"!\");\n\n        int entry = 0;\n        for (Map.Entry<String,String> en : NAME_MAP.entrySet()) {\n            ++entry;\n            String input = en.getKey();\n            String expResult = en.getValue();\n            final String DOC = \"{ \\\"\"+input+\"\\\":null}\";\n            JsonParser jp = useStream ?\n                    JSON_FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n                : JSON_FACTORY.createParser(new StringReader(DOC));\n\n            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            // first, sanity check (field name == getText()\n            String act = jp.getCurrentName();\n            assertEquals(act, getAndVerifyText(jp));\n            if (!expResult.equals(act)) {\n                String msg = \"Failed for name #\"+entry+\"/\"+NAME_MAP.size();\n                if (expResult.length() != act.length()) {\n                    fail(msg+\": exp length \"+expResult.length()+\", actual \"+act.length());\n                }\n                assertEquals(msg, expResult, act);\n            }\n            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n            jp.close();\n        }\n    }\n    private void _testLongText(int LEN) throws Exception\n    {\n        StringBuilder sb = new StringBuilder(LEN + 100);\n        Random r = new Random(99);\n        while (sb.length() < LEN) {\n            sb.append(r.nextInt());\n            sb.append(\" xyz foo\");\n            if (r.nextBoolean()) {\n                sb.append(\" and \\\"bar\\\"\");\n            } else if (r.nextBoolean()) {\n                sb.append(\" [whatever].... \");\n            } else {\n                // Let's try some more 'exotic' chars\n                sb.append(\" UTF-8-fu: try this {\\u00E2/\\u0BF8/\\uA123!} (look funny?)\");\n            }\n            if (r.nextBoolean()) {\n                if (r.nextBoolean()) {\n                    sb.append('\\n');\n                } else if (r.nextBoolean()) {\n                    sb.append('\\r');\n                } else {\n                    sb.append(\"\\r\\n\");\n                }\n            }\n        }\n        final String VALUE = sb.toString();\n        \n        // Let's use real generator to get JSON done right\n        StringWriter sw = new StringWriter(LEN + (LEN >> 2));\n        JsonGenerator jg = JSON_FACTORY.createGenerator(sw);\n        jg.writeStartObject();\n        jg.writeFieldName(\"doc\");\n        jg.writeString(VALUE);\n        jg.writeEndObject();\n        jg.close();\n        \n        final String DOC = sw.toString();\n\n        for (int type = 0; type < 3; ++type) {\n            JsonParser jp;\n\n            switch (type) {\n            default:\n                jp = JSON_FACTORY.createParser(DOC.getBytes(\"UTF-8\"));\n                break;\n            case 1:\n                jp = JSON_FACTORY.createParser(DOC);\n                break;\n            case 2: // NEW: let's also exercise UTF-32...\n                jp = JSON_FACTORY.createParser(encodeInUTF32BE(DOC));\n                break;\n            }\n            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            assertEquals(\"doc\", jp.getCurrentName());\n            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n            \n            String act = getAndVerifyText(jp);\n            if (act.length() != VALUE.length()) {\n                fail(\"Expected length \"+VALUE.length()+\", got \"+act.length());\n            }\n            if (!act.equals(VALUE)) {\n                fail(\"Long text differs\");\n            }\n\n            // should still know the field name\n            assertEquals(\"doc\", jp.getCurrentName());\n            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n            assertNull(jp.nextToken());\n            jp.close();\n        }\n    }\n    private void _testHandlingOfInvalidSpace(boolean useStream) throws Exception\n    {\n        final String JSON = \"{ \\u00A0 \\\"a\\\":1}\";\n        JsonParser jp = useStream\n                ? createParserUsingStream(JSON_FACTORY, JSON, \"UTF-8\")\n                : createParserUsingReader(JSON_FACTORY, JSON);\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        try {\n            jp.nextToken();\n            fail(\"Should have failed\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"unexpected character\");\n            // and correct error code\n            verifyException(e, \"code 160\");\n        }\n        jp.close();\n    }\n    private void _testHandlingOfInvalidSpaceFromResource(boolean useStream) throws Exception\n    {\n        InputStream in = getClass().getResourceAsStream(\"/test_0xA0.json\");\n        @SuppressWarnings(\"resource\")\n        JsonParser jp = useStream\n                ? JSON_FACTORY.createParser(in)\n                : JSON_FACTORY.createParser(new InputStreamReader(in, \"UTF-8\"));\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        try {\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            assertEquals(\"request\", jp.getCurrentName());\n            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            assertEquals(\"mac\", jp.getCurrentName());\n            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n            assertNotNull(jp.getText());\n            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n            assertEquals(\"data\", jp.getCurrentName());\n            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n\n            // ... and from there on, just loop\n            \n            while (jp.nextToken()  != null) { }\n            fail(\"Should have failed\");\n        } catch (JsonParseException e) {\n            verifyException(e, \"unexpected character\");\n            // and correct error code\n            verifyException(e, \"code 160\");\n        }\n        jp.close();\n    }\n    private void _testGetValueAsText(JsonFactory f,\n            boolean useBytes, boolean delegate) throws Exception\n    {\n        String JSON = \"{\\\"a\\\":1,\\\"b\\\":true,\\\"c\\\":null,\\\"d\\\":\\\"foo\\\"}\";\n        JsonParser p = useBytes ? f.createParser(JSON.getBytes(\"UTF-8\"))\n                : f.createParser(JSON);\n\n        if (delegate) {\n            p = new JsonParserDelegate(p);\n        }\n        \n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n        assertNull(p.getValueAsString());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"a\", p.getText());\n        assertEquals(\"a\", p.getValueAsString());\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(\"1\", p.getValueAsString());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"b\", p.getValueAsString());\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n        assertEquals(\"true\", p.getValueAsString());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"c\", p.getValueAsString());\n        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n        // null token returned as Java null, as per javadoc\n        assertNull(p.getValueAsString());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(\"d\", p.getValueAsString());\n        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(\"foo\", p.getValueAsString());\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n        assertNull(p.getValueAsString());\n\n        assertNull(p.nextToken());\n        p.close();\n    }\n    private void doTestSpec(boolean verify) throws IOException\n    {\n        // First, using a StringReader:\n        doTestSpecIndividual(null, verify);\n\n        // Then with streams using supported encodings:\n        doTestSpecIndividual(\"UTF-8\", verify);\n        doTestSpecIndividual(\"UTF-16BE\", verify);\n        doTestSpecIndividual(\"UTF-16LE\", verify);\n\n        /* Hmmh. UTF-32 is harder only because JDK doesn't come with\n         * a codec for it. Can't test it yet using this method\n         */\n        doTestSpecIndividual(\"UTF-32\", verify);\n    }\n    private void doTestSpecIndividual(String enc, boolean verify) throws IOException\n    {\n        String doc = SAMPLE_DOC_JSON_SPEC;\n        JsonParser jp;\n\n        if (enc == null) {\n            jp = createParserUsingReader(doc);\n        } else {\n            jp = createParserUsingStream(doc, enc);\n        }\n        verifyJsonSpecSampleDoc(jp, verify);\n        jp.close();\n    }\n    public void testGetValueAsTextBytes() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        _testGetValueAsText(f, true, false);\n        _testGetValueAsText(f, true, true);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter\n    implements BeanProperty\n{\n    public final static Object MARKER_FOR_EMPTY = new Object();\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter\n    implements BeanProperty\n{\n    public final static Object MARKER_FOR_EMPTY = new Object();\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testNullColumn() throws Exception\n    {\n        assertEquals(\"[null,\\\"bar\\\"]\", MAPPER.writeValueAsString(new TwoStringsBean()));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n/**\n * Class similar to {@link BeanPropertyWriter}, but that will be used\n * for serializing {@link com.fasterxml.jackson.annotation.JsonAnyGetter} annotated\n * (Map) properties\n */\npublic class AnyGetterWriter\n{\n    /**\n     * @since 2.3\n     */\n    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception;\n    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    /**\n     * Method called to construct serializer for serializing specified bean type.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,\n            BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n/**\n * Class similar to {@link BeanPropertyWriter}, but that will be used\n * for serializing {@link com.fasterxml.jackson.annotation.JsonAnyGetter} annotated\n * (Map) properties\n */\npublic class AnyGetterWriter\n{\n    /**\n     * @since 2.3\n     */\n    public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,\n            PropertyFilter filter)\n                    throws Exception;\n    public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n        throws Exception;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue705() throws Exception\n    {\n        Issue705Bean input = new Issue705Bean(\"key\", \"value\");        \n        String json = MAPPER.writeValueAsString(input);\n        assertEquals(\"{\\\"stuff\\\":\\\"[key/value]\\\"}\", json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n * accessing contents of JSON tree in alternate form (stream of tokens).\n * Useful when a streaming source is expected by code, such as data binding\n * functionality.\n */\npublic class TreeTraversingParser extends ParserMinimalBase\n{\n    /**********************************************************\n     */\n\n    @Override\n    public void close() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    /**********************************************************\n     */\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n * accessing contents of JSON tree in alternate form (stream of tokens).\n * Useful when a streaming source is expected by code, such as data binding\n * functionality.\n */\npublic class TreeTraversingParser extends ParserMinimalBase\n{\n    /**********************************************************\n     */\n\n    @Override\n    public void close() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    /**********************************************************\n     */\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testBase64Text() throws Exception\n    {\n        // let's actually iterate over sets of encoding modes, lengths\n        \n        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n        final Base64Variant[] VARIANTS = {\n                Base64Variants.MIME,\n                Base64Variants.MIME_NO_LINEFEEDS,\n                Base64Variants.MODIFIED_FOR_URL,\n                Base64Variants.PEM\n        };\n\n        for (int len : LENS) {\n            byte[] input = new byte[len];\n            for (int i = 0; i < input.length; ++i) {\n                input[i] = (byte) i;\n            }\n            for (Base64Variant variant : VARIANTS) {\n                TextNode n = new TextNode(variant.encode(input));\n                byte[] data = null;\n                try {\n                    data = n.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n\n                // 15-Aug-2018, tatu: [databind#2096] requires another test\n                JsonParser p = new TreeTraversingParser(n);\n                assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n                try {\n                    data = p.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n                p.close();\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private volatile transient NameTransformer _currentlyTransforming;\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private volatile transient NameTransformer _currentlyTransforming;\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> */\npublic class TestUnwrapped extends BaseMapTest\n{\n    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp() throws Exception\n    {\n        Issue2088Bean bean = MAPPER.readValue(\"{\\\"x\\\":1,\\\"a\\\":2,\\\"y\\\":3,\\\"b\\\":4}\", Issue2088Bean.class);\n        assertEquals(1, bean.x);\n        assertEquals(2, bean.w.a);\n        assertEquals(3, bean.y);\n        assertEquals(4, bean.w.b);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSqlDateConfigOverride() throws Exception\n    {\n        ObjectMapper mapper = newObjectMapper();\n        mapper.configOverride(java.sql.Date.class)\n            .setFormat(JsonFormat.Value.forPattern(\"yyyy+MM+dd\"));        \n        assertEquals(\"\\\"1980+04+14\\\"\", mapper.writeValueAsString(java.sql.Date.valueOf(\"1980-04-14\")));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException;\n}\n/**\n * Shared base class for {@link DeserializationContext} and\n * {@link SerializerProvider}, context objects passed through data-binding\n * process. Designed so that some of implementations can rely on shared\n * aspects like access to secondary contextual objects like type factories\n * or handler instantiators.\n * \n * @since 2.2\n */\npublic abstract class DatabindContext\n{\n    private final static int MAX_ERROR_STR_LEN = 500;\n    public abstract MapperConfig<?> getConfig();\n    public abstract AnnotationIntrospector getAnnotationIntrospector();\n    public abstract boolean isEnabled(MapperFeature feature);\n    public abstract boolean canOverrideAccessModifiers();\n    public abstract Class<?> getActiveView();\n    public abstract Locale getLocale();\n    public abstract TimeZone getTimeZone();\n    public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType);\n    public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException;\n}\n/**\n * Default {@link ValueInstantiator} implementation, which supports\n * Creator methods that can be indicated by standard Jackson\n * annotations.\n */\npublic class StdValueInstantiator\n    extends ValueInstantiator\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @deprecated Since 2.7 call either {@link #unwrapAndWrapException} or\n     *  {@link #wrapAsJsonMappingException}\n     */\n    @Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t);\n}\n/**\n * Class that defines API used by {@link ObjectMapper} and\n * {@link JsonSerializer}s to obtain serializers capable of serializing\n * instances of specific types; as well as the default implementation\n * of the functionality.\n *<p>\n * Provider handles caching aspects of serializer handling; all construction\n * details are delegated to {@link SerializerFactory} instance.\n *<p>\n * Object life-cycle is such that an initial instance (\"blueprint\") is created\n * and referenced by {@link ObjectMapper} and {@link ObjectWriter} intances;\n * but for actual usage, a configured instance is created by using\n * a create method in sub-class\n * {@link com.fasterxml.jackson.databind.ser.DefaultSerializerProvider}.\n * Only this instance can be used for actual serialization calls; blueprint\n * object is only to be used for creating instances.\n */\npublic abstract class SerializerProvider\n    extends DatabindContext\n{\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException;\n    /**\n     * Method that will try to construct a value serializer; and if\n     * one is successfully created, cache it for reuse.\n     */\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException;\n}\n/**\n * Standard implementation used by {@link ObjectMapper}:\n * adds methods only exposed to {@link ObjectMapper},\n * as well as constructors.\n *<p>\n * Note that class is abstract just because it does not\n * define {@link #createInstance} method.\n *<p>\n * Also note that all custom {@link SerializerProvider}\n * implementations must sub-class this class: {@link ObjectMapper}\n * requires this type, not basic provider type.\n */\npublic abstract class DefaultSerializerProvider\n    extends SerializerProvider\n    implements java.io.Serializable // since 2.1; only because ObjectWriter needs it\n{\n    private static final long serialVersionUID = 1L;\n    private IOException _wrapAsIOE(JsonGenerator g, Exception e);\n    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException;\n}\n/**\n * Checked exception used to signal fatal problems with mapping of\n * content, distinct from low-level I/O problems (signaled using\n * simple {@link java.io.IOException}s) or data encoding/decoding\n * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},\n * {@link com.fasterxml.jackson.core.JsonGenerationException}).\n *<p>\n * One additional feature is the ability to denote relevant path\n * of references (during serialization/deserialization) to help in\n * troubleshooting.\n */\npublic class JsonMappingException\n    extends JsonProcessingException\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method is overridden so that we can properly inject description\n     * of problem path, if such is defined.\n     */\n    @Override\n    public String getMessage();\n    /**\n     * @since 2.7\n     */\n    public static JsonMappingException from(JsonParser p, String msg);\n    /**\n     * Method that can be called to either create a new JsonMappingException\n     * (if underlying exception is not a JsonMappingException), or augment\n     * given exception with given path/reference information.\n     */\n    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref);\n    /**\n     * Factory method used when \"upgrading\" an {@link IOException} into\n     * {@link JsonMappingException}: usually only needed to comply with\n     * a signature.\n     *<p>\n     * NOTE: since 2.9 should usually NOT be used on input-side (deserialization)\n     *    exceptions; instead use method(s) of <code>InputMismatchException</code>\n     * \n     * @since 2.1\n     */\n    public static JsonMappingException fromUnexpectedIOE(IOException src);\n}\n/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public final static int TYPE_BYTE_ARRAY = 17; // since 2.9\n    protected double _parseDouble(String key) throws IllegalArgumentException;\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException;\n}\n/**\n * Base class for common deserializers. Contains shared\n * base functionality for dealing with primitive values, such\n * as (re)parsing from String.\n */\npublic abstract class StdDeserializer<T>\n    extends JsonDeserializer<T>\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.8\n     */\n    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException;\n}\n/**\n * Default {@link BeanDescription} implementation used by Jackson.\n *<p>\n * Although sub-classing is a theoretical possibility there are no known\n * use cases for that, nor is such usage tested or supported.\n * Separation from API is mostly to isolate some implementation details\n * here and keep API simple.\n */\npublic class BasicBeanDescription extends BeanDescription\n{\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    @Override\n    public Object instantiateBean(boolean fixAccess);\n}\n/**\n * Base class for deserializable properties of a bean: contains\n * both type and name definitions, and reflection-based set functionality.\n * Concrete sub-classes implement details, so that field- and\n * setter-backed properties, as well as a few more esoteric variations,\n * can be handled.\n */\npublic abstract class SettableBeanProperty\n    extends ConcreteBeanPropertyBase\n    implements java.io.Serializable\n{\n    /**\n     * Method that takes in exception of any type, and casts or wraps it\n     * to an IOException or its subclass.\n     */\n    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException;\n    /**\n     * @since 2.7\n     */\n    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException;\n}\n/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n/**\n * Context for the process of deserialization a single root-level value.\n * Used to allow passing in configuration settings and reusable temporary\n * objects (scrap arrays, containers).\n *<p>\n * Instance life-cycle is such that a partially configured \"blueprint\" object\n * is registered with {@link ObjectMapper} (and {@link ObjectReader},\n * and when actual instance is needed for deserialization,\n * a fully configured instance will be created using a method in extended internal\n *  API of sub-class\n * ({@link com.fasterxml.jackson.databind.deser.DefaultDeserializationContext#createInstance}).\n * Each instance is guaranteed to only be used from single-threaded context;\n * instances may be reused if (and only if) no configuration has changed.\n *<p>\n * Defined as abstract class so that implementations must define methods\n * for reconfiguring blueprints and creating instances.\n */\npublic abstract class DeserializationContext\n    extends DatabindContext\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L; // 2.6\n    /**\n     * @since 2.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType type) throws IOException;\n    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause);\n    /**\n     * Convenience method for parsing a Date from given String, using\n     * currently configured date format (accessed using\n     * {@link DeserializationConfig#getDateFormat()}).\n     *<p>\n     * Implementation will handle thread-safety issues related to\n     * date formats such that first time this method is called,\n     * date format is cloned, and cloned instance will be retained\n     * for use during this deserialization round.\n     */\n    public Date parseDate(String dateStr) throws IllegalArgumentException;\n    /**\n     * Convenience method that may be used by composite or container deserializers,\n     * for reading one-off values contained (for sequences, it is more efficient\n     * to actually fetch deserializer once for the whole collection).\n     *<p>\n     * NOTE: when deserializing values of properties contained in composite types,\n     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};\n     * this method does not allow use of contextual annotations.\n     * \n     * @since 2.4\n     */\n    public <T> T readValue(JsonParser p, Class<T> type) throws IOException;\n}\npublic final class ClassUtil\n{\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Annotation[] NO_ANNOTATIONS = new Annotation[0];\n    private final static Ctor[] NO_CTORS = new Ctor[0];\n    private final static Iterator<?> EMPTY_ITERATOR = Collections.emptyIterator();\n    /**\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Iterator<T> emptyIterator();\n    /**\n     * Returns either `text` or [null].\n     *\n     * @since 2.9\n     */\n    public static String backticked(String text);\n}\n/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException;\n    /**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n/**\n * Class that represents a \"wildcard\" set method which can be used\n * to generically set values of otherwise unmapped (aka \"unknown\")\n * properties read from Json content.\n *<p>\n * !!! Note: might make sense to refactor to share some code\n * with {@link SettableBeanProperty}?\n */\npublic class SettableAnyProperty\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @param e Exception to re-throw or wrap\n     * @param propName Name of property (from Json input) to set\n     * @param value Value of the property\n     */\n    protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException;\n}\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**********************************************************\n     */\n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException;\n}\n/**\n * Shared base class for {@link DeserializationContext} and\n * {@link SerializerProvider}, context objects passed through data-binding\n * process. Designed so that some of implementations can rely on shared\n * aspects like access to secondary contextual objects like type factories\n * or handler instantiators.\n * \n * @since 2.2\n */\npublic abstract class DatabindContext\n{\n    private final static int MAX_ERROR_STR_LEN = 500;\n    public abstract MapperConfig<?> getConfig();\n    public abstract AnnotationIntrospector getAnnotationIntrospector();\n    public abstract boolean isEnabled(MapperFeature feature);\n    public abstract boolean canOverrideAccessModifiers();\n    public abstract Class<?> getActiveView();\n    public abstract Locale getLocale();\n    public abstract TimeZone getTimeZone();\n    public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType);\n    public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException;\n}\n/**\n * Default {@link ValueInstantiator} implementation, which supports\n * Creator methods that can be indicated by standard Jackson\n * annotations.\n */\npublic class StdValueInstantiator\n    extends ValueInstantiator\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @deprecated Since 2.7 call either {@link #unwrapAndWrapException} or\n     *  {@link #wrapAsJsonMappingException}\n     */\n    @Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t);\n}\n/**\n * Class that defines API used by {@link ObjectMapper} and\n * {@link JsonSerializer}s to obtain serializers capable of serializing\n * instances of specific types; as well as the default implementation\n * of the functionality.\n *<p>\n * Provider handles caching aspects of serializer handling; all construction\n * details are delegated to {@link SerializerFactory} instance.\n *<p>\n * Object life-cycle is such that an initial instance (\"blueprint\") is created\n * and referenced by {@link ObjectMapper} and {@link ObjectWriter} intances;\n * but for actual usage, a configured instance is created by using\n * a create method in sub-class\n * {@link com.fasterxml.jackson.databind.ser.DefaultSerializerProvider}.\n * Only this instance can be used for actual serialization calls; blueprint\n * object is only to be used for creating instances.\n */\npublic abstract class SerializerProvider\n    extends DatabindContext\n{\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException;\n    /**\n     * Method that will try to construct a value serializer; and if\n     * one is successfully created, cache it for reuse.\n     */\n    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException;\n}\n/**\n * Standard implementation used by {@link ObjectMapper}:\n * adds methods only exposed to {@link ObjectMapper},\n * as well as constructors.\n *<p>\n * Note that class is abstract just because it does not\n * define {@link #createInstance} method.\n *<p>\n * Also note that all custom {@link SerializerProvider}\n * implementations must sub-class this class: {@link ObjectMapper}\n * requires this type, not basic provider type.\n */\npublic abstract class DefaultSerializerProvider\n    extends SerializerProvider\n    implements java.io.Serializable // since 2.1; only because ObjectWriter needs it\n{\n    private static final long serialVersionUID = 1L;\n    private IOException _wrapAsIOE(JsonGenerator g, Exception e);\n    @Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException;\n}\n/**\n * Checked exception used to signal fatal problems with mapping of\n * content, distinct from low-level I/O problems (signaled using\n * simple {@link java.io.IOException}s) or data encoding/decoding\n * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},\n * {@link com.fasterxml.jackson.core.JsonGenerationException}).\n *<p>\n * One additional feature is the ability to denote relevant path\n * of references (during serialization/deserialization) to help in\n * troubleshooting.\n */\npublic class JsonMappingException\n    extends JsonProcessingException\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method is overridden so that we can properly inject description\n     * of problem path, if such is defined.\n     */\n    @Override\n    public String getMessage();\n    /**\n     * @since 2.7\n     */\n    public static JsonMappingException from(JsonParser p, String msg);\n    /**\n     * Method that can be called to either create a new JsonMappingException\n     * (if underlying exception is not a JsonMappingException), or augment\n     * given exception with given path/reference information.\n     */\n    @SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref);\n    /**\n     * Factory method used when \"upgrading\" an {@link IOException} into\n     * {@link JsonMappingException}: usually only needed to comply with\n     * a signature.\n     *<p>\n     * NOTE: since 2.9 should usually NOT be used on input-side (deserialization)\n     *    exceptions; instead use method(s) of <code>InputMismatchException</code>\n     * \n     * @since 2.1\n     */\n    public static JsonMappingException fromUnexpectedIOE(IOException src);\n}\n/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public final static int TYPE_BYTE_ARRAY = 17; // since 2.9\n    protected double _parseDouble(String key) throws IllegalArgumentException;\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException;\n}\n/**\n * Base class for common deserializers. Contains shared\n * base functionality for dealing with primitive values, such\n * as (re)parsing from String.\n */\npublic abstract class StdDeserializer<T>\n    extends JsonDeserializer<T>\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.8\n     */\n    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException;\n}\n/**\n * Default {@link BeanDescription} implementation used by Jackson.\n *<p>\n * Although sub-classing is a theoretical possibility there are no known\n * use cases for that, nor is such usage tested or supported.\n * Separation from API is mostly to isolate some implementation details\n * here and keep API simple.\n */\npublic class BasicBeanDescription extends BeanDescription\n{\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    @Override\n    public Object instantiateBean(boolean fixAccess);\n}\n/**\n * Base class for deserializable properties of a bean: contains\n * both type and name definitions, and reflection-based set functionality.\n * Concrete sub-classes implement details, so that field- and\n * setter-backed properties, as well as a few more esoteric variations,\n * can be handled.\n */\npublic abstract class SettableBeanProperty\n    extends ConcreteBeanPropertyBase\n    implements java.io.Serializable\n{\n    /**\n     * Method that takes in exception of any type, and casts or wraps it\n     * to an IOException or its subclass.\n     */\n    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException;\n    /**\n     * @since 2.7\n     */\n    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException;\n}\n/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n/**\n * Context for the process of deserialization a single root-level value.\n * Used to allow passing in configuration settings and reusable temporary\n * objects (scrap arrays, containers).\n *<p>\n * Instance life-cycle is such that a partially configured \"blueprint\" object\n * is registered with {@link ObjectMapper} (and {@link ObjectReader},\n * and when actual instance is needed for deserialization,\n * a fully configured instance will be created using a method in extended internal\n *  API of sub-class\n * ({@link com.fasterxml.jackson.databind.deser.DefaultDeserializationContext#createInstance}).\n * Each instance is guaranteed to only be used from single-threaded context;\n * instances may be reused if (and only if) no configuration has changed.\n *<p>\n * Defined as abstract class so that implementations must define methods\n * for reconfiguring blueprints and creating instances.\n */\npublic abstract class DeserializationContext\n    extends DatabindContext\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L; // 2.6\n    /**\n     * @since 2.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType type) throws IOException;\n    public JsonMappingException instantiationException(Class<?> instClass, Throwable cause);\n    /**\n     * Convenience method for parsing a Date from given String, using\n     * currently configured date format (accessed using\n     * {@link DeserializationConfig#getDateFormat()}).\n     *<p>\n     * Implementation will handle thread-safety issues related to\n     * date formats such that first time this method is called,\n     * date format is cloned, and cloned instance will be retained\n     * for use during this deserialization round.\n     */\n    public Date parseDate(String dateStr) throws IllegalArgumentException;\n    /**\n     * Convenience method that may be used by composite or container deserializers,\n     * for reading one-off values contained (for sequences, it is more efficient\n     * to actually fetch deserializer once for the whole collection).\n     *<p>\n     * NOTE: when deserializing values of properties contained in composite types,\n     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};\n     * this method does not allow use of contextual annotations.\n     * \n     * @since 2.4\n     */\n    public <T> T readValue(JsonParser p, Class<T> type) throws IOException;\n}\npublic final class ClassUtil\n{\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Annotation[] NO_ANNOTATIONS = new Annotation[0];\n    private final static Ctor[] NO_CTORS = new Ctor[0];\n    private final static Iterator<?> EMPTY_ITERATOR = Collections.emptyIterator();\n    /**\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Iterator<T> emptyIterator();\n    /**\n     * Returns either `text` or [null].\n     *\n     * @since 2.9\n     */\n    public static String backticked(String text);\n}\n/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Method for constructing a bean deserializer that uses specified\n     * intermediate Builder for binding data, and construction of the\n     * value instance.\n     * Note that implementation is mostly copied from the regular\n     * BeanDeserializer build method.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException;\n    /**\n     * Method that is to actually build a bean deserializer instance.\n     * All basic sanity checks have been done to know that what we have\n     * may be a valid bean type, and that there are no default simple\n     * deserializers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n/**\n * Class that represents a \"wildcard\" set method which can be used\n * to generically set values of otherwise unmapped (aka \"unknown\")\n * properties read from Json content.\n *<p>\n * !!! Note: might make sense to refactor to share some code\n * with {@link SettableBeanProperty}?\n */\npublic class SettableAnyProperty\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @param e Exception to re-throw or wrap\n     * @param propName Name of property (from Json input) to set\n     * @param value Value of the property\n     */\n    protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException;\n}\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**********************************************************\n     */\n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testLocationAddition() throws Exception\n    {\n        try {\n            /*Map<?,?> map =*/ MAPPER.readValue(\"{\\\"value\\\":\\\"foo\\\"}\",\n                    new TypeReference<Map<ABC, Integer>>() { });\n            fail(\"Should not pass\");\n        } catch (MismatchedInputException e) {\n            String msg = e.getMessage();\n            String[] str = msg.split(\" at \\\\[\");\n            if (str.length != 2) {\n                fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    protected void _format(TimeZone tz, Locale loc, Date date,\n            StringBuffer buffer);\n    @Override\n    public void setTimeZone(TimeZone tz);\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone();\n    private static void pad4(StringBuffer buffer, int value);\n    /**********************************************************\n     */\n\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    protected void _format(TimeZone tz, Locale loc, Date date,\n            StringBuffer buffer);\n    @Override\n    public void setTimeZone(TimeZone tz);\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone();\n    private static void pad4(StringBuffer buffer, int value);\n    /**********************************************************\n     */\n\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private static Date judate(int year, int month, int day, int hour, int minutes, int seconds, int millis, String tz) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(year, month-1, day, hour, minutes, seconds);\n        cal.set(Calendar.MILLISECOND, millis);\n        cal.setTimeZone(TimeZone.getTimeZone(tz));\n\n        return cal.getTime();\n    }\n    private void serialize(ObjectMapper mapper, Object date, String expected) throws IOException {\n        Assert.assertEquals(quote(expected), mapper.writeValueAsString(date));\n    }\n    private void serialize(ObjectWriter w, Object date, String expected) throws IOException {\n        Assert.assertEquals(quote(expected), w.writeValueAsString(date));\n    }\n    public void testDateISO8601_10k() throws IOException\n    {\n        ObjectWriter w = MAPPER.writer()\n                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, \"UTC\"),   \"+10204-01-01T00:00:00.000+0000\");\n        // and although specification lacks for beyond 5 digits (well, actually even 5...), let's do our best:\n        serialize(w, judate(123456, 1, 1,  00, 00, 00, 0, \"UTC\"),   \"+123456-01-01T00:00:00.000+0000\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Container class that contains serializers for JDK types that\n * require special handling for some reason.\n */\npublic class JdkDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Container class that contains serializers for JDK types that\n * require special handling for some reason.\n */\npublic class JdkDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n    public static JsonDeserializer<?> find(Class<?> rawType, String clsName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private void _testEmptyToNullCoercion(Class<?> primType, Object emptyValue) throws Exception\n    {\n        final String EMPTY = \"\\\"\\\"\";\n\n        // as per [databind#1095] should only allow coercion from empty String,\n        // if `null` is acceptable\n        ObjectReader intR = MAPPER.readerFor(primType);\n        assertEquals(emptyValue, intR.readValue(EMPTY));\n        try {\n            intR.with(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n                .readValue(\"\\\"\\\"\");\n            fail(\"Should not have passed\");\n        } catch (MismatchedInputException e) {\n            verifyException(e, \"Cannot coerce empty String\");\n        }\n    }\n    private void _verifyEmptyStringFailForPrimitives(String propName) throws IOException\n    {\n        final ObjectReader reader = MAPPER\n                .readerFor(PrimitivesBean.class)\n                .with(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);\n        try {\n            reader.readValue(aposToQuotes(\"{'\"+propName+\"':''}\"));\n            fail(\"Expected failure for boolean + empty String\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Cannot coerce empty String (\\\"\\\")\");\n            verifyException(e, \"to Null value\");\n        }\n    }\n    private void verifyPath(MismatchedInputException e, String propName) {\n        final List<Reference> path = e.getPath();\n        assertEquals(1, path.size());\n        assertEquals(propName, path.get(0).getFieldName());\n    }\n    private void _testNullForPrimitiveArrays(Class<?> cls, Object defValue) throws IOException {\n        _testNullForPrimitiveArrays(cls, defValue, true);\n    }\n    private void _testNullForPrimitiveArrays(Class<?> cls, Object defValue,\n            boolean testEmptyString) throws IOException\n    {\n        final String EMPTY_STRING_JSON = \"[ \\\"\\\" ]\";\n        final String JSON_WITH_NULL = \"[ null ]\";\n        final String SIMPLE_NAME = \"`\"+cls.getSimpleName()+\"`\";\n        final ObjectReader readerCoerceOk = MAPPER.readerFor(cls);\n        final ObjectReader readerNoCoerce = readerCoerceOk\n                .with(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);\n\n        Object ob = readerCoerceOk.forType(cls).readValue(JSON_WITH_NULL);\n        assertEquals(1, Array.getLength(ob));\n        assertEquals(defValue, Array.get(ob, 0));\n        try {\n            readerNoCoerce.readValue(JSON_WITH_NULL);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Cannot coerce `null`\");\n            verifyException(e, \"as content of type \"+SIMPLE_NAME);\n        }\n        \n        if (testEmptyString) {\n            ob = readerCoerceOk.forType(cls).readValue(EMPTY_STRING_JSON);\n            assertEquals(1, Array.getLength(ob));\n            assertEquals(defValue, Array.get(ob, 0));\n\n            try {\n                readerNoCoerce.readValue(EMPTY_STRING_JSON);\n                fail(\"Should not pass\");\n            } catch (JsonMappingException e) {\n                verifyException(e, \"Cannot coerce empty String (\\\"\\\")\");\n                verifyException(e, \"as content of type \"+SIMPLE_NAME);\n            }\n        }\n    }\n    private void _testInvalidStringCoercionFail(Class<?> cls) throws IOException\n    {\n        final String JSON = \"[ \\\"foobar\\\" ]\";\n        final String SIMPLE_NAME = cls.getSimpleName();\n\n        try {\n            MAPPER.readerFor(cls).readValue(JSON);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Cannot deserialize value of type `\"+SIMPLE_NAME+\"` from String \\\"foobar\\\"\");\n        }\n    }\n    public void testVoidDeser() throws Exception\n    {\n        VoidBean bean = MAPPER.readValue(aposToQuotes(\"{'value' : 123 }\"),\n                VoidBean.class);\n        assertNull(bean.value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n * accessing contents of JSON tree in alternate form (stream of tokens).\n * Useful when a streaming source is expected by code, such as data binding\n * functionality.\n */\npublic class TreeTraversingParser extends ParserMinimalBase\n{\n    @Override\n    public long getLongValue() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    @Override\n    public float getFloatValue() throws IOException;\n    /**********************************************************\n     */\n\n    //public byte getByteValue() throws IOException\n\n    @Override\n    public NumberType getNumberType() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n * accessing contents of JSON tree in alternate form (stream of tokens).\n * Useful when a streaming source is expected by code, such as data binding\n * functionality.\n */\npublic class TreeTraversingParser extends ParserMinimalBase\n{\n    @Override\n    public long getLongValue() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException;\n    @Override\n    public float getFloatValue() throws IOException;\n    /**********************************************************\n     */\n\n    //public byte getByteValue() throws IOException\n\n    @Override\n    public NumberType getNumberType() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testNumberOverflowLong() throws IOException\n    {\n        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);\n        try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig+\" ]\").traverse()) {\n            assertToken(JsonToken.START_ARRAY, p.nextToken());\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n            try {\n                p.getLongValue();\n                fail(\"Expected failure for `long` overflow\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"Numeric value (\"+tooBig+\") out of range of long\");\n            }\n        }\n        try (final JsonParser p = MAPPER.readTree(\"{ \\\"value\\\" : \"+tooBig+\" }\").traverse()) {\n            assertToken(JsonToken.START_OBJECT, p.nextToken());\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n            try {\n                p.getLongValue();\n                fail(\"Expected failure for `long` overflow\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"Numeric value (\"+tooBig+\") out of range of long\");\n            }\n        }\n        // But also from floating-point\n        final String tooBig2 = \"1.0e30\";\n        try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig2+\" ]\").traverse()) {\n            assertToken(JsonToken.START_ARRAY, p.nextToken());\n            assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n            assertEquals(NumberType.DOUBLE, p.getNumberType());\n            try {\n                p.getLongValue();\n                fail(\"Expected failure for `long` overflow\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"Numeric value (\"+tooBig2+\") out of range of long\");\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testWithDeserializationProblemHandler() throws Exception {\n        final ObjectMapper mapper = new ObjectMapper()\n                .enableDefaultTyping();\n        mapper.addHandler(new DeserializationProblemHandler() {\n            @Override\n            public JavaType handleUnknownTypeId(DeserializationContext ctxt, JavaType baseType, String subTypeId, TypeIdResolver idResolver, String failureMsg) throws IOException { //                System.out.println(\"Print out a warning here\"); return ctxt.constructType(Void.class);\n            }\n        });\n        GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);\n        assertNotNull(processableContent.getInnerObjects());\n        assertEquals(2, processableContent.getInnerObjects().size());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"mutant factory\" pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n *<p>\n * NOTE: this class is NOT meant as sub-classable (with Jackson 2.8 and\n * above) by users. It is left as non-final mostly to allow frameworks\n * that require bytecode generation for proxying and similar use cases,\n * but there is no expecation that functionality should be extended\n * by sub-classing.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 2L; // since 2.9\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    private final TokenFilter _filter;\n    /**\n     * Same as {@link #readTree(InputStream)} except content read using\n     * passed-in {@link DataInput}.\n     */\n    public JsonNode readTree(DataInput src) throws IOException;\n    /**\n     * Same as {@link #readTree(InputStream)} except content accessed through\n     * passed-in {@link Reader}\n     */\n    public JsonNode readTree(Reader r) throws IOException;\n    /**\n     * @since 2.1\n     */\n    @Override\n    public JsonFactory getFactory();\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in byte array.\n     */\n    public JsonNode readTree(byte[] json, int offset, int len) throws IOException;\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in {@link String}\n     */\n    public JsonNode readTree(String json) throws IOException;\n    protected final JsonNode _bindAsTree(JsonParser p) throws IOException;\n    @Override\n    public JsonParser treeAsTokens(TreeNode n);\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in byte array.\n     */\n    public JsonNode readTree(byte[] json) throws IOException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or {@code null} if no more content is accessible\n     * via passed {@link JsonParser}.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and all other methods that take input source: latter\n     * will return \"missing node\", NOT {@code null}\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException;\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"mutant factory\" pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n *<p>\n * NOTE: this class is NOT meant as sub-classable (with Jackson 2.8 and\n * above) by users. It is left as non-final mostly to allow frameworks\n * that require bytecode generation for proxying and similar use cases,\n * but there is no expecation that functionality should be extended\n * by sub-classing.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 2L; // since 2.9\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    private final TokenFilter _filter;\n    /**\n     * Same as {@link #readTree(InputStream)} except content read using\n     * passed-in {@link DataInput}.\n     */\n    public JsonNode readTree(DataInput src) throws IOException;\n    /**\n     * Same as {@link #readTree(InputStream)} except content accessed through\n     * passed-in {@link Reader}\n     */\n    public JsonNode readTree(Reader r) throws IOException;\n    /**\n     * @since 2.1\n     */\n    @Override\n    public JsonFactory getFactory();\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in byte array.\n     */\n    public JsonNode readTree(byte[] json, int offset, int len) throws IOException;\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in {@link String}\n     */\n    public JsonNode readTree(String json) throws IOException;\n    protected final JsonNode _bindAsTree(JsonParser p) throws IOException;\n    @Override\n    public JsonParser treeAsTokens(TreeNode n);\n    /**\n     * Same as {@link #readTree(InputStream)} except content read from\n     * passed-in byte array.\n     */\n    public JsonNode readTree(byte[] json) throws IOException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or {@code null} if no more content is accessible\n     * via passed {@link JsonParser}.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and all other methods that take input source: latter\n     * will return \"missing node\", NOT {@code null}\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException;\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _assertNullTree(TreeNode n) {\n        if (n != null) {\n            fail(\"Should get `null` for reads with `JsonParser`, instead got: \"+n.getClass().getName());\n        }\n    }\n    private void _assertMissing(JsonNode n) {\n        assertNotNull(\"Should not get `null` but `MissingNode`\", n);\n        if (!n.isMissingNode()) {\n            fail(\"Should get `MissingNode` but got: \"+n.getClass().getName());\n        }\n    }\n    public void testNullFromEOFWithParserAndReader() throws Exception\n    {\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY0))) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(new StringReader(EMPTY1))) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0_BYTES)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY1_BYTES, 0, EMPTY1_BYTES.length)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n\n        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY0_BYTES))) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n        try (JsonParser p = MAPPER.getFactory().createParser(new ByteArrayInputStream(EMPTY1_BYTES))) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n    implements ContextualSerializer\n{\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException;\n}\n/**\n * Container class for serializers used for handling standard JDK-provided\n * primitve number types and their wrapper counterparts (like {@link java.lang.Integer}).\n */\npublic class NumberSerializers {\n    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n    implements ContextualSerializer\n{\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider prov,\n            BeanProperty property) throws JsonMappingException;\n}\n/**\n * Container class for serializers used for handling standard JDK-provided\n * primitve number types and their wrapper counterparts (like {@link java.lang.Integer}).\n */\npublic class NumberSerializers {\n    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testBigIntegerAsPlainTest() throws Exception\n    {\n        final String NORM_VALUE = \"0.0000000005\";\n        final BigDecimal BD_VALUE = new BigDecimal(NORM_VALUE);\n        final BigDecimalAsString INPUT = new BigDecimalAsString(BD_VALUE);\n        // by default, use the default `toString()`\n        assertEquals(\"{\\\"value\\\":\\\"\"+BD_VALUE.toString()+\"\\\"}\", MAPPER.writeValueAsString(INPUT));\n\n        // but can force to \"plain\" notation\n        final ObjectMapper m = jsonMapperBuilder()\n            .enable(StreamWriteFeature.WRITE_BIGDECIMAL_AS_PLAIN)\n            .build();\n        assertEquals(\"{\\\"value\\\":\\\"\"+NORM_VALUE+\"\\\"}\", m.writeValueAsString(INPUT));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructType(Type type, JavaType context);\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context);\n    public JavaType constructType(Type type, Class<?> context);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance()  return instance; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructType(Type type, JavaType context);\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context);\n    public JavaType constructType(Type type, Class<?> context);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance()  return instance; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testLocalType728() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m = Issue728.class.getMethod(\"method\", CharSequence.class);\n        assertNotNull(m);\n\n        // Start with return type\n        // first type-erased\n        JavaType t = tf.constructType(m.getReturnType());\n        assertEquals(CharSequence.class, t.getRawClass());\n        // then generic\n        t = tf.constructType(m.getGenericReturnType());\n        assertEquals(CharSequence.class, t.getRawClass());\n\n        // then parameter type\n        t = tf.constructType(m.getParameterTypes()[0]);\n        assertEquals(CharSequence.class, t.getRawClass());\n        t = tf.constructType(m.getGenericParameterTypes()[0]);\n        assertEquals(CharSequence.class, t.getRawClass());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used to contain logic for deserializing \"special\" containers\n * from {@code java.util.Collections} and {@code java.util.Arrays}. This is needed\n * because they do not have usable no-arguments constructor: however, are easy enough\n * to deserialize using delegating deserializer.\n *\n * @since 2.9.4\n */\npublic abstract class JavaUtilCollectionsDeserializers\n{\n    private final static int TYPE_SINGLETON_SET = 1;\n    private final static int TYPE_SINGLETON_LIST = 2;\n    private final static int TYPE_SINGLETON_MAP = 3;\n    private final static int TYPE_UNMODIFIABLE_SET = 4;\n    private final static int TYPE_UNMODIFIABLE_LIST = 5;\n    private final static int TYPE_UNMODIFIABLE_MAP = 6;\n    public final static int TYPE_AS_LIST = 7;\n    private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass();\n    private final static Class<?> CLASS_SINGLETON_SET;\n    private final static Class<?> CLASS_SINGLETON_LIST;\n    private final static Class<?> CLASS_SINGLETON_MAP;\n    private final static Class<?> CLASS_UNMODIFIABLE_SET;\n    private final static Class<?> CLASS_UNMODIFIABLE_LIST;\n    private final static Class<?> CLASS_UNMODIFIABLE_MAP;\n    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used to contain logic for deserializing \"special\" containers\n * from {@code java.util.Collections} and {@code java.util.Arrays}. This is needed\n * because they do not have usable no-arguments constructor: however, are easy enough\n * to deserialize using delegating deserializer.\n *\n * @since 2.9.4\n */\npublic abstract class JavaUtilCollectionsDeserializers\n{\n    private final static int TYPE_SINGLETON_SET = 1;\n    private final static int TYPE_SINGLETON_LIST = 2;\n    private final static int TYPE_SINGLETON_MAP = 3;\n    private final static int TYPE_UNMODIFIABLE_SET = 4;\n    private final static int TYPE_UNMODIFIABLE_LIST = 5;\n    private final static int TYPE_UNMODIFIABLE_MAP = 6;\n    public final static int TYPE_AS_LIST = 7;\n    private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass();\n    private final static Class<?> CLASS_SINGLETON_SET;\n    private final static Class<?> CLASS_SINGLETON_LIST;\n    private final static Class<?> CLASS_SINGLETON_MAP;\n    private final static Class<?> CLASS_UNMODIFIABLE_SET;\n    private final static Class<?> CLASS_UNMODIFIABLE_LIST;\n    private final static Class<?> CLASS_UNMODIFIABLE_MAP;\n    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n   public void testUnmodifiableListFromLinkedList() throws Exception {\n       final List<String> input = new LinkedList<>();\n       input.add(\"first\");\n       input.add(\"second\");\n\n       // Can't use simple \"_verifyCollection\" as type may change; instead use\n       // bit more flexible check:\n       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input));\n       assertEquals(input, act);\n\n       // and this check may be bit fragile (may need to revisit), but is good enough for now:\n       assertEquals(Collections.unmodifiableList(new ArrayList<>(input)).getClass(), act.getClass());\n   }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements property that is set\n * directly assigning to a Field.\n */\npublic final class FieldProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements property that is set\n * using regular \"setter\" method.\n */\npublic final class MethodProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\npublic class ObjectIdReferenceProperty extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    private final SettableBeanProperty _forward;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\npublic class AtomicReferenceDeserializer\n    extends ReferenceTypeDeserializer<AtomicReference<Object>>\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser);\n}\n/**\n * This concrete sub-class implements property that is passed\n * via Creator (constructor or static factory method).\n * It is not a full-featured implementation in that its set method\n * should usually not be called for primary mutation -- instead, value must separately passed --\n * but some aspects are still needed (specifically, injection).\n *<p>\n * Note on injectable values: unlike with other mutators, where\n * deserializer and injecting are separate, here we treat the two as related\n * things. This is necessary to add proper priority, as well as to simplify\n * coordination.\n */\npublic class CreatorProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements Collection or Map property that is\n * indirectly by getting the property value and directly modifying it.\n */\npublic final class SetterlessProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements property that is set\n * directly assigning to a Field.\n */\npublic final class FieldProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements property that is set\n * using regular \"setter\" method.\n */\npublic final class MethodProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\npublic class ObjectIdReferenceProperty extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    private final SettableBeanProperty _forward;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\npublic class AtomicReferenceDeserializer\n    extends ReferenceTypeDeserializer<AtomicReference<Object>>\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser);\n}\n/**\n * This concrete sub-class implements property that is passed\n * via Creator (constructor or static factory method).\n * It is not a full-featured implementation in that its set method\n * should usually not be called for primary mutation -- instead, value must separately passed --\n * but some aspects are still needed (specifically, injection).\n *<p>\n * Note on injectable values: unlike with other mutators, where\n * deserializer and injecting are separate, here we treat the two as related\n * things. This is necessary to add proper priority, as well as to simplify\n * coordination.\n */\npublic class CreatorProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n/**\n * This concrete sub-class implements Collection or Map property that is\n * indirectly by getting the property value and directly modifying it.\n */\npublic final class SetterlessProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.databind.BaseMapTest\n{\n    public void testNullWithinNested() throws Exception\n    {\n        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);\n        MyBean2303 intRef = r.readValue(\" {\\\"refRef\\\": 2 } \");\n        assertNotNull(intRef.refRef);\n        assertNotNull(intRef.refRef.get());\n        assertEquals(intRef.refRef.get().get(), new Integer(2));\n\n        MyBean2303 nullRef = r.readValue(\" {\\\"refRef\\\": null } \");\n        assertNotNull(nullRef.refRef);\n        assertNotNull(nullRef.refRef.get());\n        assertNull(nullRef.refRef.get().get());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specifically optimized version for {@link java.util.Collection}s\n * that contain String values; reason is that this is a very common\n * type and we can make use of the fact that Strings are final.\n */\npublic final class StringCollectionDeserializer\n    extends ContainerDeserializerBase<Collection<String>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specifically optimized version for {@link java.util.Collection}s\n * that contain String values; reason is that this is a very common\n * type and we can make use of the fact that Strings are final.\n */\npublic final class StringCollectionDeserializer\n    extends ContainerDeserializerBase<Collection<String>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDeserializeBagOfStrings() throws Exception {\n        WithBagOfStrings result = MAPPER.readerFor(WithBagOfStrings.class)\n                .readValue(\"{\\\"strings\\\": [ \\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n        assertEquals(3, result.getStrings().size());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Basic serializer that can take JSON \"Object\" structure and\n * construct a {@link java.util.Map} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.Map}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\npublic class MapDeserializer\n    extends ContainerDeserializerBase<Map<Object,Object>>\n    implements ContextualDeserializer, ResolvableDeserializer\n{\n    private static final long serialVersionUID = -3378654289961736240L;\n    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Basic serializer that can take JSON \"Object\" structure and\n * construct a {@link java.util.Map} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.Map}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\npublic class MapDeserializer\n    extends ContainerDeserializerBase<Map<Object,Object>>\n    implements ContextualDeserializer, ResolvableDeserializer\n{\n    private static final long serialVersionUID = -3378654289961736240L;\n    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testCustomMapValueDeser735() throws Exception {\n        String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n        TestMapBean735 bean = MAPPER.readValue(json, TestMapBean735.class);\n\n        assertEquals(100, bean.map1.get(\"a\").intValue());\n        assertEquals(1, bean.map2.get(\"a\").intValue());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Complete {@link DeserializationContext} implementation that adds\n * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n * to call, as well as implements certain parts that base class\n * has left abstract.\n * The remaining abstract methods ({@link #createInstance}, {@link #with})\n * are left so that custom implementations will properly implement them\n * to return intended subtype.\n */\npublic abstract class DefaultDeserializationContext\n    extends DeserializationContext\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L;\n    private List<ObjectIdResolver> _objectIdResolvers;\n    /**********************************************************\n     */\n\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType);\n}\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Complete {@link DeserializationContext} implementation that adds\n * extended API for {@link ObjectMapper} (and {@link ObjectReader})\n * to call, as well as implements certain parts that base class\n * has left abstract.\n * The remaining abstract methods ({@link #createInstance}, {@link #with})\n * are left so that custom implementations will properly implement them\n * to return intended subtype.\n */\npublic abstract class DefaultDeserializationContext\n    extends DeserializationContext\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L;\n    private List<ObjectIdResolver> _objectIdResolvers;\n    /**********************************************************\n     */\n\n    @Override\n    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType);\n}\n/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Object deserializeSetAndReturn(JsonParser jp,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void assertEmployees(Employee firstEmployee, Employee secondEmployee)\n    {\n        assertEquals(1, firstEmployee.id);\n        assertEquals(2, secondEmployee.id);\n        assertEquals(1, firstEmployee.reports.size());\n        assertSame(secondEmployee, firstEmployee.reports.get(0)); // Ensure that forward reference was properly resolved and in order.\n        assertSame(firstEmployee, secondEmployee.manager); // And that back reference is also properly resolved.\n    }\n    public void testNullObjectId() throws Exception\n    {\n        // Ok, so missing Object Id is ok, but so is null.\n        \n        Identifiable value = MAPPER.readValue\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), Identifiable.class);\n        assertNotNull(value);\n        assertEquals(3, value.value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"fluent\" (or, kind of, builder) pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException;\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException;\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"fluent\" (or, kind of, builder) pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    protected JsonNode _bindAsTree(JsonParser jp) throws IOException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException;\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException;\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue744() throws IOException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        SimpleModule module = new SimpleModule();\n        module.addDeserializer(DataA.class, new DataADeserializer());\n        mapper.registerModule(module);\n\n        DataB db = new DataB();\n        db.da.i = 11;\n        db.k = 13;\n        String jsonBString = mapper.writeValueAsString(db);\n        JsonNode jsonBNode = mapper.valueToTree(db);\n\n        // create parent\n        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n        assertEquals(5, dbNewViaString.da.i);\n        assertEquals(13, dbNewViaString.k);\n\n        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n        assertEquals(5, dbNewViaNode.da.i);\n        assertEquals(13, dbNewViaNode.k);\n\n        // update parent\n        DataB dbUpdViaString = new DataB();\n        DataB dbUpdViaNode = new DataB();\n\n        assertEquals(1, dbUpdViaString.da.i);\n        assertEquals(3, dbUpdViaString.k);\n        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n        assertEquals(5, dbUpdViaString.da.i);\n        assertEquals(13, dbUpdViaString.k);\n\n        assertEquals(1, dbUpdViaNode.da.i);\n        assertEquals(3, dbUpdViaNode.k);\n        \n        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n        assertEquals(5, dbUpdViaNode.da.i);\n        assertEquals(13, dbUpdViaNode.k);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Serializer implementation where given Java type is first converted\n * to an intermediate \"delegate type\" (using a configured\n * {@link Converter}, and then this delegate value is serialized by Jackson.\n *<p>\n * Note that although types may be related, they must not be same; trying\n * to do this will result in an exception.\n *\n * @since 2.1\n */\npublic class StdDelegatingSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value);\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException;\n    /**********************************************************\n     */\n\n    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException;\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException;\n    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException;\n    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value);\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException;\n}\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException;\n}\n/**\n * Base class used by all standard serializers, and can also\n * be used for custom serializers (in fact, this is the recommended\n * base class to use).\n * Provides convenience methods for implementing {@link SchemaAware}\n */\npublic abstract class StdSerializer<T>\n    extends JsonSerializer<T>\n    implements JsonFormatVisitable, SchemaAware, java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Helper method that can be used to see if specified property has annotation\n     * indicating that a converter is to be used for contained values (contents\n     * of structured types; array/List/Map values)\n     * \n     * @param existingSerializer (optional) configured content\n     *    serializer if one already exists.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException;\n}\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * @return True if type is either true {@link java.util.Map} type,\n     *    or something similar (meaning it has at least two type parameter;\n     *    first one describing key type, second value type)\n     */\n    @Override\n    public boolean isMapLikeType()  return false; };\n}\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Serializer implementation where given Java type is first converted\n * to an intermediate \"delegate type\" (using a configured\n * {@link Converter}, and then this delegate value is serialized by Jackson.\n *<p>\n * Note that although types may be related, they must not be same; trying\n * to do this will result in an exception.\n *\n * @since 2.1\n */\npublic class StdDelegatingSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    @Override\n    public boolean isEmpty(SerializerProvider prov, Object value);\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n        throws JsonMappingException;\n    /**********************************************************\n     */\n\n    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException;\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n        throws JsonMappingException;\n    @Override\n    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer) throws IOException;\n    @Override\n    @Deprecated // since 2.5\n    public boolean isEmpty(Object value);\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n        throws JsonMappingException;\n}\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    /**\n     * Helper method that can be used to see if specified property is annotated\n     * to indicate use of a converter for property value (in case of container types,\n     * it is container type itself, not key or content type).\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,\n            BeanPropertyWriter prop)\n        throws JsonMappingException;\n}\n/**\n * Base class used by all standard serializers, and can also\n * be used for custom serializers (in fact, this is the recommended\n * base class to use).\n * Provides convenience methods for implementing {@link SchemaAware}\n */\npublic abstract class StdSerializer<T>\n    extends JsonSerializer<T>\n    implements JsonFormatVisitable, SchemaAware, java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Helper method that can be used to see if specified property has annotation\n     * indicating that a converter is to be used for contained values (contents\n     * of structured types; array/List/Map values)\n     * \n     * @param existingSerializer (optional) configured content\n     *    serializer if one already exists.\n     * \n     * @since 2.2\n     */\n    protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,\n            BeanProperty prop, JsonSerializer<?> existingSerializer)\n        throws JsonMappingException;\n}\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * @return True if type is either true {@link java.util.Map} type,\n     *    or something similar (meaning it has at least two type parameter;\n     *    first one describing key type, second value type)\n     */\n    @Override\n    public boolean isMapLikeType()  return false; };\n}\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    /**\n     * Main serializer constructor method. We will have to be careful\n     * with respect to ordering of various method calls: essentially\n     * we want to reliably figure out which classes are standard types,\n     * and which are beans. The problem is that some bean Classes may\n     * implement standard interfaces (say, {@link java.lang.Iterable}.\n     *<p>\n     * Note: sub-classes may choose to complete replace implementation,\n     * if they want to alter priority of serializer lookups.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n            JavaType origType)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.databind.BaseMapTest\n{\n    public void testIssue731() throws Exception\n    {\n        String json = objectWriter().writeValueAsString(new ConvertingBeanWithUntypedConverter(1, 2));\n        // must be  {\"a\":2,\"b\":4}\n        assertEquals(\"{\\\"a\\\":2,\\\"b\\\":4}\", json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple helper class used to keep track of collection of\n * Jackson Annotations associated with annotatable things\n * (methods, constructors, classes).\n * Note that only Jackson-owned annotations are tracked (for now?).\n */\npublic final class AnnotationMap implements Annotations\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple helper class used to keep track of collection of\n * Jackson Annotations associated with annotatable things\n * (methods, constructors, classes).\n * Note that only Jackson-owned annotations are tracked (for now?).\n */\npublic final class AnnotationMap implements Annotations\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testMixinWithBundles() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n        String result = mapper.writeValueAsString(new Foo(\"result\"));\n        assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This mapper (or, data binder, or codec) provides functionality for\n * converting between Java objects (instances of JDK provided core classes,\n * beans), and matching JSON constructs.\n * It will use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes.\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy();\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs);\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping();\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti);\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This mapper (or, data binder, or codec) provides functionality for\n * converting between Java objects (instances of JDK provided core classes,\n * beans), and matching JSON constructs.\n * It will use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes.\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy();\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs);\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping();\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti);\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * of implementation classes\n */\npublic class TestJsonNode extends NodeTestBase\n{\n    public void testArrayWithDefaultTyping() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .enableDefaultTyping();\n\n        JsonNode array = mapper.readTree(\"[ 1, 2 ]\");\n        assertTrue(array.isArray());\n        assertEquals(2, array.size());\n\n        JsonNode obj = mapper.readTree(\"{ \\\"a\\\" : 2 }\");\n        assertTrue(obj.isObject());\n        assertEquals(1, obj.size());\n        assertEquals(2, obj.path(\"a\").asInt());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Iterator exposed by {@link ObjectMapper} when binding sequence of\n * objects. Extension is done to allow more convenient exposing of\n * {@link IOException} (which basic {@link Iterator} does not expose)\n */\npublic class MappingIterator<T> implements Iterator<T>, Closeable\n{\n    @Override\n    public void remove();\n    @Override\n    public void close() throws IOException;\n    /**\n     * Convenience method, functionally equivalent to:\n     *<code>\n     *   iterator.getParser().getCurrentLocation()\n     *</code>\n     * \n     * @return Location of the input stream of the underlying parser\n     * \n     * @since 2.2.1\n     */\n    public JsonLocation getCurrentLocation();\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator();\n    public T nextValue() throws IOException;\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n     * \n     * @return List of entries read\n     * \n     * @since 2.2\n     */\n    public List<T> readAll() throws IOException;\n    /**\n     * Equivalent of {@link #next} but one that may throw checked\n     * exceptions from Jackson due to invalid input.\n     */\n    public boolean hasNextValue() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Iterator exposed by {@link ObjectMapper} when binding sequence of\n * objects. Extension is done to allow more convenient exposing of\n * {@link IOException} (which basic {@link Iterator} does not expose)\n */\npublic class MappingIterator<T> implements Iterator<T>, Closeable\n{\n    @Override\n    public void remove();\n    @Override\n    public void close() throws IOException;\n    /**\n     * Convenience method, functionally equivalent to:\n     *<code>\n     *   iterator.getParser().getCurrentLocation()\n     *</code>\n     * \n     * @return Location of the input stream of the underlying parser\n     * \n     * @since 2.2.1\n     */\n    public JsonLocation getCurrentLocation();\n    @SuppressWarnings(\"unchecked\")\n    protected static <T> MappingIterator<T> emptyIterator();\n    public T nextValue() throws IOException;\n    /**\n     * Convenience method for reading all entries accessible via\n     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n     * \n     * @return List of entries read\n     * \n     * @since 2.2\n     */\n    public List<T> readAll() throws IOException;\n    /**\n     * Equivalent of {@link #next} but one that may throw checked\n     * exceptions from Jackson due to invalid input.\n     */\n    public boolean hasNextValue() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSimpleRootRecovery() throws Exception\n    {\n        final String JSON = aposToQuotes(\"{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} \");\n\n        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);\n        Bean bean = it.nextValue();\n\n        assertNotNull(bean);\n        assertEquals(3, bean.a);\n\n        // second one problematic\n        try {\n            it.nextValue();\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Unrecognized field \\\"foo\\\"\");\n        }\n\n        // but should recover nicely\n        bean = it.nextValue();\n        assertNotNull(bean);\n        assertEquals(1, bean.a);\n        assertEquals(2, bean.b);\n\n        assertFalse(it.hasNextValue());\n        \n        it.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private JavaType _mapType(Class<?> rawClass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private JavaType _mapType(Class<?> rawClass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.databind.BaseMapTest\n{\n    public void testMapToProperties() throws Exception\n    {\n        Bean bean = new Bean();\n        bean.A = 129;\n        bean.B = \"13\";\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n        assertEquals(2, props.size());\n\n        assertEquals(\"13\", props.getProperty(\"B\"));\n        // should coercce non-Strings to Strings\n        assertEquals(\"129\", props.getProperty(\"A\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testConversionOfPojos() throws Exception\n    {\n        final Issue467Bean input = new Issue467Bean(13);\n        final String EXP = \"{\\\"x\\\":13}\";\n        \n        // first, sanity check\n        String json = MAPPER.writeValueAsString(input);\n        assertEquals(EXP, json);\n\n        // then via conversions: should become JSON Object\n        JsonNode tree = MAPPER.valueToTree(input);\n        assertTrue(\"Expected Object, got \"+tree.getNodeType(), tree.isObject());\n        assertEquals(EXP, MAPPER.writeValueAsString(tree));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Node that maps to JSON Object structures in JSON content.\n *<p>\n * Note: class was <code>final</code> temporarily for Jackson 2.2.\n */\npublic class ObjectNode\n    extends ContainerNode<ObjectNode>\n{\n    /**\n     * Method that will set specified field, replacing old value, if any.\n     * Note that this is identical to {@link #replace(String, JsonNode)},\n     * except for return value.\n     *<p>\n     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}\n     * where chaining with 'this' is desired.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *\n     * @return This node after adding/replacing property value (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode set(String fieldName, JsonNode value);\n    @Override\n    public JsonNode path(int index);\n    @Override\n    public int size();\n    @Override\n    protected JsonNode _at(JsonPointer ptr);\n    @Override\n    public JsonNode path(String fieldName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Node that maps to JSON Object structures in JSON content.\n *<p>\n * Note: class was <code>final</code> temporarily for Jackson 2.2.\n */\npublic class ObjectNode\n    extends ContainerNode<ObjectNode>\n{\n    /**\n     * Method that will set specified field, replacing old value, if any.\n     * Note that this is identical to {@link #replace(String, JsonNode)},\n     * except for return value.\n     *<p>\n     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}\n     * where chaining with 'this' is desired.\n     *\n     * @param value to set field to; if null, will be converted\n     *   to a {@link NullNode} first  (to remove field entry, call\n     *   {@link #remove} instead)\n     *\n     * @return This node after adding/replacing property value (to allow chaining)\n     *\n     * @since 2.1\n     */\n    public JsonNode set(String fieldName, JsonNode value);\n    @Override\n    public JsonNode path(int index);\n    @Override\n    public int size();\n    @Override\n    protected JsonNode _at(JsonPointer ptr);\n    @Override\n    public JsonNode path(String fieldName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testNamingWithObjectNode() throws Exception\n    {\n        ObjectMapper m = new ObjectMapper();\n        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\n        ClassWithObjectNodeField result =\n            m.readValue(\n                \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n                ClassWithObjectNodeField.class);\n        assertNotNull(result);\n        assertEquals(\"1\", result.id);\n        assertNotNull(result.json);\n        assertEquals(2, result.json.size());\n        assertEquals(\"bing\", result.json.path(\"baz\").asText());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Version version();\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Version version();\n    /**\n     * Annotations with meta-annotation {@link JacksonAnnotationsInside}\n     * are considered bundles.\n     */\n    @Override\n    public boolean isAnnotationBundle(Annotation ann);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testEnumWithJsonPropertyRename() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] {\n                EnumWithPropertyAnno.B, EnumWithPropertyAnno.A\n        });\n        assertEquals(\"[\\\"b\\\",\\\"a\\\"]\", json);\n\n        // and while not really proper place, let's also verify deser while we're at it\n        EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class);\n        assertNotNull(result);\n        assertEquals(2, result.length);\n        assertSame(EnumWithPropertyAnno.B, result[0]);\n        assertSame(EnumWithPropertyAnno.A, result[1]);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Factory class that can provide serializers for standard JDK classes,\n * as well as custom classes that extend standard classes or implement\n * one of \"well-known\" interfaces (such as {@link java.util.Collection}).\n *<p>\n * Since all the serializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is essentially stateless.\n */\npublic abstract class BasicSerializerFactory\n    extends SerializerFactory\n    implements java.io.Serializable\n{\n    /**\n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.List} types that support efficient by-index access\n     * \n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * <code>Object[]</code> (and subtypes, except for String).\n     */\n    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException;\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType);\n    /**\n     *<p>\n     * NOTE: although return type is left opaque, it really needs to be\n     * <code>JsonInclude.Include</code> for things to work as expected.\n     *\n     * @since 2.5\n     */\n    protected Object findSuppressableContentValue(SerializationConfig config,\n            JavaType contentType, BeanDescription beanDesc)\n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.Map} types.\n     */\n    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException;\n}\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Factory class that can provide serializers for standard JDK classes,\n * as well as custom classes that extend standard classes or implement\n * one of \"well-known\" interfaces (such as {@link java.util.Collection}).\n *<p>\n * Since all the serializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is essentially stateless.\n */\npublic abstract class BasicSerializerFactory\n    extends SerializerFactory\n    implements java.io.Serializable\n{\n    /**\n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.List} types that support efficient by-index access\n     * \n     * @since 2.1\n     */\n    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n            CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * <code>Object[]</code> (and subtypes, except for String).\n     */\n    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n            ArrayType type, BeanDescription beanDesc,\n            boolean staticTyping,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException;\n    public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType);\n    /**\n     *<p>\n     * NOTE: although return type is left opaque, it really needs to be\n     * <code>JsonInclude.Include</code> for things to work as expected.\n     *\n     * @since 2.5\n     */\n    protected Object findSuppressableContentValue(SerializationConfig config,\n            JavaType contentType, BeanDescription beanDesc)\n        throws JsonMappingException;\n    /**\n     * Helper method that handles configuration details when constructing serializers for\n     * {@link java.util.Map} types.\n     */\n    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n            MapType type, BeanDescription beanDesc,\n            boolean staticTyping, JsonSerializer<Object> keySerializer,\n            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n        throws JsonMappingException;\n}\n/**\n * Factory class that can provide serializers for any regular Java beans\n * (as defined by \"having at least one get method recognizable as bean\n * accessor\" -- where {@link Object#getClass} does not count);\n * as well as for \"standard\" JDK types. Latter is achieved\n * by delegating calls to {@link BasicSerializerFactory} \n * to find serializers both for \"standard\" JDK types (and in some cases,\n * sub-classes as is the case for collection classes like\n * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n * classes.\n *<p>\n * Note about delegating calls to {@link BasicSerializerFactory}:\n * although it would be nicer to use linear delegation\n * for construction (to essentially dispatch all calls first to the\n * underlying {@link BasicSerializerFactory}; or alternatively after\n * failing to provide bean-based serializer}, there is a problem:\n * priority levels for detecting standard types are mixed. That is,\n * we want to check if a type is a bean after some of \"standard\" JDK\n * types, but before the rest.\n * As a result, \"mixed\" delegation used, and calls are NOT done using\n * regular {@link SerializerFactory} interface but rather via\n * direct calls to {@link BasicSerializerFactory}.\n *<p>\n * Finally, since all caching is handled by the serializer provider\n * (not factory) and there is no configurability, this\n * factory is stateless.\n * This means that a global singleton instance can be used.\n */\npublic class BeanSerializerFactory\n    extends BasicSerializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testJsonValueWithCustomOverride() throws Exception\n    {\n        final Bean838 INPUT = new Bean838();\n\n        // by default, @JsonValue should be used\n        assertEquals(quote(\"value\"), MAPPER.writeValueAsString(INPUT));\n\n        // but custom serializer should override it\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerModule(new SimpleModule()\n            .addSerializer(Bean838.class, new Bean838Serializer())\n            );\n        assertEquals(\"42\", mapper.writeValueAsString(INPUT));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Container class for serializers used for handling standard JDK-provided types.\n */\npublic class NumberSerializers\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Container class for serializers used for handling standard JDK-provided types.\n */\npublic class NumberSerializers\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testEmptyInclusionScalars() throws IOException\n    {\n        ObjectMapper defMapper = MAPPER;\n        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\n\n        // First, Strings\n        StringWrapper str = new StringWrapper(\"\");\n        assertEquals(\"{\\\"str\\\":\\\"\\\"}\", defMapper.writeValueAsString(str));\n        assertEquals(\"{}\", inclMapper.writeValueAsString(str));\n        assertEquals(\"{}\", inclMapper.writeValueAsString(new StringWrapper()));\n\n        assertEquals(\"{\\\"value\\\":\\\"x\\\"}\", defMapper.writeValueAsString(new NonEmptyString(\"x\")));\n        assertEquals(\"{}\", defMapper.writeValueAsString(new NonEmptyString(\"\")));\n\n        // Then numbers\n        assertEquals(\"{\\\"value\\\":12}\", defMapper.writeValueAsString(new NonEmptyInt(12)));\n        assertEquals(\"{}\", defMapper.writeValueAsString(new NonEmptyInt(0)));\n\n        assertEquals(\"{\\\"value\\\":1.25}\", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));\n        assertEquals(\"{}\", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));\n\n        IntWrapper zero = new IntWrapper(0);\n        assertEquals(\"{\\\"i\\\":0}\", defMapper.writeValueAsString(zero));\n        assertEquals(\"{}\", inclMapper.writeValueAsString(zero));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Immutable container class used to store simple configuration\n * settings. Since instances are fully immutable, instances can\n * be freely shared and used without synchronization.\n */\npublic final class BaseSettings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public TimeZone getTimeZone();\n    public BaseSettings withDateFormat(DateFormat df);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Immutable container class used to store simple configuration\n * settings. Since instances are fully immutable, instances can\n * be freely shared and used without synchronization.\n */\npublic final class BaseSettings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public TimeZone getTimeZone();\n    public BaseSettings withDateFormat(DateFormat df);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n        private int getY() { return 2; }\n    private final static String getLF() {\n        return System.getProperty(\"line.separator\");\n    }\n    public void testDateFormatConfig() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        TimeZone tz1 = TimeZone.getTimeZone(\"America/Los_Angeles\");\n        TimeZone tz2 = TimeZone.getTimeZone(\"Central Standard Time\");\n\n        // sanity checks\n        assertEquals(tz1, tz1);\n        assertEquals(tz2, tz2);\n        if (tz1.equals(tz2)) {\n            fail();\n        }\n\n        mapper.setTimeZone(tz1);\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n\n        // also better stick via reader/writer as well\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n        \n        SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        f.setTimeZone(tz2);\n        mapper.setDateFormat(f);\n\n        // should not change the timezone tho\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.getDeserializationConfig().getTimeZone());\n        assertEquals(tz1, mapper.writer().getConfig().getTimeZone());\n        assertEquals(tz1, mapper.reader().getConfig().getTimeZone());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n/**\n * Simple {@link AbstractTypeResolver} implementation, which is\n * based on static mapping from abstract super types into\n * sub types (concrete or abstract), but retaining generic\n * parameterization.\n * Can be used for things like specifying which implementation of\n * {@link java.util.Collection} to use:\n *<pre>\n *  SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver();\n *  // To make all properties declared as Collection, List, to LinkedList\n *  resolver.addMapping(Collection.class, LinkedList.class);\n *  resolver.addMapping(List.class, LinkedList.class);\n *</pre>\n * Can also be used as an alternative to per-class annotations when defining\n * concrete implementations; however, only works with abstract types (since\n * this is only called for abstract types)\n */\npublic class SimpleAbstractTypeResolver\n    extends AbstractTypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 8635483102371490919L;\n    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type);\n}\n/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException;\n}\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n/**\n * Simple {@link AbstractTypeResolver} implementation, which is\n * based on static mapping from abstract super types into\n * sub types (concrete or abstract), but retaining generic\n * parameterization.\n * Can be used for things like specifying which implementation of\n * {@link java.util.Collection} to use:\n *<pre>\n *  SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver();\n *  // To make all properties declared as Collection, List, to LinkedList\n *  resolver.addMapping(Collection.class, LinkedList.class);\n *  resolver.addMapping(List.class, LinkedList.class);\n *</pre>\n * Can also be used as an alternative to per-class annotations when defining\n * concrete implementations; however, only works with abstract types (since\n * this is only called for abstract types)\n */\npublic class SimpleAbstractTypeResolver\n    extends AbstractTypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 8635483102371490919L;\n    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type);\n}\n/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException;\n}\n/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n        assertNotNull(result);\n        assertNotNull(result.someBytes);\n        assertEquals(byte[].class, result.someBytes.getClass());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter extends PropertyWriter\n    implements BeanProperty\n{\n    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n    public BeanPropertyWriter rename(NameTransformer transformer);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base bean property handler class, which implements common parts of\n * reflection-based functionality for accessing a property value\n * and serializing it.\n *<p> \n * Note that current design tries to keep instances immutable (semi-functional\n * style); mostly because these instances are exposed to application\n * code and this is to reduce likelihood of data corruption and\n * synchronization issues.\n */\npublic class BeanPropertyWriter extends PropertyWriter\n    implements BeanProperty\n{\n    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n    public BeanPropertyWriter rename(NameTransformer transformer);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testEnumHandlers() throws IOException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        // ensure we have serializers and/or deserializers, first\n        String json = mapper.writerFor(EnumPOJO.class)\n                .writeValueAsString(new EnumPOJO());\n        EnumPOJO result = mapper.readerFor(EnumPOJO.class)\n                .readValue(json);\n        assertNotNull(result);\n\n        // and then use JDK serialization to freeze/thaw objects\n        byte[] bytes = jdkSerialize(mapper);\n        ObjectMapper mapper2 = jdkDeserialize(bytes);\n        assertNotNull(mapper2);\n\n        bytes = jdkSerialize(mapper.readerFor(EnumPOJO.class));\n        ObjectReader r = jdkDeserialize(bytes);\n        assertNotNull(r);\n\n        /* 14-Aug-2015, tatu: Looks like pre-loading JsonSerializer is problematic\n         *    at this point; comment out for now. Try to fix later on.\n         */\n        bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));\n        ObjectWriter w = jdkDeserialize(bytes);\n        assertNotNull(w);\n\n        // plus, ensure objects are usable:\n        String json2 = w.writeValueAsString(new EnumPOJO());\n        assertEquals(json, json2);\n        EnumPOJO result2 = r.readValue(json2);\n        assertNotNull(result2);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testInverseExternalId928() throws Exception\n    {\n        final String CLASS = Payload928.class.getName();\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        final String successCase = \"{\\\"payload\\\":{\\\"something\\\":\\\"test\\\"},\\\"class\\\":\\\"\"+CLASS+\"\\\"}\";\n        Envelope928 envelope1 = mapper.readValue(successCase, Envelope928.class);\n        assertNotNull(envelope1);\n        assertEquals(Payload928.class, envelope1._payload.getClass());\n\n        // and then re-ordered case that was problematic\n        final String failCase = \"{\\\"class\\\":\\\"\"+CLASS+\"\\\",\\\"payload\\\":{\\\"something\\\":\\\"test\\\"}}\";\n        Envelope928 envelope2 = mapper.readValue(failCase, Envelope928.class);\n        assertNotNull(envelope2);\n        assertEquals(Payload928.class, envelope2._payload.getClass());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deserializer that can build instances of {@link JsonNode} from any\n * JSON content, using appropriate {@link JsonNode} type.\n */\npublic class JsonNodeDeserializer\n    extends BaseNodeDeserializer<JsonNode>\n{\n    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deserializer that can build instances of {@link JsonNode} from any\n * JSON content, using appropriate {@link JsonNode} type.\n */\npublic class JsonNodeDeserializer\n    extends BaseNodeDeserializer<JsonNode>\n{\n    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> */\npublic class TestObjectNode\n    extends BaseMapTest\n{\n    public void testIssue941() throws Exception\n    {\n        ObjectNode object = MAPPER.createObjectNode();\n\n        String json = MAPPER.writeValueAsString(object);\n        System.out.println(\"json: \"+json);\n\n        ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works\n        System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception\n        System.out.println(\"Deserialized to MyValue: \"+de2);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testExternalTypeIdWithNull() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerSubtypes(ValueBean.class);\n        ExternalBean b;\n        b = mapper.readValue(aposToQuotes(\"{'bean':null,'extType':'vbean'}\"),\n                ExternalBean.class);\n        assertNotNull(b);\n        b = mapper.readValue(aposToQuotes(\"{'extType':'vbean','bean':null}\"),\n                ExternalBean.class);\n        assertNotNull(b);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException;\n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException;\n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testStringArray() throws Exception\n    {\n        final String[] STRS = new String[] {\n            \"a\", \"b\", \"abcd\", \"\", \"???\", \"\\\"quoted\\\"\", \"lf: \\n\",\n        };\n        StringWriter sw = new StringWriter();\n        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);\n        jg.writeStartArray();\n        for (String str : STRS) {\n            jg.writeString(str);\n        }\n        jg.writeEndArray();\n        jg.close();\n\n        String[] result = MAPPER.readValue(sw.toString(), String[].class);\n        assertNotNull(result);\n\n        assertEquals(STRS.length, result.length);\n        for (int i = 0; i < STRS.length; ++i) {\n            assertEquals(STRS[i], result[i]);\n        }\n\n        // [#479]: null handling was busted in 2.4.0\n        result = MAPPER.readValue(\" [ null ]\", String[].class);\n        assertNotNull(result);\n        assertEquals(1, result.length);\n        assertNull(result[0]);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(TypeReference<?> type);\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(JavaType type);\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(Class<?> type);\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: while results are usually identical to that of serialization followed\n     * by deserialization, this is not always the case. In some cases serialization\n     * into intermediate representation will retain encapsulation of things like\n     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n     * node identity ({@link JsonNode}). If so, result is a valid tree, but values\n     * are not re-constructed through actual JSON representation. So if transformation\n     * requires actual materialization of JSON (or other data format that this mapper\n     * produces), it will be necessary to do actual serialization.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n}\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString();\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException;\n    /**\n     * @since 2.7\n     */\n\n    @Override\n    public Version version();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(TypeReference<?> type);\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(JavaType type);\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     * \n     * @since 2.6\n     */\n    public ObjectReader readerFor(Class<?> type);\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: while results are usually identical to that of serialization followed\n     * by deserialization, this is not always the case. In some cases serialization\n     * into intermediate representation will retain encapsulation of things like\n     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic\n     * node identity ({@link JsonNode}). If so, result is a valid tree, but values\n     * are not re-constructed through actual JSON representation. So if transformation\n     * requires actual materialization of JSON (or other data format that this mapper\n     * produces), it will be necessary to do actual serialization.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n}\n/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString();\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser p) throws IOException;\n    /**\n     * @since 2.7\n     */\n\n    @Override\n    public Version version();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n        private void setValue(Object value) {\n            this.value = value;\n        }\n    public void testBigDecimal965() throws Exception\n    {\n\n        Wrapper965 w = new Wrapper965();\n        w.typeEnum = Type965.BIG_DECIMAL;\n        final String NUM_STR = \"-10000000000.0000000001\";\n        w.value = new BigDecimal(NUM_STR);\n\n        String json = MAPPER.writeValueAsString(w);\n\n        // simple sanity check so serialization is faithful\n        if (!json.contains(NUM_STR)) {\n            fail(\"JSON content should contain value '\"+NUM_STR+\"', does not appear to: \"+json);\n        }\n        \n        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)\n                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n                .readValue(json);\n\n        assertEquals(w.typeEnum, w2.typeEnum);\n        assertTrue(String.format(\"Expected %s = %s; got back %s = %s\", w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()), w.value.equals(w2.value));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    public final JsonWriteContext getOutputContext()  return _writeContext; };\n    @Override\n    public void writeNumber(int i) throws IOException;\n    @Override\n    public void writeNumber(BigInteger v) throws IOException;\n    @Override\n    public void writeTree(TreeNode node) throws IOException;\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException;\n    @Override\n    public void writeNumber(String encodedValue) throws IOException;\n    @Override\n    public void writeNumber(long l) throws IOException;\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException;\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException;\n    @Override\n    public final void writeEndObject() throws IOException;\n    protected final void _append(JsonToken type, Object value);\n    @Override\n    public final void writeEndArray() throws IOException;\n    /**\n     * Similar to {@link #_append(JsonToken,Object)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n    \n    protected final void _appendRaw(int rawType, Object value);\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException;\n    @Override\n    public final void writeFieldName(String name) throws IOException;\n    @Override\n    public final void writeStartObject() throws IOException;\n    @Override\n    public void writeNumber(double d) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException;\n    @Override\n    public void writeString(SerializableString text) throws IOException;\n    @Override\n    public void writeRaw(char c) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException;\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException;\n    @Override\n    public void writeNumber(float f) throws IOException;\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    @Override\n    public final JsonWriteContext getOutputContext()  return _writeContext; };\n    @Override\n    public void writeNumber(int i) throws IOException;\n    @Override\n    public void writeNumber(BigInteger v) throws IOException;\n    @Override\n    public void writeTree(TreeNode node) throws IOException;\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException;\n    @Override\n    public void writeNumber(String encodedValue) throws IOException;\n    @Override\n    public void writeNumber(long l) throws IOException;\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException;\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException;\n    @Override\n    public final void writeEndObject() throws IOException;\n    protected final void _append(JsonToken type, Object value);\n    @Override\n    public final void writeEndArray() throws IOException;\n    /**\n     * Similar to {@link #_append(JsonToken,Object)} but also updates context with\n     * knowledge that a scalar value was written\n     *\n     * @since 2.6.4\n     */\n    \n    protected final void _appendRaw(int rawType, Object value);\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException;\n    @Override\n    public final void writeFieldName(String name) throws IOException;\n    @Override\n    public final void writeStartObject() throws IOException;\n    @Override\n    public void writeNumber(double d) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException;\n    @Override\n    public void writeString(SerializableString text) throws IOException;\n    @Override\n    public void writeRaw(char c) throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException;\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException;\n    @Override\n    public void writeNumber(float f) throws IOException;\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _verifyOutputContext(JsonGenerator gen1, JsonGenerator gen2)\n    {\n        _verifyOutputContext(gen1.getOutputContext(), gen2.getOutputContext());\n    }\n    private void _verifyOutputContext(JsonStreamContext ctxt1, JsonStreamContext ctxt2)\n    {\n        if (ctxt1 == null) {\n            if (ctxt2 == null) {\n                return;\n            }\n            fail(\"Context 1 null, context 2 not null: \"+ctxt2);\n        } else if (ctxt2 == null) {\n            fail(\"Context 2 null, context 1 not null: \"+ctxt1);\n        }\n        if (!ctxt1.getTypeDesc().equals(ctxt2.getTypeDesc())) {\n            fail(\"Different output context: token-buffer's = \"+ctxt1+\", json-generator's: \"+ctxt2);\n        }\n\n        if (ctxt1.inObject()) {\n            assertTrue(ctxt2.inObject());\n            String str1 = ctxt1.getCurrentName();\n            String str2 = ctxt2.getCurrentName();\n\n            if ((str1 != str2) && !str1.equals(str2)) {\n                fail(\"Expected name '\"+str2+\"' (JsonParser), TokenBuffer had '\"+str1+\"'\");\n            }\n        } else if (ctxt1.inArray()) {\n            assertTrue(ctxt2.inArray());\n            assertEquals(ctxt1.getCurrentIndex(), ctxt2.getCurrentIndex());\n        }\n        _verifyOutputContext(ctxt1.getParent(), ctxt2.getParent());\n    }\n    public void testOutputContext() throws IOException\n    {\n        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec\n        StringWriter w = new StringWriter();\n        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);\n \n        // test content: [{\"a\":1,\"b\":{\"c\":2}},{\"a\":2,\"b\":{\"c\":3}}]\n\n        buf.writeStartArray();\n        gen.writeStartArray();\n        _verifyOutputContext(buf, gen);\n        \n        buf.writeStartObject();\n        gen.writeStartObject();\n        _verifyOutputContext(buf, gen);\n        \n        buf.writeFieldName(\"a\");\n        gen.writeFieldName(\"a\");\n        _verifyOutputContext(buf, gen);\n\n        buf.writeNumber(1);\n        gen.writeNumber(1);\n        _verifyOutputContext(buf, gen);\n\n        buf.writeFieldName(\"b\");\n        gen.writeFieldName(\"b\");\n        _verifyOutputContext(buf, gen);\n\n        buf.writeStartObject();\n        gen.writeStartObject();\n        _verifyOutputContext(buf, gen);\n        \n        buf.writeFieldName(\"c\");\n        gen.writeFieldName(\"c\");\n        _verifyOutputContext(buf, gen);\n\n        buf.writeNumber(2);\n        gen.writeNumber(2);\n        _verifyOutputContext(buf, gen);\n\n        buf.writeEndObject();\n        gen.writeEndObject();\n        _verifyOutputContext(buf, gen);\n\n        buf.writeEndObject();\n        gen.writeEndObject();\n        _verifyOutputContext(buf, gen);\n\n        buf.writeEndArray();\n        gen.writeEndArray();\n        _verifyOutputContext(buf, gen);\n        \n        buf.close();\n        gen.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deserializer implementation that is used if it is necessary to bind content of\n * \"unknown\" type; something declared as basic {@link java.lang.Object}\n * (either explicitly, or due to type erasure).\n * If so, \"natural\" mapping is used to convert JSON values to their natural\n * Java object matches: JSON arrays to Java {@link java.util.List}s (or, if configured,\n * Object[]), JSON objects to {@link java.util.Map}s, numbers to\n * {@link java.lang.Number}s, booleans to {@link java.lang.Boolean}s and\n * strings to {@link java.lang.String} (and nulls to nulls).\n */\npublic class UntypedObjectDeserializer\n    extends StdDeserializer<Object>\n    implements ResolvableDeserializer, ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null);\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deserializer implementation that is used if it is necessary to bind content of\n * \"unknown\" type; something declared as basic {@link java.lang.Object}\n * (either explicitly, or due to type erasure).\n * If so, \"natural\" mapping is used to convert JSON values to their natural\n * Java object matches: JSON arrays to Java {@link java.util.List}s (or, if configured,\n * Object[]), JSON objects to {@link java.util.Map}s, numbers to\n * {@link java.lang.Number}s, booleans to {@link java.lang.Boolean}s and\n * strings to {@link java.lang.String} (and nulls to nulls).\n */\npublic class UntypedObjectDeserializer\n    extends StdDeserializer<Object>\n    implements ResolvableDeserializer, ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    public final static UntypedObjectDeserializer instance = new UntypedObjectDeserializer(null, null);\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testNestedUntyped989() throws IOException\n    {\n        Untyped989 pojo;\n        ObjectReader r = MAPPER.readerFor(Untyped989.class);\n\n        pojo = r.readValue(\"[]\");\n        assertTrue(pojo.value instanceof List);\n        pojo = r.readValue(\"[{}]\");\n        assertTrue(pojo.value instanceof List);\n        \n        pojo = r.readValue(\"{}\");\n        assertTrue(pojo.value instanceof Map);\n        pojo = r.readValue(\"{\\\"a\\\":[]}\");\n        assertTrue(pojo.value instanceof Map);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public PropertyName findNameForSerialization(Annotated a);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> */\npublic class TestUnwrapped extends BaseMapTest\n{\n    public void testUnwrappedAsPropertyIndicator() throws Exception\n    {\n        Inner inner = new Inner();\n        inner.animal = \"Zebra\";\n\n        Outer outer = new Outer();\n        outer.inner = inner;\n\n        String actual = MAPPER.writeValueAsString(outer);\n\n        assertTrue(actual.contains(\"animal\"));\n        assertTrue(actual.contains(\"Zebra\"));\n        assertFalse(actual.contains(\"inner\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n{\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * As a fallback, we may need to use this serializer for other\n * types of {@link Number}s: both custom types and \"big\" numbers\n * like {@link BigInteger} and {@link BigDecimal}.\n */\npublic class NumberSerializer\n    extends StdScalarSerializer<Number>\n{\n    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSimpleNumbers() throws Exception\n    {\n        final StringBuilder sb = new StringBuilder();\n        \n        MAPPER.acceptJsonFormatVisitor(Numbers.class,\n                new JsonFormatVisitorWrapper.Base() {\n            @Override\n            public JsonObjectFormatVisitor expectObjectFormat(final JavaType type) {\n                return new JsonObjectFormatVisitor.Base(getProvider()) {\n                    @Override\n                    public void optionalProperty(BeanProperty prop) throws JsonMappingException {\n                        sb.append(\"[optProp \").append(prop.getName()).append(\"(\");\n                        JsonSerializer<Object> ser = null;\n                        if (prop instanceof BeanPropertyWriter) {\n                            BeanPropertyWriter bpw = (BeanPropertyWriter) prop;\n                            ser = bpw.getSerializer();\n                        }\n                        final SerializerProvider prov = getProvider();\n                        if (ser == null) {\n                            ser = prov.findValueSerializer(prop.getType(), prop);\n                        }\n                        ser.acceptJsonFormatVisitor(new JsonFormatVisitorWrapper.Base() {\n                            @Override\n                            public JsonNumberFormatVisitor expectNumberFormat(\n                                    JavaType type) throws JsonMappingException {\n                                return new JsonNumberFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[numberFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n\n                            @Override\n                            public JsonIntegerFormatVisitor expectIntegerFormat(JavaType type) throws JsonMappingException {\n                                return new JsonIntegerFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[integerFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n                        }, prop.getType());\n\n                        sb.append(\")]\");\n                    }\n                };\n            }\n        });\n        assertEquals(\"[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]\", sb.toString());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type deserializer used with {@link As#WRAPPER_OBJECT}\n * inclusion mechanism. Simple since JSON structure used is always\n * the same, regardless of structure used for actual value: wrapping\n * is done using a single-element JSON Object where type id is the key,\n * and actual object data as the value.\n */\npublic class AsWrapperTypeDeserializer\n    extends TypeDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 5345570420394408290L;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type deserializer used with {@link As#WRAPPER_OBJECT}\n * inclusion mechanism. Simple since JSON structure used is always\n * the same, regardless of structure used for actual value: wrapping\n * is done using a single-element JSON Object where type id is the key,\n * and actual object data as the value.\n */\npublic class AsWrapperTypeDeserializer\n    extends TypeDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 5345570420394408290L;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSimple() throws Exception\n    {\n        Company comp = new Company();\n        comp.addComputer(new DesktopComputer(\"computer-1\", \"Bangkok\"));\n        comp.addComputer(new DesktopComputer(\"computer-2\", \"Pattaya\"));\n        comp.addComputer(new LaptopComputer(\"computer-3\", \"Apple\"));\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(comp);\n\n        System.out.println(\"JSON: \"+json);\n\n        Company result = mapper.readValue(json, Company.class);\n        assertNotNull(result);\n        assertNotNull(result.computers);\n        assertEquals(3, result.computers.size());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient);\n    @Override\n    public Date parse(String dateStr, ParsePosition pos);\n    @Override\n    public StdDateFormat clone();\n    /**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */\n            // and since leniency settings may have been used:\n\n    @Override // since 2.7\n    public boolean isLenient();\n    @Override\n    public void setTimeZone(TimeZone tz);\n    /**********************************************************\n     */\n\n    @Override\n    public Date parse(String dateStr) throws ParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc, Boolean lenient);\n    @Override\n    public Date parse(String dateStr, ParsePosition pos);\n    @Override\n    public StdDateFormat clone();\n    /**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */\n            // and since leniency settings may have been used:\n\n    @Override // since 2.7\n    public boolean isLenient();\n    @Override\n    public void setTimeZone(TimeZone tz);\n    /**********************************************************\n     */\n\n    @Override\n    public Date parse(String dateStr) throws ParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testLenient() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        assertTrue(f.isLenient());\n\n        StdDateFormat f2 = f.clone();\n        assertTrue(f2.isLenient());\n\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());\n\n        f2.setLenient(true);\n        assertTrue(f2.isLenient());\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());\n        StdDateFormat f3 = f2.clone();\n        assertFalse(f3.isLenient());\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        assertNotNull(dt);\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            fail(\"Should not pass\");\n        } catch (ParseException e) {\n            verifyException(e, \"can not parse date\");\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        assertNotNull(dt);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected JavaType _narrow(Class<?> subclass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected JavaType _narrow(Class<?> subclass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n      public void testSimple() throws Exception {\n          final ObjectMapper mapper = new ObjectMapper();\n          final String json = aposToQuotes(\"{'schemas': [{\\n\"\n              + \"  'name': 'FoodMart'\\n\"\n              + \"}]}\\n\");\n          mapper.readValue(json, JsonRoot.class);\n      }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls);\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb);\n}\n/**\n * Type that represents Java Collection types (Lists, Sets).\n */\npublic final class CollectionType\n    extends CollectionLikeType\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.7\n     */\n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT);\n    /**\n     * @deprecated Since 2.7, remove from 2.8\n     */\n    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT);\n}\n/**\n * Type that represents \"true\" Java Map types.\n */\npublic final class MapType extends MapLikeType\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.7\n     */\n    public static MapType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            JavaType keyT, JavaType valueT);\n    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method that should NOT to be used by application code:\n     * it does NOT properly handle inspection of super-types, so neither parent\n     * Classes nor implemented Interfaces are accessible with resulting type\n     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>\n     * methods which handle introspection appropriately.\n     *<p>\n     * Note that prior to 2.7, method usage was not limited and would typically\n     * have worked acceptably: the problem comes from inability to resolve super-type\n     * information, for which {@link TypeFactory} is needed.\n     * \n     * @deprecated Since 2.7\n     */\n    @Deprecated\n    public static SimpleType construct(Class<?> cls);\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb);\n}\n/**\n * Type that represents Java Collection types (Lists, Sets).\n */\npublic final class CollectionType\n    extends CollectionLikeType\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.7\n     */\n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType elemT);\n    /**\n     * @deprecated Since 2.7, remove from 2.8\n     */\n    @Deprecated // since 2.7\n    public static CollectionType construct(Class<?> rawType, JavaType elemT);\n}\n/**\n * Type that represents \"true\" Java Map types.\n */\npublic final class MapType extends MapLikeType\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * @since 2.7\n     */\n    public static MapType construct(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            JavaType keyT, JavaType valueT);\n    @Deprecated // since 2.7\n    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testExplicitMapType() throws Exception\n    {\n        JavaType key = SimpleType.construct(String.class);\n        JavaType elem = SimpleType.construct(Point.class);\n        JavaType t = MapType.construct(Map.class, key, elem);\n\n        final String json = aposToQuotes(\"{'x':{'x':3,'y':5}}\");        \n\n        Map<String,Point> m = MAPPER.readValue(json, t);\n        assertNotNull(m);\n        assertEquals(1, m.size());\n        Object ob = m.values().iterator().next();\n        assertEquals(Point.class, ob.getClass());\n        Point p = (Point) ob;\n        assertEquals(3, p.x);\n        assertEquals(5, p.getY());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Bogus deserializer that will simply skip all content there is to map\n * and returns Java null reference.\n * \n * @since 2.2\n */\npublic class NullifyingDeserializer\n    extends StdDeserializer<Object>\n{\n    private static final long serialVersionUID = 1L;\n    public final static NullifyingDeserializer instance = new NullifyingDeserializer();\n    /**********************************************************\n     */\n    \n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Bogus deserializer that will simply skip all content there is to map\n * and returns Java null reference.\n * \n * @since 2.2\n */\npublic class NullifyingDeserializer\n    extends StdDeserializer<Object>\n{\n    private static final long serialVersionUID = 1L;\n    public final static NullifyingDeserializer instance = new NullifyingDeserializer();\n    /**********************************************************\n     */\n    \n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testUnknownTypeIDRecovery() throws Exception\n    {\n        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(\n                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n        String json = aposToQuotes(\"{'version':0.0,'application':'123',\"\n                +\"'item':{'type':'xevent','location':'location1'},\"\n                +\"'item2':{'type':'event','location':'location1'}}\");\n        // can't read item2 - which is valid\n        CallRecord r = reader.readValue(json);\n        assertNull(r.item);\n        assertNotNull(r.item2);\n\n        json = aposToQuotes(\"{'item':{'type':'xevent','location':'location1'}, 'version':0.0,'application':'123'}\");\n        CallRecord r3 = reader.readValue(json);\n        assertNull(r3.item);\n        assertEquals(\"123\", r3.application);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException;\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Separate implementation for serializing String arrays (instead of\n * using {@link ObjectArrayDeserializer}.\n * Used if (and only if) no custom value deserializers are used.\n */\npublic final class StringArrayDeserializer\n    extends StdDeserializer<String[]>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -7589512013334920693L;\n    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n    @Override\n    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException;\n    /**\n     * Offlined version used when we do not use the default deserialization method.\n     */\n    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testArrayIndexForExceptions() throws Exception\n    {\n        final String OBJECTS_JSON = \"[ \\\"KEY2\\\", false ]\";\n        try {\n            MAPPER.readValue(OBJECTS_JSON, Key[].class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not deserialize\");\n            List<JsonMappingException.Reference> refs = e.getPath();\n            assertEquals(1, refs.size());\n            assertEquals(1, refs.get(0).getIndex());\n        }\n\n        try {\n            MAPPER.readValue(\"[ \\\"xyz\\\", { } ]\", String[].class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not deserialize\");\n            List<JsonMappingException.Reference> refs = e.getPath();\n            assertEquals(1, refs.size());\n            assertEquals(1, refs.get(0).getIndex());\n        }\n\n        try {\n            MAPPER.readValue(\"{\\\"keys\\\":\"+OBJECTS_JSON+\"}\", KeyListBean.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not deserialize\");\n            List<JsonMappingException.Reference> refs = e.getPath();\n            assertEquals(2, refs.size());\n            // Bean has no index, but has name:\n            assertEquals(-1, refs.get(0).getIndex());\n            assertEquals(\"keys\", refs.get(0).getFieldName());\n\n            // and for List, reverse:\n            assertEquals(1, refs.get(1).getIndex());\n            assertNull(refs.get(1).getFieldName());\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Container class for deserializers that handle core JDK primitive\n * (and matching wrapper) types, as well as standard \"big\" numeric types.\n * Note that this includes types such as {@link java.lang.Boolean}\n * and {@link java.lang.Character} which are not strictly numeric,\n * but are part of primitive/wrapper types.\n */\npublic class NumberDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Container class for deserializers that handle core JDK primitive\n * (and matching wrapper) types, as well as standard \"big\" numeric types.\n * Note that this includes types such as {@link java.lang.Boolean}\n * and {@link java.lang.Character} which are not strictly numeric,\n * but are part of primitive/wrapper types.\n */\npublic class NumberDeserializers\n{\n    private final static HashSet<String> _classNames = new HashSet<String>();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private void _testEmptyToNullCoercion(Class<?> primType, Object emptyValue) throws Exception\n    {\n        final String EMPTY = \"\\\"\\\"\";\n\n        // as per [databind#1095] should only allow coercion from empty String,\n        // if `null` is acceptable\n        ObjectReader intR = MAPPER.readerFor(primType);\n        assertEquals(emptyValue, intR.readValue(EMPTY));\n        try {\n            intR.with(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n                .readValue(\"\\\"\\\"\");\n            fail(\"Should not have passed\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not map Empty String\");\n        }\n    }\n    public void testEmptyToNullCoercionForPrimitives() throws Exception {\n        _testEmptyToNullCoercion(int.class, Integer.valueOf(0));\n        _testEmptyToNullCoercion(long.class, Long.valueOf(0));\n        _testEmptyToNullCoercion(double.class, Double.valueOf(0.0));\n        _testEmptyToNullCoercion(float.class, Float.valueOf(0.0f));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDeprecatedTypeResolution() throws Exception\n    {\n        TypeFactory tf = MAPPER.getTypeFactory();\n\n        // first, with real (if irrelevant) context\n        JavaType t = tf.constructType(Point.class, getClass());\n        assertEquals(Point.class, t.getRawClass());\n\n        // and then missing context\n        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);\n        assertEquals(Point.class, t2.getRawClass());\n\n        JavaType ctxt = tf.constructType(getClass());\n        JavaType t3 = tf.constructType(Point.class, ctxt);\n        assertEquals(Point.class, t3.getRawClass());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private static String asArray(Object value) {\n        final String stringVal = value.toString();\n        return new StringBuilder(stringVal.length() + 2).append(\"[\").append(stringVal).append(\"]\").toString();\n    }\n    public void testLocale() throws IOException\n    {\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n        // [databind#1123]\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n        assertSame(Locale.ROOT, loc);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link SettableBeanProperty} implementation used\n * for virtual property that represents Object Id that is used\n * for some POJO types (or properties).\n */\npublic final class ObjectIdValueProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public Object deserializeSetAndReturn(JsonParser p,\n    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n    @Override\n    public ObjectIdValueProperty withName(PropertyName newName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testNullStringPropertyId() throws Exception\n    {\n        IdentifiableStringId value = MAPPER.readValue\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), IdentifiableStringId.class);\n        assertNotNull(value);\n        assertEquals(3, value.value);\n    }    \n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple types are defined as anything other than one of recognized\n * container types (arrays, Collections, Maps). For our needs we\n * need not know anything further, since we have no way of dealing\n * with generic types other than Collections and Maps.\n */\npublic class SimpleType // note: until 2.6 was final\n    extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1125WithDefault() throws Exception\n    {\n        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes(\"{'value':{'a':3,'def':9,'b':5}}\"),\n        \t\tIssue1125Wrapper.class);\n        assertNotNull(result.value);\n        assertEquals(Default1125.class, result.value.getClass());\n        Default1125 impl = (Default1125) result.value;\n        assertEquals(3, impl.a);\n        assertEquals(5, impl.b);\n        assertEquals(9, impl.def);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testDateDefaultShape() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        // No @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // Empty @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n        assertEquals(aposToQuotes(\"{'date':0}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json);\n\n        // @JsonFormat with Shape.ANY and locale => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T00:00:00.000+0000'}\"), json);\n\n        // @JsonFormat with Shape.ANY and timezone => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01T01:00:00.000+0100'}\"), json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testGenericSignature1195() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m;\n        JavaType t;\n\n        m = Generic1195.class.getMethod(\"getList\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/List<Ljava/lang/String;>;\", t.getGenericSignature());\n\n        m = Generic1195.class.getMethod(\"getMap\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;\", t.getGenericSignature());\n\n        m = Generic1195.class.getMethod(\"getGeneric\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\", t.getGenericSignature());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstract class that defines API used for introspecting annotation-based\n * configuration for serialization and deserialization. Separated\n * so that different sets of annotations can be supported, and support\n * plugged-in dynamically.\n *<p>\n * Although default implementations are based on using annotations as the only\n * (or at least main) information source, custom implementations are not limited\n * in such a way, and in fact there is no expectation they should be. So the name\n * is bit of misnomer; this is a general configuration introspection facility.\n *<p>\n * NOTE: due to rapid addition of new methods (and changes to existing methods),\n * it is <b>strongly</b> recommended that custom implementations should not directly\n * extend this class, but rather extend {@link NopAnnotationIntrospector}.\n * This way added methods will not break backwards compatibility of custom annotation\n * introspectors.\n */\npublic abstract class AnnotationIntrospector\n    implements Versioned, java.io.Serializable\n{\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstract class that defines API used for introspecting annotation-based\n * configuration for serialization and deserialization. Separated\n * so that different sets of annotations can be supported, and support\n * plugged-in dynamically.\n *<p>\n * Although default implementations are based on using annotations as the only\n * (or at least main) information source, custom implementations are not limited\n * in such a way, and in fact there is no expectation they should be. So the name\n * is bit of misnomer; this is a general configuration introspection facility.\n *<p>\n * NOTE: due to rapid addition of new methods (and changes to existing methods),\n * it is <b>strongly</b> recommended that custom implementations should not directly\n * extend this class, but rather extend {@link NopAnnotationIntrospector}.\n * This way added methods will not break backwards compatibility of custom annotation\n * introspectors.\n */\npublic abstract class AnnotationIntrospector\n    implements Versioned, java.io.Serializable\n{\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testBrokenAnnotation() throws Exception\n    {\n        try {\n            serializeAsString(MAPPER, new BrokenClass());\n        } catch (Exception e) {\n            verifyException(e, \"types not related\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Object that contains baseline configuration for deserialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance to be used for deserialization process.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class DeserializationConfig\n    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type);\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker();\n}\n/**\n * Object that contains baseline configuration for serialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance for serialization process to\n * {@link SerializerProvider} and {@link SerializerFactory}\n * (either directly, or through {@link ObjectWriter}.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class SerializationConfig\n    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean serializer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type);\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Object that contains baseline configuration for deserialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance to be used for deserialization process.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class DeserializationConfig\n    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type);\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker();\n}\n/**\n * Object that contains baseline configuration for serialization\n * process. An instance is owned by {@link ObjectMapper}, which\n * passes an immutable instance for serialization process to\n * {@link SerializerProvider} and {@link SerializerFactory}\n * (either directly, or through {@link ObjectWriter}.\n *<p>\n * Note that instances are considered immutable and as such no copies\n * should need to be created for sharing; all copying is done with\n * \"fluent factory\" methods.\n */\npublic final class SerializationConfig\n    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Method that will introspect full bean properties for the purpose\n     * of building a bean serializer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends BeanDescription> T introspect(JavaType type);\n    @Override\n    public VisibilityChecker<?> getDefaultVisibilityChecker();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testVisibilityFeatures() throws Exception\n    {\n        ObjectMapper om = new ObjectMapper();\n        // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).\n        om.configure(MapperFeature.AUTO_DETECT_FIELDS, false);\n        om.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_SETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n        om.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n        om.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);\n        om.configure(MapperFeature.INFER_PROPERTY_MUTATORS, false);\n        om.configure(MapperFeature.USE_ANNOTATIONS, true);\n\n        JavaType javaType = om.getTypeFactory().constructType(TCls.class);        \n        BeanDescription desc = (BeanDescription) om.getSerializationConfig().introspect(javaType);\n        List<BeanPropertyDefinition> props = desc.findProperties();\n        if (props.size() != 1) {\n            fail(\"Should find 1 property, not \"+props.size()+\"; properties = \"+props);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple value container used to keep track of Object Ids during\n * serialization.\n */\npublic final class WritableObjectId\n{\n    public final ObjectIdGenerator<?> generator;\n    public Object id;\n    public Object generateId(Object forPojo);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple value container used to keep track of Object Ids during\n * serialization.\n */\npublic final class WritableObjectId\n{\n    public final ObjectIdGenerator<?> generator;\n    public Object id;\n    public Object generateId(Object forPojo);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1255() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Foo mo = new Foo();\n        mo.bar1 = new Bar();\n        mo.bar2 = mo.bar1;\n\n        String json = mapper.writeValueAsString(mo);\n\n        Foo result = mapper.readValue(json, Foo.class);\n        assertNotNull(result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public final class AnnotatedClass\n    extends Annotated\n{\n    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public final class AnnotatedClass\n    extends Annotated\n{\n    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDisappearingMixins515() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n            .disable(MapperFeature.AUTO_DETECT_FIELDS)\n            .disable(MapperFeature.AUTO_DETECT_GETTERS)\n            .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n            .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n        SimpleModule module = new SimpleModule(\"Test\");\n        module.setMixInAnnotation(Person.class, PersonMixin.class);        \n        mapper.registerModule(module);\n\n        assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl()));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException;\n    /**\n     * @since 2.8\n     */\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException;\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Deserializer class that can deserialize instances of\n * arbitrary bean objects, usually from JSON Object structs,\n */\npublic class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException;\n    /**\n     * @since 2.8\n     */\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException;\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n   private Answer createInitialAnswer() {\n      Answer answer = new Answer();\n      String child1Name = \"child1\";\n      String child2Name = \"child2\";\n      String parent1Name = \"parent1\";\n      String parent2Name = \"parent2\";\n      Parent parent1 = new Parent(parent1Name, false);\n      answer.parents.put(parent1Name, parent1);\n      Child child1 = new Child(child1Name);\n      child1.parent = parent1;\n      child1.parentAsList = Collections.singletonList(parent1);\n      Child child2 = new Child(child2Name);\n      Parent parent2 = new Parent(parent2Name, false);\n      child2.parent = parent2;\n      child2.parentAsList = Collections.singletonList(parent2);\n      parent1.children.put(child1Name, child1);\n      parent1.children.put(child2Name, child2);\n      answer.parents.put(parent2Name, parent2);\n      return answer;\n   }\n    public void testObjectIds1261() throws Exception\n    {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.enable(SerializationFeature.INDENT_OUTPUT);\n         mapper.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n\n         Answer initialAnswer = createInitialAnswer();\n         String initialAnswerString = mapper.writeValueAsString(initialAnswer);\n// System.out.println(\"Initial answer:\\n\"+initialAnswerString);\n         JsonNode tree = mapper.readTree(initialAnswerString);\n         Answer deserializedAnswer = mapper.readValue(initialAnswerString,\n               Answer.class);\n         String reserializedAnswerString = mapper\n               .writeValueAsString(deserializedAnswer);\n         JsonNode newTree = mapper.readTree(reserializedAnswerString);\n         if (!tree.equals(newTree)) {\n                  fail(\"Original and recovered Json are different. Recovered = \\n\" + reserializedAnswerString + \"\\n\");\n         }\n   }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for all standard Jackson {@link TypeDeserializer}s.\n */\npublic abstract class TypeDeserializerBase\n    extends TypeDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n    /**********************************************************\n     */\n\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testPolymorphicTypeViaCustom() throws Exception {\n        Base1270<Poly1> req = new Base1270<Poly1>();\n        Poly1 o = new Poly1();\n        o.val = \"optionValue\";\n        req.options = o;\n        req.val = \"some value\";\n        Top1270 top = new Top1270();\n        top.b = req;\n        String json = MAPPER.writeValueAsString(top);\n        JsonNode tree = MAPPER.readTree(json);\n        assertNotNull(tree.get(\"b\"));\n        assertNotNull(tree.get(\"b\").get(\"options\"));\n        assertNotNull(tree.get(\"b\").get(\"options\").get(\"val\"));\n\n        // Can we reverse the process? I have some doubts\n        Top1270 itemRead = MAPPER.readValue(json, Top1270.class);\n        assertNotNull(itemRead);\n        assertNotNull(itemRead.b);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n}\n/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    final private transient Annotations _classAnnotations;\n    /**\n     * Method called to finalize setup of this deserializer,\n     * after deserializer itself has been registered.\n     * This is needed to handle recursive and transitive dependencies.\n     */\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final ExtTypedProperty[] _properties;\n    private final HashMap<String, Integer> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n}\n/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    final private transient Annotations _classAnnotations;\n    /**\n     * Method called to finalize setup of this deserializer,\n     * after deserializer itself has been registered.\n     * This is needed to handle recursive and transitive dependencies.\n     */\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testExternalTypeId() throws Exception\n    {\n        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };\n\n        Message<?> msg = MAPPER.readValue(aposToQuotes(\"{ 'type':'foo', 'payload': {} }\"), type);\n        assertNotNull(msg);\n        assertNotNull(msg.payload);\n        assertEquals(\"foo\", msg.type);\n\n        // and then with different order\n        msg = MAPPER.readValue(aposToQuotes(\"{'payload': {}, 'type':'foo' }\"), type);\n        assertNotNull(msg);\n        assertNotNull(msg.payload);\n        assertEquals(\"foo\", msg.type);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used for resolving type parameters for given class\n */\npublic class TypeBindings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static String[] NO_STRINGS = new String[0];\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);\n    private final String[] _names;\n    private final JavaType[] _types;\n    private final String[] _unboundVariables;\n    private final int _hashCode;\n    /**\n     * Returns number of bindings contained\n     */\n    public int size();\n    /**\n     * @since 2.3\n     */\n    public boolean hasUnbound(String name);\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings);\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n    public TypeFactory withModifier(TypeModifier mod);\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used for resolving type parameters for given class\n */\npublic class TypeBindings\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static String[] NO_STRINGS = new String[0];\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);\n    private final String[] _names;\n    private final JavaType[] _types;\n    private final String[] _unboundVariables;\n    private final int _hashCode;\n    /**\n     * Returns number of bindings contained\n     */\n    public int size();\n    /**\n     * @since 2.3\n     */\n    public boolean hasUnbound(String name);\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * @param bindings Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings);\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n    public TypeFactory withModifier(TypeModifier mod);\n    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testMapRefinement() throws Exception\n    {\n        String ID1 = \"3a6383d4-8123-4c43-8b8d-7cedf3e59404\";\n        String ID2 = \"81c3d978-90c4-4b00-8da1-1c39ffcab02c\";\n        String json = aposToQuotes(\n\"{'id':'\"+ID1+\"','items':[{'id':'\"+ID2+\"','property':'value'}]}\");\n\n        ObjectMapper m = new ObjectMapper();\n        Data data = m.readValue(json, Data.class);\n\n        assertEquals(ID1, data.id);\n        assertNotNull(data.items);\n        assertEquals(1, data.items.size());\n        Item value = data.items.get(ID2);\n        assertNotNull(value);\n        assertEquals(\"value\", value.property);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends com.fasterxml.jackson.databind.BaseMapTest\n{\n    public void testEmpty1256() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n\n        String json = mapper.writeValueAsString(new Issue1256Bean());\n        assertEquals(\"{}\", json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class StdKeySerializers\n{\n    /**\n     * Method called if no specified key serializer was located; will return a\n     * \"default\" key serializer.\n     *\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType);\n    /**\n     * @param config Serialization configuration in use, may be needed in choosing\n     *    serializer to use\n     * @param rawKeyType Type of key values to serialize\n     * @param useDefault If no match is found, should we return fallback deserializer\n     *    (true), or null (false)?\n     */\n    public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType, boolean useDefault);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class StdKeySerializers\n{\n    /**\n     * Method called if no specified key serializer was located; will return a\n     * \"default\" key serializer.\n     *\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType);\n    /**\n     * @param config Serialization configuration in use, may be needed in choosing\n     *    serializer to use\n     * @param rawKeyType Type of key values to serialize\n     * @param useDefault If no match is found, should we return fallback deserializer\n     *    (true), or null (false)?\n     */\n    public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config,\n            Class<?> rawKeyType, boolean useDefault);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testEnumsWithJsonPropertyAsKey() throws Exception\n    {\n        EnumMap<EnumWithJsonProperty,String> input = new EnumMap<EnumWithJsonProperty,String>(EnumWithJsonProperty.class);\n        input.put(EnumWithJsonProperty.A, \"b\");\n        assertEquals(\"{\\\"aleph\\\":\\\"b\\\"}\", MAPPER.writeValueAsString(input));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private static String asArray(Object value) {\n        final String stringVal = value.toString();\n        return new StringBuilder(stringVal.length() + 2).append(\"[\").append(stringVal).append(\"]\").toString();\n    }\n    public void testLocale() throws IOException\n    {\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n        assertEquals(new Locale(\"en\", \"US\"), MAPPER.readValue(quote(\"en-US\"), Locale.class));\n\n        // [databind#1123]\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n        assertSame(Locale.ROOT, loc);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"mutant factory\" pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    private final TokenFilter _filter;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser p)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException;\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueTypeRef).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Builder object that can be used for per-serialization configuration of\n * deserialization parameters, such as root type to use or object\n * to update (instead of constructing new instance).\n *<p>\n * Uses \"mutant factory\" pattern so that instances are immutable\n * (and thus fully thread-safe with no external synchronization);\n * new instances are constructed for different configurations.\n * Instances are initially constructed by {@link ObjectMapper} and can be\n * reused, shared, cached; both because of thread-safety and because\n * instances are relatively light-weight.\n */\npublic class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n    private final TokenFilter _filter;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser p)\n        throws IOException, JsonProcessingException;\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException;\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException;\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueTypeRef).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private <T> MappingIterator<T> _iterator(ObjectReader r,\n            String json,\n            Source srcType) throws IOException\n    {\n        switch (srcType) {\n        case BYTE_ARRAY:\n            return r.readValues(json.getBytes(\"UTF-8\"));\n        case BYTE_ARRAY_OFFSET:\n            {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                out.write(0);\n                out.write(0);\n                out.write(0);\n                out.write(json.getBytes(\"UTF-8\"));\n                out.write(0);\n                out.write(0);\n                out.write(0);\n                byte[] b = out.toByteArray();\n                return r.readValues(b, 3, b.length-6);\n            }\n        case INPUT_STREAM:\n            return r.readValues(new ByteArrayInputStream(json.getBytes(\"UTF-8\")));\n        case READER:\n            return r.readValues(new StringReader(json));\n        case STRING:\n        default:\n            return r.readValues(json);\n        }\n    }\n    private void _testRootBeans(Source srcType) throws Exception\n    {\n        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n\n        MappingIterator<Bean> it = _iterator(MAPPER.readerFor(Bean.class),\n                JSON, srcType);\n                MAPPER.readerFor(Bean.class).readValues(JSON);\n        assertNotNull(it.getCurrentLocation());\n        assertTrue(it.hasNext());\n        Bean b = it.next();\n        assertEquals(3, b.a);\n        assertTrue(it.hasNext());\n        b = it.next();\n        assertEquals(27, b.a);\n        assertFalse(it.hasNext());\n        it.close();\n\n        // Also, test 'readAll()'\n        it = MAPPER.readerFor(Bean.class).readValues(JSON);\n        List<Bean> all = it.readAll();\n        assertEquals(2, all.size());\n        it.close();\n\n        it = MAPPER.readerFor(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n        Set<Bean> set = it.readAll(new HashSet<Bean>());\n        assertEquals(HashSet.class, set.getClass());\n        assertEquals(1, set.size());\n        assertEquals(3, set.iterator().next().a);\n    }\n    private void _testRootBeans(Source srcType) throws Exception\n    {\n        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n\n        MappingIterator<Bean> it = _iterator(MAPPER.readerFor(Bean.class),\n                JSON, srcType);\n                MAPPER.readerFor(Bean.class).readValues(JSON);\n        assertNotNull(it.getCurrentLocation());\n        assertTrue(it.hasNext());\n        Bean b = it.next();\n        assertEquals(3, b.a);\n        assertTrue(it.hasNext());\n        b = it.next();\n        assertEquals(27, b.a);\n        assertFalse(it.hasNext());\n        it.close();\n\n        // Also, test 'readAll()'\n        it = MAPPER.readerFor(Bean.class).readValues(JSON);\n        List<Bean> all = it.readAll();\n        assertEquals(2, all.size());\n        it.close();\n\n        it = MAPPER.readerFor(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n        Set<Bean> set = it.readAll(new HashSet<Bean>());\n        assertEquals(HashSet.class, set.getClass());\n        assertEquals(1, set.size());\n        assertEquals(3, set.iterator().next().a);\n    }\n    public void testRootBeans() throws Exception\n    {\n        for (Source src : Source.values()) {\n            _testRootBeans(src);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _testCauseOfThrowableIgnoral() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n        IOException e = mapper.readValue(\"{}\", IOException.class);\n        assertNotNull(e);\n    }\n    private void _testCauseOfThrowableIgnoral() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n        IOException e = mapper.readValue(\"{}\", IOException.class);\n        assertNotNull(e);\n    }\n    public void testCauseOfThrowableIgnoral() throws Exception\n    {\n        final SecurityManager origSecMan = System.getSecurityManager();\n        try {\n            System.setSecurityManager(new CauseBlockingSecurityManager());\n            _testCauseOfThrowableIgnoral();\n        } finally {\n            System.setSecurityManager(origSecMan);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type that represents Map-like types; things that consist of key/value pairs\n * but that do not necessarily implement {@link java.util.Map}, but that do not\n * have enough introspection functionality to allow for some level of generic\n * handling. This specifically allows framework to check for configuration and\n * annotation settings used for Map types, and pass these to custom handlers\n * that may be more familiar with actual type.\n */\npublic class MapLikeType extends TypeBase {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public MapLikeType withContentValueHandler(Object h);\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n}\n/**\n * Type that represents things that act similar to {@link java.util.Collection};\n * but may or may not be instances of that interface.\n * This specifically allows framework to check for configuration and annotation\n * settings used for Map types, and pass these to custom handlers that may be more\n * familiar with actual type.\n */\npublic class CollectionLikeType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public CollectionLikeType withContentValueHandler(Object h);\n}\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Mutant factory method that will construct a new instance that is identical to\n     * this instance, except that it will have specified content value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentValueHandler(Object h);\n\n    /**\n     * Mutant factory method that will try to copy handlers that the specified\n     * source type instance had, if any; this must be done recursively where\n     * necessary (as content types may be structured).\n     *\n     * @since 2.8.4\n     */\n\n    /**\n     * Mutant factory method that may be called on structured types\n     * that have a so-called content type (element of arrays, value type\n     * of Maps, referenced type of referential types),\n     * and will construct a new instance that is identical to\n     * this instance, except that it has specified content type, instead of current\n     * one. If content type is already set to given type, <code>this</code> is returned.\n     * If type does not have a content type (which is the case with\n     * <code>SimpleType</code>), @link IllegalArgumentException};\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type that represents Map-like types; things that consist of key/value pairs\n * but that do not necessarily implement {@link java.util.Map}, but that do not\n * have enough introspection functionality to allow for some level of generic\n * handling. This specifically allows framework to check for configuration and\n * annotation settings used for Map types, and pass these to custom handlers\n * that may be more familiar with actual type.\n */\npublic class MapLikeType extends TypeBase {\n    private static final long serialVersionUID = 1L;\n    @Override\n    public MapLikeType withContentValueHandler(Object h);\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n}\n/**\n * Type that represents things that act similar to {@link java.util.Collection};\n * but may or may not be instances of that interface.\n * This specifically allows framework to check for configuration and annotation\n * settings used for Map types, and pass these to custom handlers that may be more\n * familiar with actual type.\n */\npublic class CollectionLikeType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public CollectionLikeType withContentValueHandler(Object h);\n}\n/**\n * Base class for type token classes used both to contain information\n * and as keys for deserializers.\n *<p>\n * Instances can (only) be constructed by\n * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n *<p>\n * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n * it to be pushed through interfaces that only expose that type.\n */\npublic abstract class JavaType\n    extends ResolvedType\n    implements java.io.Serializable, // 2.1\n        java.lang.reflect.Type // 2.2\n{\n    private static final long serialVersionUID = 1;\n    /**\n     * Mutant factory method that will construct a new instance that is identical to\n     * this instance, except that it will have specified content value handler assigned.\n     * \n     * @return Newly created type instance\n     */\n    public abstract JavaType withContentValueHandler(Object h);\n\n    /**\n     * Mutant factory method that will try to copy handlers that the specified\n     * source type instance had, if any; this must be done recursively where\n     * necessary (as content types may be structured).\n     *\n     * @since 2.8.4\n     */\n\n    /**\n     * Mutant factory method that may be called on structured types\n     * that have a so-called content type (element of arrays, value type\n     * of Maps, referenced type of referential types),\n     * and will construct a new instance that is identical to\n     * this instance, except that it has specified content type, instead of current\n     * one. If content type is already set to given type, <code>this</code> is returned.\n     * If type does not have a content type (which is the case with\n     * <code>SimpleType</code>), @link IllegalArgumentException};\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testMapKeyRefinement1384() throws Exception\n    {\n        final String TEST_INSTANCE_SERIALIZED =\n                \"{\\\"mapProperty\\\":[\\\"java.util.HashMap\\\",{\\\"Compound|Key\\\":\\\"Value\\\"}]}\";\n        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);\n        assertEquals(1, testInstance.mapProperty.size());\n        Object key = testInstance.mapProperty.keySet().iterator().next();\n        assertEquals(CompoundKey.class, key.getClass());\n        String testInstanceSerialized = mapper.writeValueAsString(testInstance);\n        assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition);\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition);\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private String dateToString(java.util.Date value)\n    {\n        /* Then from String. This is bit tricky, since JDK does not really\n         * suggest a 'standard' format. So let's try using something...\n         */\n        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n        return df.format(value);\n    }\n    private static Calendar gmtCalendar(long time)\n    {\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n        c.setTimeInMillis(time);\n        return c;\n    }\n    public void testISO8601MissingSeconds() throws Exception\n    {\n        String inputStr;\n        Date inputDate;\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n    \n        inputStr = \"1997-07-16T19:20+01:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n        c.setTime(inputDate);\n        assertEquals(1997, c.get(Calendar.YEAR));\n        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n        assertEquals(0, c.get(Calendar.SECOND));\n        assertEquals(0, c.get(Calendar.MILLISECOND));\n}\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Serializer class that can serialize Object that have a\n * {@link com.fasterxml.jackson.annotation.JsonValue} annotation to\n * indicate that serialization should be done by calling the method\n * annotated, and serializing result it returns.\n *<p>\n * Implementation note: we will post-process resulting serializer\n * (much like what is done with {@link BeanSerializer})\n * to figure out actual serializers for final types.\n *  This must be done from {@link #createContextual} method, and NOT from constructor;\n * otherwise we could end up with an infinite loop.\n */\npublic class JsonValueSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, JsonFormatVisitable, SchemaAware\n    {\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<Object> _notNullClass(Class<?> cls);\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Serializer class that can serialize Object that have a\n * {@link com.fasterxml.jackson.annotation.JsonValue} annotation to\n * indicate that serialization should be done by calling the method\n * annotated, and serializing result it returns.\n *<p>\n * Implementation note: we will post-process resulting serializer\n * (much like what is done with {@link BeanSerializer})\n * to figure out actual serializers for final types.\n *  This must be done from {@link #createContextual} method, and NOT from constructor;\n * otherwise we could end up with an infinite loop.\n */\npublic class JsonValueSerializer\n    extends StdSerializer<Object>\n    implements ContextualSerializer, JsonFormatVisitable, SchemaAware\n    {\n    @SuppressWarnings(\"unchecked\")\n    private final static Class<Object> _notNullClass(Class<?> cls);\n    @Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testWithCreatorAndJsonValue() throws Exception\n    {\n        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        String json = mapper.writeValueAsString(new Bean1385Wrapper(\n                new Bean1385(BYTES)\n        ));\n        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);\n        assertNotNull(result);\n        assertNotNull(result.value);\n        assertEquals(Bean1385.class, result.value.getClass());\n        Bean1385 b = (Bean1385) result.value;\n        Assert.assertArrayEquals(BYTES, b.raw);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonParser.Feature... features);\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f);\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature);\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, JavaType valueType) throws IOException;\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonGenerator.Feature... features);\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer);\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser p, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Overridable helper method used to construct default {@link ClassIntrospector}\n     * to use.\n     * \n     * @since 2.5\n     */\n    protected ClassIntrospector defaultClassIntrospector();\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f);\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, Class<T> valueType) throws IOException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n}\n/**\n * Default {@link TypeResolverBuilder} implementation.\n */\npublic class StdTypeResolverBuilder\n    implements TypeResolverBuilder<StdTypeResolverBuilder>\n{\n    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes);\n    @Override\n    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes);\n    /**********************************************************\n     */\n\n    @Override\n    public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs);\n    /**\n     * Method for constructing an instance with specified type property name\n     * (property name to use for type id when using \"as-property\" inclusion).\n     */\n    @Override\n    public StdTypeResolverBuilder typeProperty(String typeIdPropName);\n    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * ObjectMapper provides functionality for reading and writing JSON,\n * either to and from basic POJOs (Plain Old Java Objects), or to and from\n * a general-purpose JSON Tree Model ({@link JsonNode}), as well as\n * related functionality for performing conversions.\n * It is also highly customizable to work both with different styles of JSON\n * content, and to support more advanced Object concepts such as\n * polymorphism and Object identity.\n * <code>ObjectMapper</code> also acts as a factory for more advanced {@link ObjectReader}\n * and {@link ObjectWriter} classes.\n * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will\n * use instances of {@link JsonParser} and {@link JsonGenerator}\n * for implementing actual reading/writing of JSON.\n * Note that although most read and write methods are exposed through this class,\n * some of the functionality is only exposed via {@link ObjectReader} and\n * {@link ObjectWriter}: specifically, reading/writing of longer sequences of\n * values is only available through {@link ObjectReader#readValues(InputStream)}\n * and {@link ObjectWriter#writeValues(OutputStream)}.\n *<p>\nSimplest usage is of form:\n<pre>\n  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!\n  MyValue value = new MyValue();\n  // ... and configure\n  File newState = new File(\"my-stuff.json\");\n  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance\n  // or, read\n  MyValue older = mapper.readValue(new File(\"my-older-stuff.json\"), MyValue.class);\n\n  // Or if you prefer JSON Tree representation:\n  JsonNode root = mapper.readTree(newState);\n  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:\n  int age = root.at(\"/personal/age\").getValueAsInt(); \n</pre>\n *<p>\n * The main conversion API is defined in {@link ObjectCodec}, so that\n * implementation details of this class need not be exposed to\n * streaming parser and generator classes. Usage via {@link ObjectCodec} is,\n * however, usually only for cases where dependency to {@link ObjectMapper} is\n * either not possible (from Streaming API), or undesireable (when only relying\n * on Streaming API).\n *<p> \n * Mapper instances are fully thread-safe provided that ALL configuration of the\n * instance occurs before ANY read or write calls. If configuration of a mapper\n * is modified after first usage, changes may or may not take effect, and configuration\n * calls themselves may fail.\n * If you need to use different configuration, you have two main possibilities:\n *<ul>\n * <li>Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.\n *    Both types are fully immutable and you can freely create new instances with different\n *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers\n *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is\n *    a very light-weight operation so it is usually appropriate to create these on per-call\n *    basis, as needed, for configuring things like optional indentation of JSON.\n *  </li>\n * <li>If the specific kind of configurability is not available via {@link ObjectReader} and\n *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:\n *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).\n *   To help with this usage, you may want to use method {@link #copy()} which creates a clone\n *   of the mapper with specific configuration, and allows configuration of the copied instance\n *   before it gets used. Note that {@link #copy} operation is as expensive as constructing\n *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers\n *   if you intend to use them for multiple operations.\n *  </li>\n * </ul>\n *<p>\n * Note on caching: root-level deserializers are always cached, and accessed\n * using full (generics-aware) type information. This is different from\n * caching of referenced types, which is more limited and is done only\n * for a subset of all deserializer types. The main reason for difference\n * is that at root-level there is no incoming reference (and hence no\n * referencing property, no referral information or annotations to\n * produce differing deserializers), and that the performance impact\n * greatest at root level (since it'll essentially cache the full\n * graph of deserializers involved).\n */\npublic class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonParser.Feature... features);\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f);\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature);\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, JavaType valueType) throws IOException;\n    /**\n     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * for parser instances this object mapper creates.\n     *<p>\n     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n     *\n     * @since 2.5\n     */\n    public ObjectMapper enable(JsonGenerator.Feature... features);\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer);\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser p, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content from given resource into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Overridable helper method used to construct default {@link ClassIntrospector}\n     * to use.\n     * \n     * @since 2.5\n     */\n    protected ClassIntrospector defaultClassIntrospector();\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f);\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException;\n    /**\n     * Method to deserialize JSON content from given file into given Java type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(DataInput src, Class<T> valueType) throws IOException;\n    /**\n     * Method to deserialize JSON content from given JSON content String.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException;\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     * \n     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n     *   network error) occurs (passed through as-is without additional wrapping -- note\n     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n     *   does NOT result in wrapping of exception even if enabled)\n     * @throws JsonParseException if underlying input contains invalid content\n     *    of type {@link JsonParser} supports (JSON for default case)\n     * @throws JsonMappingException if the input JSON structure does not match structure\n     *   expected for result type (or has other mismatch issues)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException;\n}\n/**\n * Default {@link TypeResolverBuilder} implementation.\n */\npublic class StdTypeResolverBuilder\n    implements TypeResolverBuilder<StdTypeResolverBuilder>\n{\n    @Override\n    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes);\n    @Override\n    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes);\n    /**********************************************************\n     */\n\n    @Override\n    public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs);\n    /**\n     * Method for constructing an instance with specified type property name\n     * (property name to use for type id when using \"as-property\" inclusion).\n     */\n    @Override\n    public StdTypeResolverBuilder typeProperty(String typeIdPropName);\n    @Override\n    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n            JavaType baseType, Collection<NamedType> subtypes);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDefaultTypingWithLong() throws Exception\n    {\n        Data data = new Data();\n        data.key = 1L;\n        Map<String, Object> mapData = new HashMap<String, Object>();\n        mapData.put(\"longInMap\", 2L);\n        mapData.put(\"longAsField\", data);\n\n        // Configure Jackson to preserve types\n        ObjectMapper mapper = new ObjectMapper();\n        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n        resolver.init(JsonTypeInfo.Id.CLASS, null);\n        resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n        resolver.typeProperty(\"__t\");\n        mapper.setDefaultTyping(resolver);\n        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n        // Serialize\n        String json = mapper.writeValueAsString(mapData);\n\n        // Deserialize\n        Map<?,?> result = mapper.readValue(json, Map.class);\n        assertNotNull(result);\n        assertEquals(2, result.size());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Basic serializer that can take JSON \"Array\" structure and\n * construct a {@link java.util.Collection} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.List}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\npublic class CollectionDeserializer\n    extends ContainerDeserializerBase<Collection<Object>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -1L; // since 2.5\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Basic serializer that can take JSON \"Array\" structure and\n * construct a {@link java.util.Collection} instance, with typed contents.\n *<p>\n * Note: for untyped content (one indicated by passing Object.class\n * as the type), {@link UntypedObjectDeserializer} is used instead.\n * It can also construct {@link java.util.List}s, but not with specific\n * POJO types, only other containers and primitives/wrappers.\n */\npublic class CollectionDeserializer\n    extends ContainerDeserializerBase<Collection<Object>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -1L; // since 2.5\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testUnmodifiable() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Class<?> unmodSetType = Collections.unmodifiableSet(Collections.<String>emptySet()).getClass();\n        mapper.addMixIn(unmodSetType, UnmodifiableSetMixin.class);\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n        final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";\n\n        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);\n        assertTrue(foo.isEmpty());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Checked exception used to signal fatal problems with mapping of\n * content, distinct from low-level I/O problems (signaled using\n * simple {@link java.io.IOException}s) or data encoding/decoding\n * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},\n * {@link com.fasterxml.jackson.core.JsonGenerationException}).\n *<p>\n * One additional feature is the ability to denote relevant path\n * of references (during serialization/deserialization) to help in\n * troubleshooting.\n */\npublic class JsonMappingException\n    extends JsonProcessingException\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method for accessing full structural path within type hierarchy\n     * down to problematic property.\n     */\n    public List<Reference> getPath();\n    /**\n     * @since 2.7\n     */\n    public static JsonMappingException from(JsonParser p, String msg);\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Checked exception used to signal fatal problems with mapping of\n * content, distinct from low-level I/O problems (signaled using\n * simple {@link java.io.IOException}s) or data encoding/decoding\n * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},\n * {@link com.fasterxml.jackson.core.JsonGenerationException}).\n *<p>\n * One additional feature is the ability to denote relevant path\n * of references (during serialization/deserialization) to help in\n * troubleshooting.\n */\npublic class JsonMappingException\n    extends JsonProcessingException\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Method for accessing full structural path within type hierarchy\n     * down to problematic property.\n     */\n    public List<Reference> getPath();\n    /**\n     * @since 2.7\n     */\n    public static JsonMappingException from(JsonParser p, String msg);\n    @Override\n    public String toString();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final ObjectMapper MAPPER = new ObjectMapper();\n\n    public void testReferenceChainForInnerClass() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new Outer());\n        try {\n            MAPPER.readValue(json, Outer.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            JsonMappingException.Reference reference = e.getPath().get(0);\n            assertEquals(getClass().getName()+\"$Outer[\\\"inner\\\"]\", reference.toString());\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class for {@link BeanSerializerFactory} that is used to\n * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n * to change behavior.\n */\npublic class PropertyBuilder\n{\n    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;\n    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testIssue1351() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n        assertEquals(aposToQuotes(\"{}\"), mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));\n        // [databind#1417]\n        assertEquals(aposToQuotes(\"{}\"), mapper.writeValueAsString(new Issue1351NonBean(0)));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link BeanDescription} implementation used by Jackson.\n *<p>\n * Although sub-classing is a theoretical possibility there are no known\n * use cases for that, nor is such usage tested or supported.\n * Separation from API is mostly to isolate some implementation details\n * here and keep API simple.\n */\npublic class BasicBeanDescription extends BeanDescription\n{\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes);\n    protected boolean isFactoryMethod(AnnotatedMethod am);\n}\n/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link BeanDescription} implementation used by Jackson.\n *<p>\n * Although sub-classing is a theoretical possibility there are no known\n * use cases for that, nor is such usage tested or supported.\n * Separation from API is mostly to isolate some implementation details\n * here and keep API simple.\n */\npublic class BasicBeanDescription extends BeanDescription\n{\n    @Override\n    public Method findFactoryMethod(Class<?>... expArgTypes);\n    protected boolean isFactoryMethod(AnnotatedMethod am);\n}\n/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDeserializeKeyViaFactory() throws Exception\n    {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\",\n                    new TypeReference<Map<FullName, Double>>() { });\n        Map.Entry<FullName, Double> entry = map.entrySet().iterator().next();\n        FullName key = entry.getKey();\n        assertEquals(key._firstname, \"first\");\n        assertEquals(key._lastname, \"last\");\n        assertEquals(entry.getValue().doubleValue(), 42, 0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public static StdKeyDeserializer forType(Class<?> raw);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public static StdKeyDeserializer forType(Class<?> raw);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testCustomEnumKeySerializerWithPolymorphic() throws IOException\n    {\n        SimpleModule simpleModule = new SimpleModule();\n        simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\n            @Override\n            public SuperTypeEnum deserialize(JsonParser p, DeserializationContext deserializationContext)\n                    throws IOException\n            {\n                return SuperTypeEnum.valueOf(p.getText());\n            }\n        });\n        ObjectMapper mapper = new ObjectMapper()\n                .registerModule(simpleModule);\n\n        SuperType superType = mapper.readValue(\"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\",\n                SuperType.class);\n        assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\", superType.someMap.get(SuperTypeEnum.FOO));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**********************************************************\n     */\n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**********************************************************\n     */\n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testCustomEnumValueAndKeyViaModifier() throws IOException\n    {\n        SimpleModule module = new SimpleModule();\n        module.setDeserializerModifier(new BeanDeserializerModifier() {        \n            @Override\n            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,\n                    final JavaType type, BeanDescription beanDesc,\n                    final JsonDeserializer<?> deserializer) {\n                return new JsonDeserializer<Enum>() {\n                    @Override\n                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        final String str = p.getValueAsString().toLowerCase();\n                        return KeyEnum.valueOf(rawClass, str);\n                    }\n                };\n            }\n\n            @Override\n            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,\n                    final JavaType type, KeyDeserializer deserializer)\n            {\n                if (!type.isEnumType()) {\n                    return deserializer;\n                }\n                return new KeyDeserializer() {\n                    @Override\n                    public Object deserializeKey(String key, DeserializationContext ctxt)\n                            throws IOException\n                    {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        return Enum.valueOf(rawClass, key.toLowerCase());\n                    }\n                };\n            }\n        });\n        ObjectMapper mapper = new ObjectMapper()\n                .registerModule(module);\n\n        // First, enum value as is\n        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),\n                KeyEnum.class);\n        assertSame(KeyEnum.replacements, key);\n\n        // and then as key\n        EnumMap<KeyEnum,String> map = mapper.readValue(\n                aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),\n                new TypeReference<EnumMap<KeyEnum,String>>() { });\n        assertEquals(1, map.size());\n        assertSame(KeyEnum.replacements, map.keySet().iterator().next());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    final private transient Annotations _classAnnotations;\n    @SuppressWarnings(\"incomplete-switch\")\n    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n    /**\n     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n     */\n    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException;\n    /**\n     * Method called to deserialize POJO value from a JSON floating-point\n     * number.\n     */\n    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException;\n    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException;\n    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException;\n    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n            DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for <code>BeanDeserializer</code>.\n */\npublic abstract class BeanDeserializerBase\n    extends StdDeserializer<Object>\n    implements ContextualDeserializer, ResolvableDeserializer,\n        java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    final private transient Annotations _classAnnotations;\n    @SuppressWarnings(\"incomplete-switch\")\n    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)\n        throws IOException;\n    /**\n     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n     */\n    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException;\n    /**\n     * Method called to deserialize POJO value from a JSON floating-point\n     * number.\n     */\n    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException;\n    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException;\n    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException;\n    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n            DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSuccessfulDeserializationOfObjectWithChainedArrayCreators() throws IOException\n    {\n        MAPPER.readValue(JSON, Bean1421A.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n            SettableBeanProperty[] properties);\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n            SettableBeanProperty[] injectables);\n    private <T extends AnnotatedMember> T _fixAccess(T member);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n            SettableBeanProperty[] properties);\n    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n            SettableBeanProperty[] injectables);\n    private <T extends AnnotatedMember> T _fixAccess(T member);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testConstructorChoice() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class);\n\n        assertEquals(1, pojo.getIntField());\n        assertEquals(\"foo\", pojo.getStringField());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException;\n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Utility class used for efficient storage of {@link JsonToken}\n * sequences, needed for temporary buffering.\n * Space efficient for different sequence lengths (especially so for smaller\n * ones; but not significantly less efficient for larger), highly efficient\n * for linear iteration and appending. Implemented as segmented/chunked\n * linked list of tokens; only modifications are via appends.\n *<p>\n * Note that before version 2.0, this class was located in the \"core\"\n * bundle, not data-binding; but since it was only used by data binding,\n * was moved here to reduce size of core package\n */\npublic class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException;\n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDelegateWithTokenBuffer() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n        assertNotNull(value);\n        Object ob = value.stuff;\n        assertEquals(TokenBuffer.class, ob.getClass());\n        JsonParser jp = ((TokenBuffer) ob).asParser();\n        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"a\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(1, jp.getIntValue());\n        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n        assertEquals(\"b\", jp.getCurrentName());\n        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n        assertEquals(2, jp.getIntValue());\n        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n        jp.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used for storing mapping from property name to\n * {@link SettableBeanProperty} instances.\n *<p>\n * Note that this class is used instead of generic {@link java.util.HashMap}\n * for bit of performance gain (and some memory savings): although default\n * implementation is very good for generic use cases, it can be streamlined\n * a bit for specific use case we have. Even relatively small improvements\n * matter since this is directly on the critical path during deserialization,\n * as it is done for each and every POJO property deserialized.\n */\npublic class BeanPropertyMap\n    implements Iterable<SettableBeanProperty>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 2L;\n    private int _hashMask;\n    private int _size;\n    private int _spillCount;\n    private Object[] _hashArea;\n    private SettableBeanProperty[] _propsInOrder;\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used for storing mapping from property name to\n * {@link SettableBeanProperty} instances.\n *<p>\n * Note that this class is used instead of generic {@link java.util.HashMap}\n * for bit of performance gain (and some memory savings): although default\n * implementation is very good for generic use cases, it can be streamlined\n * a bit for specific use case we have. Even relatively small improvements\n * matter since this is directly on the critical path during deserialization,\n * as it is done for each and every POJO property deserialized.\n */\npublic class BeanPropertyMap\n    implements Iterable<SettableBeanProperty>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 2L;\n    private int _hashMask;\n    private int _size;\n    private int _spillCount;\n    private Object[] _hashArea;\n    private SettableBeanProperty[] _propsInOrder;\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> */\npublic class TestUnwrapped extends BaseMapTest\n{\n    public void testCaseInsensitiveUnwrap() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n        Person p = mapper.readValue(\"{ }\", Person.class);\n        assertNotNull(p);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public static StdKeyDeserializer forType(Class<?> raw);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n * types Jackson supports.\n * Implemented as \"chameleon\" (or swiss pocket knife) class; not particularly elegant,\n * but helps reduce number of classes and jar size (class metadata adds significant\n * per-class overhead; much more than bytecode).\n */\npublic class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n    public static StdKeyDeserializer forType(Class<?> raw);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private void _doTestUntyped(final Map<String, ObjectWrapper> map)\n    {\n        ObjectWrapper w = map.get(\"double\");\n        assertNotNull(w);\n        assertEquals(Double.valueOf(42), w.getObject());\n        assertEquals(\"string\", map.get(\"string\").getObject());\n        assertEquals(Boolean.TRUE, map.get(\"boolean\").getObject());\n        assertEquals(Collections.singletonList(\"list0\"), map.get(\"list\").getObject());\n        assertTrue(map.containsKey(\"null\"));\n        assertNull(map.get(\"null\"));\n        assertEquals(5, map.size());\n    }\n    public void testcharSequenceKeyMap() throws Exception {\n        String JSON = aposToQuotes(\"{'a':'b'}\");\n        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertEquals(\"b\", result.get(\"a\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This sub-class is used to handle special case of value being a\n * non-static inner class. If so, we will have to use a special\n * alternative for default constructor; but otherwise can delegate\n * to regular implementation.\n */\npublic final class InnerClassProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void assignIndex(int index)  _delegate.assignIndex(index); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This sub-class is used to handle special case of value being a\n * non-static inner class. If so, we will have to use a special\n * alternative for default constructor; but otherwise can delegate\n * to regular implementation.\n */\npublic final class InnerClassProperty\n    extends SettableBeanProperty\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void assignIndex(int index)  _delegate.assignIndex(index); };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1501() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n        String ser = mapper.writeValueAsString(new Something());\n        mapper.readValue(ser, Something.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used for aggregating information about all possible\n * properties of a POJO.\n */\npublic class POJOPropertiesCollector\n{\n    /**********************************************************\n     */\n\n    public MapperConfig<?> getConfig();\n    /**\n     * Method called to further get rid of unwanted individual accessors,\n     * based on read/write settings and rules for \"pulling in\" accessors\n     * (or not).\n     */\n    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props);\n}\n/**\n * Helper class used for aggregating information about a single\n * potential POJO property.\n */\npublic class POJOPropertyBuilder\n    extends BeanPropertyDefinition\n    implements Comparable<POJOPropertyBuilder>\n{\n    /**\n     * @param inferMutators Whether mutators can be \"pulled in\" by visible\n     *    accessors or not. \n     */\n    public void removeNonVisible(boolean inferMutators);\n    /**\n     * Method called to remove all entries that are marked as\n     * ignored.\n     */\n    public void removeIgnored();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used for aggregating information about all possible\n * properties of a POJO.\n */\npublic class POJOPropertiesCollector\n{\n    /**********************************************************\n     */\n\n    public MapperConfig<?> getConfig();\n    /**\n     * Method called to further get rid of unwanted individual accessors,\n     * based on read/write settings and rules for \"pulling in\" accessors\n     * (or not).\n     */\n    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props);\n}\n/**\n * Helper class used for aggregating information about a single\n * potential POJO property.\n */\npublic class POJOPropertyBuilder\n    extends BeanPropertyDefinition\n    implements Comparable<POJOPropertyBuilder>\n{\n    /**\n     * @param inferMutators Whether mutators can be \"pulled in\" by visible\n     *    accessors or not. \n     */\n    public void removeNonVisible(boolean inferMutators);\n    /**\n     * Method called to remove all entries that are marked as\n     * ignored.\n     */\n    public void removeIgnored();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final ObjectMapper MAPPER = new ObjectMapper();\n\n    // [databind#935]\n    public void testReadOnlyAndWriteOnly() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReadXWriteY());\n        assertEquals(\"{\\\"x\\\":1}\", json);\n\n        ReadXWriteY result = MAPPER.readValue(\"{\\\"x\\\":5, \\\"y\\\":6}\", ReadXWriteY.class);\n        assertNotNull(result);\n        assertEquals(1, result.x);\n        assertEquals(6, result.y);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Type deserializer used with {@link As#PROPERTY}\n * inclusion mechanism.\n * Uses regular form (additional key/value entry before actual data)\n * when typed object is expressed as JSON Object; otherwise behaves similar to how\n * {@link As#WRAPPER_ARRAY} works.\n * Latter is used if JSON representation is polymorphic\n */\npublic class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Type deserializer used with {@link As#PROPERTY}\n * inclusion mechanism.\n * Uses regular form (additional key/value entry before actual data)\n * when typed object is expressed as JSON Object; otherwise behaves similar to how\n * {@link As#WRAPPER_ARRAY} works.\n * Latter is used if JSON representation is polymorphic\n */\npublic class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testWithEmptyStringAsNullObject1533() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n        AsPropertyWrapper wrapper = mapper.readValue(\"{ \\\"value\\\": \\\"\\\" }\", AsPropertyWrapper.class);\n        assertNull(wrapper.value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Standard serializer used for {@link java.lang.Enum} types.\n *<p>\n * Based on {@link StdScalarSerializer} since the JSON value is\n * scalar (String).\n */\npublic class EnumSerializer\n    extends StdScalarSerializer<Enum<?>>\n    implements ContextualSerializer\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}\n     * for constructing serializer instance of Enum types.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n            BeanDescription beanDesc, JsonFormat.Value format);\n    /**********************************************************\n     */\n    \n    protected final boolean _serializeAsIndex(SerializerProvider serializers);\n    /**\n     * To support some level of per-property configuration, we will need\n     * to make things contextual. We are limited to \"textual vs index\"\n     * choice here, however.\n     */\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Standard serializer used for {@link java.lang.Enum} types.\n *<p>\n * Based on {@link StdScalarSerializer} since the JSON value is\n * scalar (String).\n */\npublic class EnumSerializer\n    extends StdScalarSerializer<Enum<?>>\n    implements ContextualSerializer\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}\n     * for constructing serializer instance of Enum types.\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n            BeanDescription beanDesc, JsonFormat.Value format);\n    /**********************************************************\n     */\n    \n    protected final boolean _serializeAsIndex(SerializerProvider serializers);\n    /**\n     * To support some level of per-property configuration, we will need\n     * to make things contextual. We are limited to \"textual vs index\"\n     * choice here, however.\n     */\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testEnumPropertyAsNumber() throws Exception {\n        assertEquals(String.format(aposToQuotes(\"{'color':%s}\"), Color.GREEN.ordinal()), MAPPER.writeValueAsString(new ColorWrapper(Color.GREEN)));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class that handles deserialization using a separate\n * Builder class, which is used for data binding and\n * produces actual deserialized value at the end\n * of data binding.\n *<p>\n * Note on implementation: much of code has been copied from\n * {@link BeanDeserializer}; there may be opportunities to\n * refactor this in future.\n */\npublic class BuilderBasedDeserializer\n    extends BeanDeserializerBase\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class that handles deserialization using a separate\n * Builder class, which is used for data binding and\n * produces actual deserialized value at the end\n * of data binding.\n *<p>\n * Note on implementation: much of code has been copied from\n * {@link BeanDeserializer}; there may be opportunities to\n * refactor this in future.\n */\npublic class BuilderBasedDeserializer\n    extends BeanDeserializerBase\n{\n    private static final long serialVersionUID = 1L;\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception {\n        final String json = aposToQuotes(\"{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Person person = mapper.readValue(json, Person.class);\n        assertEquals(1234, person.getId());\n        assertNotNull(person.getName());\n        assertEquals(\"John\", person.getName().getFirst());\n        assertEquals(\"Doe\", person.getName().getLast());\n        assertEquals(30, person.getAge());\n        assertEquals(true, person.isAlive());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1599() throws Exception\n    {\n        final String JSON = aposToQuotes(\n \"{'id': 124,\\n\"\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n+\"  {\\n\"\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n+\"    'transletName' : 'a.b',\\n\"\n+\"    'outputProperties' : { }\\n\"\n+\"  }\\n\"\n+\" ]\\n\"\n+\"}\"\n        );\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        try {\n            mapper.readValue(JSON, Bean1599.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Illegal type\");\n            verifyException(e, \"to deserialize\");\n            verifyException(e, \"prevented for security reasons\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method that {@link DeserializerCache}s call to create a new\n     * deserializer for types other than Collections, Maps, arrays and\n     * enums.\n     */\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException;\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    @Override\n    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1599() throws Exception\n    {\n        final String JSON = aposToQuotes(\n \"{'id': 124,\\n\"\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n+\"  {\\n\"\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n+\"    'transletName' : 'a.b',\\n\"\n+\"    'outputProperties' : { }\\n\"\n+\"  }\\n\"\n+\" ]\\n\"\n+\"}\"\n        );\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        try {\n            mapper.readValue(JSON, Bean1599.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Illegal type\");\n            verifyException(e, \"to deserialize\");\n            verifyException(e, \"prevented for security reasons\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann);\n}\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException;\n}\n/**\n * Container object that encapsulates information usually\n * derived from {@link JsonIdentityInfo} annotation or its\n * custom alternatives\n */\npublic class ObjectIdInfo\n{\n    public ObjectIdInfo withAlwaysAsId(boolean state);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectIdInfo findObjectIdInfo(Annotated ann);\n}\n/**\n * Base class both for the standard bean serializer, and couple\n * of variants that only differ in small details.\n * Can be used for custom bean serializers as well, although that\n * is not the primary design goal.\n */\npublic abstract class BeanSerializerBase\n    extends StdSerializer<Object>\n    implements ContextualSerializer, ResolvableSerializer,\n        JsonFormatVisitable, SchemaAware\n{\n    @SuppressWarnings(\"incomplete-switch\")\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException;\n}\n/**\n * Container object that encapsulates information usually\n * derived from {@link JsonIdentityInfo} annotation or its\n * custom alternatives\n */\npublic class ObjectIdInfo\n{\n    public ObjectIdInfo withAlwaysAsId(boolean state);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIssue1607() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer());\n        assertEquals(aposToQuotes(\"{'alwaysClass':1,'alwaysProp':2}\"), json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Container class for storing information on creators (based on annotations,\n * visibility), to be able to build actual instantiator later on.\n */\npublic class CreatorCollector\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private static String asArray(Object value) {\n        final String stringVal = value.toString();\n        return new StringBuilder(stringVal.length() + 2).append(\"[\").append(stringVal).append(\"]\").toString();\n    }\n    public void testStringBuilder() throws Exception\n    {\n        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);\n        assertEquals(\"abc\", sb.toString());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Standard {@link SubtypeResolver} implementation.\n */\npublic class StdSubtypeResolver\n    extends SubtypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, \n            AnnotatedMember property, JavaType baseType);\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config,\n            AnnotatedClass baseType);\n    /**********************************************************\n     */\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, \n            AnnotatedMember property, JavaType baseType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Standard {@link SubtypeResolver} implementation.\n */\npublic class StdSubtypeResolver\n    extends SubtypeResolver\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, \n            AnnotatedMember property, JavaType baseType);\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config,\n            AnnotatedClass baseType);\n    /**********************************************************\n     */\n\n    @Override\n    public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, \n            AnnotatedMember property, JavaType baseType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final ObjectMapper MAPPER = objectMapper();\n\n    public void testBaseTypeId1616() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                mapper.getDeserializationConfig(),\n                // note: `null` is fine here as `AnnotatedMember`:\n                null,\n                mapper.constructType(Base1616.class));\n        assertEquals(2, subtypes.size());\n        Set<String> ok = new HashSet<>(Arrays.asList(\"A\", \"B\"));\n        for (NamedType type : subtypes) {\n            String id = type.getName();\n            if (!ok.contains(id)) {\n                fail(\"Unexpected id '\"+id+\"' (mapping to: \"+type.getType()+\"), should be one of: \"+ok);\n            }\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n    \n    @Override\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link AnnotationIntrospector} implementation that handles standard\n * Jackson annotations.\n */\npublic class JacksonAnnotationIntrospector\n    extends AnnotationIntrospector\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n    \n    @Override\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final ObjectMapper MAPPER = new ObjectMapper();\n\n    public void testTypeCoercion1592() throws Exception\n    {\n        // first, serialize\n        MAPPER.writeValueAsString(new Bean1592());\n        Bean1592 result = MAPPER.readValue(\"{}\", Bean1592.class);\n        assertNotNull(result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testIgnoreGetterNotSetter1595() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Simple1595 config = new Simple1595();\n        config.setId(123);\n        config.setName(\"jack\");\n        String json = mapper.writeValueAsString(config);\n        assertEquals(aposToQuotes(\"{'id':123}\"), json);\n        Simple1595 des = mapper.readValue(aposToQuotes(\"{'id':123,'name':'jack'}\"), Simple1595.class);\n        assertEquals(\"jack\", des.getName());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base class for simple deserializers that only accept JSON String\n * values as the source.\n */\npublic abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testWeirdStringHandling() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))\n            ;\n        SingleValuedEnum result = mapper.readValue(\"\\\"B\\\"\", SingleValuedEnum.class);\n        assertEquals(SingleValuedEnum.A, result);\n\n        // also, write [databind#1629] try this\n        mapper = new ObjectMapper()\n                .addHandler(new WeirdStringHandler(null));\n        UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);\n        assertNull(result2);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Internal placeholder type used for self-references.\n *\n * @since 2.7\n */\npublic class ResolvedRecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    public void setReference(JavaType ref);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Internal placeholder type used for self-references.\n *\n * @since 2.7\n */\npublic class ResolvedRecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    public void setReference(JavaType ref);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        tf.constructType(Base.class);\n        tf.constructType(Sub.class);\n        Sub sub = new Sub();\n        String serialized = objectMapper().writeValueAsString(sub);\n        assertEquals(\"{\\\"base\\\":1,\\\"sub\\\":2}\", serialized);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public abstract class DateTimeSerializerBase<T>\n    extends StdScalarSerializer<T>\n    implements ContextualSerializer\n{\n    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testFormatWithoutPattern() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\"));\n        String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01X01:00:00'}\"), json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Internal placeholder type used for self-references.\n *\n * @since 2.7\n */\npublic class ResolvedRecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    public void setReference(JavaType ref);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Internal placeholder type used for self-references.\n *\n * @since 2.7\n */\npublic class ResolvedRecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n    public void setReference(JavaType ref);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testSuperClassWithReferencedJavaType() {\n        TypeFactory tf = objectMapper().getTypeFactory();\n        tf.constructType(Base.class); // must be constructed before sub to set the cache correctly\n        JavaType subType = tf.constructType(Sub.class);\n        // baseTypeFromSub should be a ResolvedRecursiveType in this test\n        JavaType baseTypeFromSub = subType.getSuperClass();\n        assertNotNull(baseTypeFromSub.getSuperClass());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone();\n    public static TimeZone getDefaultTimeZone();\n    /**********************************************************\n     */\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition);\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)\n            throws ParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\npublic class StdDateFormat\n    extends DateFormat\n{\n    public final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n    /**********************************************************\n     */\n\n    @Override // since 2.6\n    public TimeZone getTimeZone();\n    public static TimeZone getDefaultTimeZone();\n    /**********************************************************\n     */\n    \n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition);\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)\n            throws ParseException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    private String dateToString(java.util.Date value)\n    {\n        /* Then from String. This is bit tricky, since JDK does not really\n         * suggest a 'standard' format. So let's try using something...\n         */\n        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n        return df.format(value);\n    }\n    private static Calendar gmtCalendar(long time)\n    {\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n        c.setTimeInMillis(time);\n        return c;\n    }\n    public void testDateUtilISO8601NoTimezoneNonDefault() throws Exception\n    {\n        // In first case, no timezone -> SHOULD use configured timezone\n        ObjectReader r = MAPPER.readerFor(Date.class);\n        TimeZone tz = TimeZone.getTimeZone(\"GMT-2\");\n        Date date1 = r.with(tz)\n                .readValue(quote(\"1970-01-01T00:00:00.000\"));\n        // Second case, should use specified timezone, not configured\n        Date date2 = r.with(TimeZone.getTimeZone(\"GMT+5\"))\n                .readValue(quote(\"1970-01-01T00:00:00.000-02:00\"));\n        assertEquals(date1, date2);\n\n        // also verify actual value, in GMT\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n        c.setTime(date1);\n        assertEquals(1970, c.get(Calendar.YEAR));\n        assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));\n        assertEquals(1, c.get(Calendar.DAY_OF_MONTH));\n        assertEquals(2, c.get(Calendar.HOUR_OF_DAY));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link com.fasterxml.jackson.databind.jsontype.TypeIdResolver} implementation\n * that converts between fully-qualified\n * Java class names and (JSON) Strings.\n */\npublic class ClassNameIdResolver\n    extends TypeIdResolverBase\n{\n    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link com.fasterxml.jackson.databind.jsontype.TypeIdResolver} implementation\n * that converts between fully-qualified\n * Java class names and (JSON) Strings.\n */\npublic class ClassNameIdResolver\n    extends TypeIdResolverBase\n{\n    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testNestedTypeCheck1735() throws Exception\n    {\n        try {\n            MAPPER.readValue(aposToQuotes(\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n                    Wrapper1735.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"not subtype of\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _testTypes1737(Class<?> nasty) throws Exception {\n        _testTypes1737(nasty.getName());\n    }\n    private void _testTypes1737(String clsName) throws Exception\n    {\n        // While usually exploited via default typing let's not require\n        // it here; mechanism still the same\n        String json = aposToQuotes(\n                \"{'v':['\"+clsName+\"','/tmp/foobar.txt']}\"\n                );\n        try {\n            MAPPER.readValue(json, PolyWrapper.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            _verifySecurityException(e, clsName);\n        }\n    }\n    public void testJDKTypes1737() throws Exception\n    {\n        _testTypes1737(java.util.logging.FileHandler.class);\n        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized serializer that can be used as the generic key\n * serializer, when serializing {@link java.util.Map}s to JSON\n * Objects.\n */\npublic class StdKeySerializer extends StdSerializer<Object>\n{\n    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized serializer that can be used as the generic key\n * serializer, when serializing {@link java.util.Map}s to JSON\n * Objects.\n */\npublic class StdKeySerializer extends StdSerializer<Object>\n{\n    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{\n    public void testClassKey() throws IOException\n    {\n        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();\n        map.put(String.class, 2);\n        String json = MAPPER.writeValueAsString(map);\n        assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class that defines simple API implemented by objects that create value\n * instances.  Some or all of properties of value instances may \n * be initialized by instantiator, rest being populated by deserializer,\n * to which value instance is passed.\n * Since different kinds of JSON values (structured and scalar)\n * may be bound to Java values, in some cases instantiator\n * fully defines resulting value; this is the case when JSON value\n * is a scalar value (String, number, boolean).\n *<p>\n * Note that this type is not parameterized (even though it would seemingly\n * make sense), because such type information can not be use effectively\n * during runtime: access is always using either wildcard type, or just\n * basic {@link java.lang.Object}; and so adding type parameter seems\n * like unnecessary extra work.\n *<p>\n * Actual implementations are strongly recommended to be based on\n * {@link com.fasterxml.jackson.databind.deser.std.StdValueInstantiator}\n * which implements all methods, and as such will be compatible\n * across versions even if new methods were added to this interface.\n */\npublic abstract class ValueInstantiator\n{\n    /**\n     * Method that returns description of the value type this instantiator\n     * handles. Used for error messages, diagnostics.\n     */\n    public String getValueTypeDesc();\n}\n/**\n * Default {@link ValueInstantiator} implementation, which supports\n * Creator methods that can be indicated by standard Jackson\n * annotations.\n */\npublic class StdValueInstantiator\n    extends ValueInstantiator\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public boolean canCreateFromObjectWith();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class that defines simple API implemented by objects that create value\n * instances.  Some or all of properties of value instances may \n * be initialized by instantiator, rest being populated by deserializer,\n * to which value instance is passed.\n * Since different kinds of JSON values (structured and scalar)\n * may be bound to Java values, in some cases instantiator\n * fully defines resulting value; this is the case when JSON value\n * is a scalar value (String, number, boolean).\n *<p>\n * Note that this type is not parameterized (even though it would seemingly\n * make sense), because such type information can not be use effectively\n * during runtime: access is always using either wildcard type, or just\n * basic {@link java.lang.Object}; and so adding type parameter seems\n * like unnecessary extra work.\n *<p>\n * Actual implementations are strongly recommended to be based on\n * {@link com.fasterxml.jackson.databind.deser.std.StdValueInstantiator}\n * which implements all methods, and as such will be compatible\n * across versions even if new methods were added to this interface.\n */\npublic abstract class ValueInstantiator\n{\n    /**\n     * Method that returns description of the value type this instantiator\n     * handles. Used for error messages, diagnostics.\n     */\n    public String getValueTypeDesc();\n}\n/**\n * Default {@link ValueInstantiator} implementation, which supports\n * Creator methods that can be indicated by standard Jackson\n * annotations.\n */\npublic class StdValueInstantiator\n    extends ValueInstantiator\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    @Override\n    public boolean canCreateFromObjectWith();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDelegatingArray1804() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        MyType thing = mapper.readValue(\"[]\", MyType.class);\n        assertNotNull(thing);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Class that defines caching layer between callers (like\n * {@link ObjectMapper},\n * {@link com.fasterxml.jackson.databind.DeserializationContext})\n * and classes that construct deserializers\n * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n */\npublic final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testCachedSerialize() throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        String json = aposToQuotes(\"{'data':{'1st':'onedata','2nd':'twodata'}}\");\n\n        // Do deserialization with non-annotated map property\n        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);\n        assertTrue(ignored.data.containsKey(\"1st\"));\n        assertTrue(ignored.data.containsKey(\"2nd\"));\n\n//mapper = new ObjectMapper();\n        \n        MapHolder model2 = mapper.readValue(json, MapHolder.class);\n        if (!model2.data.containsKey(\"1st (CUSTOM)\")\n            || !model2.data.containsKey(\"2nd (CUSTOM)\")) {\n            fail(\"Not using custom key deserializer for input: \"+json+\"; resulted in: \"+model2.data);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Concrete deserializer factory class that adds full Bean deserializer\n * construction logic using class introspection.\n * Note that factories specifically do not implement any form of caching:\n * aside from configuration they are stateless; caching is implemented\n * by other components.\n *<p>\n * Instances of this class are fully immutable as all configuration is\n * done by using \"fluent factories\" (methods that construct new factory\n * instances with different configuration, instead of modifying instance).\n */\npublic class BeanDeserializerFactory\n    extends BasicDeserializerFactory\n    implements java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1;\n    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n    /**\n     * Method used by module registration functionality, to construct a new bean\n     * deserializer factory\n     * with different configuration settings.\n     */\n    @Override\n    public DeserializerFactory withConfig(DeserializerFactoryConfig config);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _testTypes1737(Class<?> nasty) throws Exception {\n        _testTypes1737(nasty.getName());\n    }\n    private void _testTypes1737(String clsName) throws Exception\n    {\n        // While usually exploited via default typing let's not require\n        // it here; mechanism still the same\n        String json = aposToQuotes(\n                \"{'v':['\"+clsName+\"','/tmp/foobar.txt']}\"\n                );\n        try {\n            MAPPER.readValue(json, PolyWrapper.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            _verifySecurityException(e, clsName);\n        }\n    }\n    public void testJDKTypes1737() throws Exception\n    {\n        _testTypes1737(java.util.logging.FileHandler.class);\n        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _testIllegalType(Class<?> nasty) throws Exception {\n        _testIllegalType(nasty.getName());\n    }\n    private void _testIllegalType(String clsName) throws Exception\n    {\n        // While usually exploited via default typing let's not require\n        // it here; mechanism still the same\n        String json = aposToQuotes(\n                \"{'v':['\"+clsName+\"','/tmp/foobar.txt']}\"\n                );\n        try {\n            MAPPER.readValue(json, PolyWrapper.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            _verifySecurityException(e, clsName);\n        }\n    }\n    public void testJDKTypes1872() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n    \n        String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",\n                Authentication1872.class.getName()));\n        Authentication1872 result = mapper.readValue(json, Authentication1872.class);\n        assertNotNull(result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    public static SubTypeValidator instance()  return instance; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    public static SubTypeValidator instance()  return instance; };\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private void _testIllegalType(Class<?> nasty) throws Exception {\n        _testIllegalType(nasty.getName());\n    }\n    private void _testIllegalType(String clsName) throws Exception\n    {\n        // While usually exploited via default typing let's not require\n        // it here; mechanism still the same\n        String json = aposToQuotes(\n                \"{'v':['\"+clsName+\"','/tmp/foobar.txt']}\"\n                );\n        try {\n            MAPPER.readValue(json, PolyWrapper.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            _verifySecurityException(e, clsName);\n        }\n    }\n    public void testC3P0Types() throws Exception\n    {\n        _testIllegalType(ComboPooledDataSource.class); // [databind#1931]\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple recursive-descent parser for parsing canonical {@link JavaType}\n * representations and constructing type instances.\n */\npublic class TypeParser\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException;\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass);\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass,\n            Class<?> keyClass, Class<?> valueClass);\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses);\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance()  return instance; };\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType);\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple recursive-descent parser for parsing canonical {@link JavaType}\n * representations and constructing type instances.\n */\npublic class TypeParser\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException;\n}\n/**\n * Class used for creating concrete {@link JavaType} instances,\n * given various inputs.\n *<p>\n * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n * as well as many objects it constructs (like\n* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n * but usually those objects also \n * expose convenience methods (<code>constructType</code>).\n * So, you can do for example:\n *<pre>\n *   JavaType stringType = mapper.constructType(String.class);\n *</pre>\n * However, more advanced methods are only exposed by factory so that you\n * may need to use:\n *<pre>\n *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n *</pre>\n */\npublic final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n    private final static Class<?> CLS_STRING = String.class;\n    private final static Class<?> CLS_OBJECT = Object.class;\n    private final static Class<?> CLS_COMPARABLE = Comparable.class;\n    private final static Class<?> CLS_CLASS = Class.class;\n    private final static Class<?> CLS_ENUM = Enum.class;\n    private final static Class<?> CLS_BOOL = Boolean.TYPE;\n    private final static Class<?> CLS_INT = Integer.TYPE;\n    private final static Class<?> CLS_LONG = Long.TYPE;\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, Class<?> contextClass);\n    public JavaType constructType(TypeReference<?> typeRef);\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException;\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type);\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass,\n            Class<?> keyClass, Class<?> valueClass);\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);\n     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);\n     *</pre>\n     *<p>\n     * The reason for first two arguments to be separate is that parameterization may\n     * apply to a super-type. For example, if generic type was instead to be\n     * constructed for <code>ArrayList&lt;Integer></code>, the usual call would be:\n     *<pre>\n     *  TypeFactory.constructParametrizedType(ArrayList.class, List.class, Integer.class);\n     *</pre>\n     * since parameterization is applied to {@link java.util.List}.\n     * In most cases distinction does not matter, but there are types where it does;\n     * one such example is parameterization of types that implement {@link java.util.Iterator}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type.\n     * \n     * @param parametrized Actual full type\n     * @param parameterClasses Type parameters to apply\n     *\n     * @since 2.5 NOTE: was briefly deprecated for 2.6\n     */\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses);\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance()  return instance; };\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType);\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer&gt;\"\n     * from \"Map&lt;String,Integer&gt;\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass);\n    public JavaType constructType(Type type, TypeBindings bindings);\n    /**\n     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n     */\n    @Deprecated\n    public JavaType constructType(Type type, JavaType contextType);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{    \n    public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        assertEquals(\"java.util.Calendar\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        assertEquals(List.class, t.getRawClass());\n        assertEquals(CollectionType.class, t.getClass());\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        assertEquals(Object.class, t.getContentType().getRawClass());\n        can = t.toCanonical();\n        assertEquals(\"java.util.List<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Abstract factory base class that can provide deserializers for standard\n * JDK classes, including collection classes and simple heuristics for\n * \"upcasting\" common collection interface types\n * (such as {@link java.util.Collection}).\n *<p>\n * Since all simple deserializers are eagerly instantiated, and there is\n * no additional introspection or customizability of these types,\n * this factory is stateless.\n */\npublic abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final ObjectMapper MAPPER = newObjectMapper()\n            .setAnnotationIntrospector(new MyParamIntrospector())\n            .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)\n            ;\n\n    // [databind#2051]\n    public void testSnakeCaseWithOneArg() throws Exception\n    {\n        final String MSG = \"1st\";\n        OneProperty actual = MAPPER.readValue(\n                \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",\n                OneProperty.class);\n        assertEquals(\"CTOR:\"+MSG, actual.paramName0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Value node that contains a wrapped POJO, to be serialized as\n * a JSON constructed through data mapping (usually done by\n * calling {@link com.fasterxml.jackson.databind.ObjectMapper}).\n */\npublic class POJONode\n    extends ValueNode\n{\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Value node that contains a wrapped POJO, to be serialized as\n * a JSON constructed through data mapping (usually done by\n * calling {@link com.fasterxml.jackson.databind.ObjectMapper}).\n */\npublic class POJONode\n    extends ValueNode\n{\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testPOJONodeCustomSer() throws Exception\n    {\n      Data data = new Data();\n      data.aStr = \"Hello\";\n\n      Map<String, Object> mapTest = new HashMap<>();\n      mapTest.put(\"data\", data);\n\n      ObjectNode treeTest = MAPPER.createObjectNode();\n      treeTest.putPOJO(\"data\", data);\n\n      final String EXP = \"{\\\"data\\\":{\\\"aStr\\\":\\\"The value is: Hello!\\\"}}\";\n      \n      String mapOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\n      assertEquals(EXP, mapOut);\n\n      String treeOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\n      assertEquals(EXP, treeOut);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final JavaType _beanType;\n    private final ExtTypedProperty[] _properties;\n    private final Map<String, Object> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Helper class that is used to flatten JSON structure when using\n * \"external type id\" (see {@link com.fasterxml.jackson.annotation.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n * This is needed to store temporary state and buffer tokens, as the structure is\n * rearranged a bit so that actual type deserializer can resolve type and \n * finalize deserialization.\n */\npublic class ExternalTypeHandler\n{\n    private final JavaType _beanType;\n    private final ExtTypedProperty[] _properties;\n    private final Map<String, Object> _nameToPropertyIndex;\n    private final String[] _typeIds;\n    private final TokenBuffer[] _tokens;\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testExample() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        \n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(Arrays.asList(new AnimalAndType(AnimalType.Dog, new Dog())));\n        List<AnimalAndType> list = mapper.readerFor(new TypeReference<List<AnimalAndType>>() { })\n            .readValue(json);\n        assertNotNull(list);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType();\n    @Override\n    protected String buildCanonicalName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Specialized {@link SimpleType} for types that are referential types,\n * that is, values that can be dereferenced to another value (or null),\n * of different type.\n * Referenced type is accessible using {@link #getContentType()}.\n * \n * @since 2.6\n */\npublic class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType();\n    @Override\n    protected String buildCanonicalName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    extends BaseMapTest\n{    \n    public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        assertEquals(\"java.util.Calendar\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#2109]: also ReferenceTypes\n        t = tf.constructType(new TypeReference<AtomicReference<Long>>() { });\n        can = t.toCanonical();\n        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n\n        // [databind#1941]: allow \"raw\" types too\n        t = tf.constructFromCanonical(\"java.util.List\");\n        assertEquals(List.class, t.getRawClass());\n        assertEquals(CollectionType.class, t.getClass());\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        assertEquals(Object.class, t.getContentType().getRawClass());\n        can = t.toCanonical();\n        assertEquals(\"java.util.List<java.lang.Object>\", can);\n        assertEquals(t, tf.constructFromCanonical(can));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n    @Override\n    public JsonToken nextToken() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n    @Override\n    public JsonToken nextToken() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private final XmlMapper MAPPER = new XmlMapper();\n\n    public void testNestedUnwrappedLists180() throws Exception\n    {\n        /*\n        Records recs = new Records();\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.get(0).fields.add(new Field(\"a\"));\n        recs.records.get(2).fields.add(new Field(\"b\"));\n\n        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n        */\n\n        String xml =\n\"<Records>\\n\"\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n//+\"<records>\\n</records>\\n\"\n+\"<records></records>\\n\"\n+\"  <records>\\n\"\n+\"   <fields name='b'/>\\n\"\n+\"  </records>\\n\"\n+\"</Records>\\n\"\n;\n        \n//System.out.println(\"XML: \"+xml);\n\n        Records result = MAPPER.readValue(xml, Records.class);\n        assertNotNull(result.records);\n        assertEquals(2, result.records.size());\n        assertNotNull(result.records.get(1));\n        assertEquals(1, result.records.get(1).fields.size());\n        assertEquals(\"b\", result.records.get(1).fields.get(0).name);\n\n        // also, first one ought not be null should it? Ideally not...\n        assertNotNull(result.records.get(0));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n * abstract out all irrelevant details, and to expose equivalent of flat token\n * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n * content) all of which is just to simplify\n * actual higher-level conversion to JSON tokens\n */\npublic class XmlTokenStream\n{\n    public final static int XML_START_ELEMENT = 1;\n    public final static int XML_END_ELEMENT = 2;\n    public final static int XML_ATTRIBUTE_NAME = 3;\n    public final static int XML_ATTRIBUTE_VALUE = 4;\n    public final static int XML_TEXT = 5;\n    public final static int XML_END = 6;\n    private final static int REPLAY_START_DUP = 1;\n    private final static int REPLAY_END = 2;\n    private final static int REPLAY_START_DELAYED = 3;\n    private JsonLocation _extractLocation(XMLStreamLocation2 location);\n    public XMLStreamReader2 getXmlReader();\n    /**********************************************************************\n     */\n\n    private final int _next() throws XMLStreamException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n * abstract out all irrelevant details, and to expose equivalent of flat token\n * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n * content) all of which is just to simplify\n * actual higher-level conversion to JSON tokens\n */\npublic class XmlTokenStream\n{\n    public final static int XML_START_ELEMENT = 1;\n    public final static int XML_END_ELEMENT = 2;\n    public final static int XML_ATTRIBUTE_NAME = 3;\n    public final static int XML_ATTRIBUTE_VALUE = 4;\n    public final static int XML_TEXT = 5;\n    public final static int XML_END = 6;\n    private final static int REPLAY_START_DUP = 1;\n    private final static int REPLAY_END = 2;\n    private final static int REPLAY_START_DELAYED = 3;\n    private JsonLocation _extractLocation(XMLStreamLocation2 location);\n    public XMLStreamReader2 getXmlReader();\n    /**********************************************************************\n     */\n\n    private final int _next() throws XMLStreamException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testMixedContent() throws Exception\n    {\n        WindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\n                WindSpeed.class);\n        assertEquals(27, result.value);\n        assertNotNull(result.radius);\n        assertEquals(20, result.radius.value);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException;\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n    @Override\n    public JsonToken nextToken() throws IOException;\n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException;\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException;\n    @Override\n    public void close() throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testXmlAttributesWithNextTextValue() throws Exception\n    {\n        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n\n        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n\n        // First: verify handling without forcing array handling:\n        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\n        assertEquals(\"max\", xp.getCurrentName());\n\n        assertEquals(\"7\", xp.nextTextValue());\n\n        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n        assertEquals(\"offset\", xp.getCurrentName());\n\n        assertEquals(\"offset\", xp.getText());\n\n        assertEquals(\"9\", xp.nextTextValue());\n\n        assertEquals(\"9\", xp.getText());\n\n        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n        xp.close();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    private static final long serialVersionUID = 1L;\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    private static final long serialVersionUID = 1L;\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testDynamicRootName() throws IOException\n    {\n        String xml;\n\n        ObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\n\n        xml = w.writeValueAsString(new StringBean(\"foo\"));\n        assertEquals(\"<rudy><text>foo</text></rudy>\", xml);\n\n        xml = w.writeValueAsString(new StringBean(null));\n        assertEquals(\"<rudy><text/></rudy>\", xml);\n\n        // and even with null will respect configured root name\n        xml = w.writeValueAsString(null);\n        assertEquals(\"<rudy/>\", xml);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    private static final long serialVersionUID = 1L;\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    public void testCopyWith() throws Exception\n    {\n        XmlMapper xmlMapper = newMapper();\n        final ObjectMapper xmlMapperNoAnno = xmlMapper.copy()\n                .disable(MapperFeature.USE_ANNOTATIONS)\n                .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n\n        String xml1 = xmlMapper.writeValueAsString(new Pojo282());\n        String xml2 = xmlMapperNoAnno.writeValueAsString(new Pojo282());\n\n        if (!xml1.contains(\"AnnotatedName\")) {\n            fail(\"Should use name 'AnnotatedName', xml = \"+xml1);\n        }\n        if (!xml2.contains(\"Pojo282\")\n                || xml2.contains(\"AnnotatedName\")) {\n            fail(\"Should NOT use name 'AnnotatedName' but 'Pojo282', xml = \"+xml1);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n * Operation requires calling code (usually either standard Jackson serializers,\n * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n * additional configuration calls beyond regular {@link JsonGenerator} API,\n * mostly to pass namespace information.\n */\npublic final class ToXmlGenerator\n    extends GeneratorBase\n{\n    @Override\n    public void writeNull() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n    \t\tbyte[] data, int offset, int len) throws IOException;\n    private byte[] toFullBuffer(byte[] data, int offset, int len);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n * Operation requires calling code (usually either standard Jackson serializers,\n * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n * additional configuration calls beyond regular {@link JsonGenerator} API,\n * mostly to pass namespace information.\n */\npublic final class ToXmlGenerator\n    extends GeneratorBase\n{\n    @Override\n    public void writeNull() throws IOException;\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n    \t\tbyte[] data, int offset, int len) throws IOException;\n    private byte[] toFullBuffer(byte[] data, int offset, int len);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>{\n    private TestPojo createPojo(char... content) {\n        TestPojo obj = new TestPojo();\n        // DirectByteBuffer does not have an underlying array\n        // so the ByteArraySerializer has to fallback to stream writing\n        obj.field = ByteBuffer.allocateDirect(content.length);\n        for(char b : content) {\n            obj.field.put((byte) b);\n        }\n        obj.field.position(0);\n        return obj;\n    }\n    public void testWith0Bytes() throws Exception \n    {\n        String xml = MAPPER.writeValueAsString(createPojo());\n        assertEquals(\"<TestPojo><field/></TestPojo>\", xml);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public int getLength();\n    public static boolean testNode(Node node, NodeTest test);\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    public int getLength();\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public int getLength();\n    public static boolean testNode(Node node, NodeTest test);\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    public int getLength();\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void appendXMLSignature(\n        StringBuffer buffer,\n        Object object,\n        boolean elements,\n        boolean attributes,\n        boolean text,\n        boolean pi) \n    {\n        Node node = (Node) object;\n        int type = node.getNodeType();\n        switch (type) {\n            case Node.DOCUMENT_NODE :\n                buffer.append(\"<D>\");\n                appendXMLSignature(\n                    buffer,\n                    node.getChildNodes(),\n                    elements,\n                    attributes,\n                    text,\n                    pi);\n                buffer.append(\"</D\");\n                break;\n\n            case Node.ELEMENT_NODE :\n                String tag = elements ? ((Element) node).getTagName() : \"E\";\n                buffer.append(\"<\");\n                buffer.append(tag);\n                buffer.append(\">\");\n                appendXMLSignature(\n                    buffer,\n                    node.getChildNodes(),\n                    elements,\n                    attributes,\n                    text,\n                    pi);\n                buffer.append(\"</\");\n                buffer.append(tag);\n                buffer.append(\">\");\n                break;\n\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                if (text) {\n                    String string = node.getNodeValue();\n                    string = string.replace('\\n', '=');\n                    buffer.append(string);\n                }\n                break;\n        }\n    }\n    private void appendXMLSignature(\n        StringBuffer buffer,\n        NodeList children,\n        boolean elements,\n        boolean attributes,\n        boolean text,\n        boolean pi) \n    {\n        for (int i = 0; i < children.getLength(); i++) {\n            appendXMLSignature(\n                buffer,\n                children.item(i),\n                elements,\n                attributes,\n                text,\n                pi);\n        }\n    }\n    public void testGetNode() {\n        assertXPathNodeType(context, \"/\", Document.class);\n        assertXPathNodeType(context, \"/vendor/location\", Element.class);\n        assertXPathNodeType(context, \"//location/@name\", Attr.class);\n        assertXPathNodeType(context, \"//vendor\", Element.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    public final Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    public final Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testEmptyNodeSetOperations() {\n        assertXPathValue(context, \"/idonotexist = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist != 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"/idonotexist <= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] != 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] >= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array[position() < 1] <= 0\", Boolean.FALSE, Boolean.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n    public NodePointer getNodePointer();\n}\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n    private Attr getAttribute(Element element, QName name);\n    private boolean testAttr(Attr attr, QName testName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n    public NodePointer getNodePointer();\n}\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n    private Attr getAttribute(Element element, QName name);\n    private boolean testAttr(Attr attr, QName testName);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * apply the same XPaths to contexts using different models:\n * DOM, JDOM etc.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class XMLModelTestCase extends JXPathTestCase {\n    public void testNamespaceMapping() {\n        context.registerNamespace(\"rate\", \"priceNS\");\n        context.registerNamespace(\"goods\", \"productNS\");\n\n        assertEquals(\"Context node namespace resolution\",  \"priceNS\",  context.getNamespaceURI(\"price\"));        \n        \n        assertEquals(\"Registered namespace resolution\",  \"priceNS\",  context.getNamespaceURI(\"rate\"));\n\n        // child:: with a namespace and wildcard\n        assertXPathValue(context, \n                \"count(vendor/product/rate:*)\", \n                new Double(2));\n\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/rate:amount[1]/@rate:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/rate:amount[1]/@price:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/price:amount[1]/@rate:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/price:amount[1]/@price:discount\", \"10%\");\n\n        // Preference for externally registered namespace prefix\n        assertXPathValueAndPointer(context,\n                \"//product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n        \n        // Same, but with a child context        \n        JXPathContext childCtx = \n            JXPathContext.newContext(context, context.getContextBean());\n        assertXPathValueAndPointer(childCtx,\n                \"//product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n        \n        // Same, but with a relative context        \n        JXPathContext relativeCtx = \n            context.getRelativeContext(context.getPointer(\"/vendor\"));\n        assertXPathValueAndPointer(relativeCtx,\n                \"product/product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public static boolean testNode(Node node, NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public static boolean testNode(Node node, NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testElementDOM() {\n        doTestElement(DocumentContainer.MODEL_DOM);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public NodePointer createAttribute(JXPathContext context, QName name);\n    public NodeIterator namespaceIterator();\n    public boolean testNode(NodeTest test);\n}\n/**\n * Namespace resolver for JXPathContextReferenceImpl.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NamespaceResolver implements Cloneable {\n    private boolean sealed;\n    /**\n     * Get the prefix associated with the specifed namespace URI.\n     * @param namespaceURI the ns URI to check.\n     * @return String prefix\n     */\n    public synchronized String getPrefix(String namespaceURI);\n    /**\n     * Given a prefix, returns a registered namespace URI. If the requested\n     * prefix was not defined explicitly using the registerNamespace method,\n     * JXPathContext will then check the context node to see if the prefix is\n     * defined there. See\n     * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     */\n    public synchronized String getNamespaceURI(String prefix);\n    /**\n     * Learn whether this NamespaceResolver has been sealed.\n     * @return\n     */\n    public boolean isSealed();\n    /**\n     * Get the namespace context pointer.\n     * @return Pointer\n     */\n    public Pointer getNamespaceContextPointer();\n    /**\n     * Registers a namespace prefix.\n     * \n     * @param prefix A namespace prefix\n     * @param namespaceURI A URI for that prefix\n     */\n    public synchronized void registerNamespace(String prefix, String namespaceURI);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public NodePointer createAttribute(JXPathContext context, QName name);\n    public NodeIterator namespaceIterator();\n    public boolean testNode(NodeTest test);\n}\n/**\n * Namespace resolver for JXPathContextReferenceImpl.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NamespaceResolver implements Cloneable {\n    private boolean sealed;\n    /**\n     * Get the prefix associated with the specifed namespace URI.\n     * @param namespaceURI the ns URI to check.\n     * @return String prefix\n     */\n    public synchronized String getPrefix(String namespaceURI);\n    /**\n     * Given a prefix, returns a registered namespace URI. If the requested\n     * prefix was not defined explicitly using the registerNamespace method,\n     * JXPathContext will then check the context node to see if the prefix is\n     * defined there. See\n     * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\n     * \n     * @param prefix The namespace prefix to look up\n     * @return namespace URI or null if the prefix is undefined.\n     */\n    public synchronized String getNamespaceURI(String prefix);\n    /**\n     * Learn whether this NamespaceResolver has been sealed.\n     * @return\n     */\n    public boolean isSealed();\n    /**\n     * Get the namespace context pointer.\n     * @return Pointer\n     */\n    public Pointer getNamespaceContextPointer();\n    /**\n     * Registers a namespace prefix.\n     * \n     * @param prefix A namespace prefix\n     * @param namespaceURI A URI for that prefix\n     */\n    public synchronized void registerNamespace(String prefix, String namespaceURI);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCreateAndSetAttributeDOM() {\n        doTestCreateAndSetAttribute(DocumentContainer.MODEL_DOM);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An element of the compile tree representing one of built-in functions\n * like \"position()\" or \"number()\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreFunction extends Operation {\n    private static final Double ZERO = new Double(0);\n    private int functionCode;\n    protected Object functionFloor(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An element of the compile tree representing one of built-in functions\n * like \"position()\" or \"number()\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreFunction extends Operation {\n    private static final Double ZERO = new Double(0);\n    private int functionCode;\n    protected Object functionFloor(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testCoreFunctions() {\n        assertXPathValue(context, \"string(2)\", \"2\");\n        assertXPathValue(context, \"string($nan)\", \"NaN\");\n        assertXPathValue(context, \"string(-$nan)\", \"NaN\");\n        assertXPathValue(context, \"string(-2 div 0)\", \"-Infinity\");\n        assertXPathValue(context, \"string(2 div 0)\", \"Infinity\");\n        assertXPathValue(context, \"concat('a', 'b', 'c')\", \"abc\");\n        assertXPathValue(context, \"starts-with('abc', 'ab')\", Boolean.TRUE);\n        assertXPathValue(context, \"starts-with('xabc', 'ab')\", Boolean.FALSE);\n        assertXPathValue(context, \"contains('xabc', 'ab')\", Boolean.TRUE);\n        assertXPathValue(context, \"contains('xabc', 'ba')\", Boolean.FALSE);\n        assertXPathValue(\n            context,\n            \"substring-before('1999/04/01', '/')\",\n            \"1999\");\n        assertXPathValue(\n            context,\n            \"substring-after('1999/04/01', '/')\",\n            \"04/01\");\n        assertXPathValue(context, \"substring('12345', 2, 3)\", \"234\");\n        assertXPathValue(context, \"substring('12345', 2)\", \"2345\");\n        assertXPathValue(context, \"substring('12345', 1.5, 2.6)\", \"234\");\n        assertXPathValue(context, \"substring('12345', 0, 3)\", \"12\");\n        assertXPathValue(context, \"substring('12345', 0 div 0, 3)\", \"\");\n        assertXPathValue(context, \"substring('12345', 1, 0 div 0)\", \"\");\n        assertXPathValue(context, \"substring('12345', -42, 1 div 0)\", \"12345\");\n        assertXPathValue(context, \"substring('12345', -1 div 0, 1 div 0)\", \"\");\n        assertXPathValue(context, \"substring('12345', 6, 6)\", \"\");\n        assertXPathValue(context, \"substring('12345', 7, 8)\", \"\");\n        assertXPathValue(context, \"substring('12345', 7)\", \"\");\n        assertXPathValue(context, \"string-length('12345')\", new Double(5));\n        assertXPathValue(context, \"normalize-space(' abc  def  ')\", \"abc def\");\n        assertXPathValue(context, \"normalize-space('abc def')\", \"abc def\");\n        assertXPathValue(context, \"normalize-space('   ')\", \"\");\n        assertXPathValue(context, \"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\");\n        assertXPathValue(context, \"boolean(1)\", Boolean.TRUE);\n        assertXPathValue(context, \"boolean(0)\", Boolean.FALSE);\n        assertXPathValue(context, \"boolean('x')\", Boolean.TRUE);\n        assertXPathValue(context, \"boolean('')\", Boolean.FALSE);\n        assertXPathValue(context, \"boolean(/list)\", Boolean.TRUE);\n        assertXPathValue(context, \"boolean(/list[position() < 1])\", Boolean.FALSE);\n\n        assertXPathValue(context, \"true()\", Boolean.TRUE);\n        assertXPathValue(context, \"false()\", Boolean.FALSE);\n        assertXPathValue(context, \"not(false())\", Boolean.TRUE);\n        assertXPathValue(context, \"not(true())\", Boolean.FALSE);\n        assertXPathValue(context, \"null()\", null);        \n        assertXPathValue(context, \"number('1')\", new Double(1));\n        assertXPathValue(context, \"number($bool_true)\", new Double(1));\n        assertXPathValue(context, \"number($bool_false)\", new Double(0));\n        assertXPathValue(context, \"floor(1.5)\", new Double(1));\n        assertXPathValue(context, \"floor(-1.5)\", new Double(-2));\n        assertXPathValue(context, \"ceiling(1.5)\", new Double(2));\n        assertXPathValue(context, \"ceiling(-1.5)\", new Double(-1));\n        assertXPathValue(context, \"round(1.5)\", new Double(2));\n        assertXPathValue(context, \"round(-1.5)\", new Double(-1));\n\n        assertXPathValue(context, \"floor('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"floor(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"floor(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n        assertXPathValue(context, \"ceiling('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"ceiling(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"ceiling(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n        assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"round(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"round(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * EvalContext that represents a union between other contexts - result\n * of a union operation like (a | b)\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class UnionContext extends NodeSetContext {\n    private EvalContext contexts[];\n    private boolean prepared;\n    public int getDocumentOrder();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * EvalContext that represents a union between other contexts - result\n * of a union operation like (a | b)\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class UnionContext extends NodeSetContext {\n    private EvalContext contexts[];\n    private boolean prepared;\n    public int getDocumentOrder();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * apply the same XPaths to contexts using different models:\n * DOM, JDOM etc.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class XMLModelTestCase extends JXPathTestCase {\n    public void testUnion() {\n        assertXPathValue(context, \"/vendor[1]/contact[1] | /vendor[1]/contact[4]\", \"John\");\n        assertXPathValue(context, \"/vendor[1]/contact[4] | /vendor[1]/contact[1]\", \"John\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test);\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test);\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * apply the same XPaths to contexts using different models:\n * DOM, JDOM etc.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class XMLModelTestCase extends JXPathTestCase {\n    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n    public NodePointer getNodePointer();\n}\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n    public int getPosition();\n    private boolean testAttr(Attr attr);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private List attributes;\n    private int position = 0;\n    public NodePointer getNodePointer();\n}\n/**\n * An iterator of attributes of a DOM Node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMAttributeIterator implements NodeIterator {\n    private NodePointer parent;\n    private QName name;\n    private List attributes;\n    private int position = 0;\n    public int getPosition();\n    private boolean testAttr(Attr attr);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * apply the same XPaths to contexts using different models:\n * DOM, JDOM etc.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class XMLModelTestCase extends JXPathTestCase {\n    public void testAxisAttribute() {\n        // attribute::\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n        // attribute:: produces the correct pointer\n        assertXPathPointer(\n            context,\n            \"vendor/location/@id\",\n            \"/vendor[1]/location[1]/@id\");\n\n        // iterate over attributes\n        assertXPathValueIterator(\n            context,\n            \"vendor/location/@id\",\n            list(\"100\", \"101\"));\n\n        // Using different prefixes for the same namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@price:discount\",\n            \"10%\");\n        \n        // namespace uri for an attribute\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n            \"priceNS\");\n\n        // local name of an attribute\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n            \"discount\");\n\n        // name for an attribute\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@price:discount)\",\n            \"price:discount\");\n\n        // attribute:: with the default namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@discount\",\n            \"20%\");\n\n        // namespace uri of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n            \"\");\n\n        // local name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // attribute:: with a namespace and wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@price:*\",\n            list(\"10%\"));\n\n        // attribute:: with a wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/location[1]/@*\",\n            set(\"100\", \"\", \"local\"));\n\n        // attribute:: with default namespace and wildcard\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/@*\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n\n        // attribute:: select non-ns'd attributes only\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n            list(\"20%\"));\n\n        // Empty attribute\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n        // Missing attribute\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n        // Missing attribute with namespace\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n        // Using attribute in a predicate\n        assertXPathValue(\n            context,\n            \"vendor/location[@id='101']//street\",\n            \"Tangerine Drive\");\n        \n        assertXPathValueIterator(\n            context,\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n            \"local\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * EvalContext that walks the \"attribute::\" axis.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class AttributeContext extends EvalContext {\n    private NodeTest nodeTest;\n    private boolean setStarted = false;\n    private NodeIterator iterator;\n    private NodePointer currentNodePointer;\n    public NodePointer getCurrentNodePointer();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * EvalContext that walks the \"attribute::\" axis.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class AttributeContext extends EvalContext {\n    private NodeTest nodeTest;\n    private boolean setStarted = false;\n    private NodeIterator iterator;\n    private NodePointer currentNodePointer;\n    public NodePointer getCurrentNodePointer();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle> * apply the same XPaths to contexts using different models:\n * DOM, JDOM etc.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class XMLModelTestCase extends JXPathTestCase {\n    public void testAxisAttribute() {\n        // attribute::\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n        // attribute:: produces the correct pointer\n        assertXPathPointer(\n            context,\n            \"vendor/location/@id\",\n            \"/vendor[1]/location[1]/@id\");\n\n        // iterate over attributes\n        assertXPathValueIterator(\n            context,\n            \"vendor/location/@id\",\n            list(\"100\", \"101\"));\n\n        // Using different prefixes for the same namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@price:discount\",\n            \"10%\");\n        \n        // namespace uri for an attribute\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n            \"priceNS\");\n\n        // local name of an attribute\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n            \"discount\");\n\n        // name for an attribute\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@price:discount)\",\n            \"price:discount\");\n\n        // attribute:: with the default namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@discount\",\n            \"20%\");\n\n        // namespace uri of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n            \"\");\n\n        // local name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // attribute:: with a namespace and wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@price:*\",\n            list(\"10%\"));\n\n        // attribute:: with a wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/location[1]/@*\",\n            set(\"100\", \"\", \"local\"));\n\n        // attribute:: with default namespace and wildcard\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/@*\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n\n        // attribute::node()\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/attribute::node()\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n        \n        // attribute:: select non-ns'd attributes only\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n            list(\"20%\"));\n\n        // Empty attribute\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n        // Missing attribute\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n        // Missing attribute with namespace\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n        // Using attribute in a predicate\n        assertXPathValue(\n            context,\n            \"vendor/location[@id='101']//street\",\n            \"Tangerine Drive\");\n        \n        assertXPathValueIterator(\n            context,\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n            \"local\"));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName();\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName();\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get relative position of this among like-named siblings.\n     * @return 1..n\n     */\n    private int getRelativePositionByQName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testIterateJDOM() {\n        doTestIterate(DocumentContainer.MODEL_JDOM);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Common superclass for several types of nodes in the parse tree. Provides\n * APIs for optimization of evaluation of expressions.  Specifically, an\n * expression only needs to executed once during the evaluation of an xpath\n * if that expression is context-independent.  Expression.isContextDependent()\n * provides that hint.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class Expression {\n    private boolean contextDependencyKnown = false;\n    private boolean contextDependent;\n    /**\n     * Evaluates the expression. If the result is a node set, returns\n     * the first element of the node set.\n     */\n    public abstract Object computeValue(EvalContext context);\n    public abstract Object compute(EvalContext context);\n\n    public Iterator iterate(EvalContext context);\n    /**\n     * Returns true if this expression should be re-evaluated\n     * each time the current position in the context changes.\n     */\n    public boolean isContextDependent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Common superclass for several types of nodes in the parse tree. Provides\n * APIs for optimization of evaluation of expressions.  Specifically, an\n * expression only needs to executed once during the evaluation of an xpath\n * if that expression is context-independent.  Expression.isContextDependent()\n * provides that hint.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class Expression {\n    private boolean contextDependencyKnown = false;\n    private boolean contextDependent;\n    /**\n     * Evaluates the expression. If the result is a node set, returns\n     * the first element of the node set.\n     */\n    public abstract Object computeValue(EvalContext context);\n    public abstract Object compute(EvalContext context);\n\n    public Iterator iterate(EvalContext context);\n    /**\n     * Returns true if this expression should be re-evaluated\n     * each time the current position in the context changes.\n     */\n    public boolean isContextDependent();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNodeSetReturn() {\n        assertXPathValueIterator(\n            context,\n            \"test:nodeSet()/name\",\n            list(\"Name 1\", \"Name 2\"));\n\n        assertXPathValueIterator(\n            context,\n            \"test:nodeSet()\",\n            list(testBean.getBeans()[0], testBean.getBeans()[1]));\n\n        assertXPathPointerIterator(\n            context,\n            \"test:nodeSet()/name\",\n            list(\"/beans[1]/name\", \"/beans[2]/name\"));\n            \n        assertXPathValueAndPointer(\n            context,\n            \"test:nodeSet()/name\",\n            \"Name 1\",\n            \"/beans[1]/name\");        \n\n        assertXPathValueAndPointer(\n            context,\n            \"test:nodeSet()/@name\",\n            \"Name 1\",\n            \"/beans[1]/@name\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    /**\n     * Compare left to right.\n     * @param left left operand\n     * @param right right operand\n     * @return operation success/failure\n     */\n    private boolean compute(Object left, Object right);\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n    private boolean containsMatch(Iterator it, Object value);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    /**\n     * Compare left to right.\n     * @param left left operand\n     * @param right right operand\n     * @return operation success/failure\n     */\n    private boolean compute(Object left, Object right);\n    /**\n     * Learn whether any element returned from an Iterator matches a given value.\n     * @param it Iterator\n     * @param value to look for\n     * @return whether a match was found\n     */\n    private boolean containsMatch(Iterator it, Object value);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testComplexOperationWithVariables() {\n        JXPathContext context = JXPathContext.newContext(null);\n        context.getVariables().declareVariable(\"a\", Integer.valueOf(0));\n        context.getVariables().declareVariable(\"b\", Integer.valueOf(0));\n        context.getVariables().declareVariable(\"c\", Integer.valueOf(1));\n        assertXPathValue(context, \"$a + $b <= $c\", Boolean.TRUE);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A pointer allocated by a PropertyOwnerPointer to represent the value of\n * a property of the parent object.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class PropertyPointer extends NodePointer {\n    public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n    public boolean isLeaf();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A pointer allocated by a PropertyOwnerPointer to represent the value of\n * a property of the parent object.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class PropertyPointer extends NodePointer {\n    public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n    public boolean isLeaf();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testMapValueEquality() {\n        assertXPathValue(context, \"map/b != map/a\", Boolean.TRUE);\n        assertXPathValue(context, \"map/a != map/b\", Boolean.TRUE);\n        assertXPathValue(context, \"map/a != map/c\", Boolean.FALSE);\n        assertXPathValue(context, \"map/a = map/b\", Boolean.FALSE);\n        assertXPathValue(context, \"map/a = map/c\", Boolean.TRUE);\n        assertXPathValue(context, \"not(map/a = map/b)\", Boolean.TRUE);\n        assertXPathValue(context, \"not(map/a = map/c)\", Boolean.FALSE);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n * a DOMNodePointer instance may likewise not be properly Serializable.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    private NamespaceResolver localNamespaceResolver;\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testInnerEmptyNamespaceDOM() {\n        doTest(\"b:foo/test\", DocumentContainer.MODEL_DOM, \"/b:foo[1]/test[1]\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NullPropertyPointer extends PropertyPointer {\n    private String propertyName = \"*\";\n    private boolean byNameAttribute = false;\n    public NodePointer createPath(JXPathContext context);\n    public NodePointer createPath(JXPathContext context, Object value);\n    public QName getName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class NullPropertyPointer extends PropertyPointer {\n    private String propertyName = \"*\";\n    private boolean byNameAttribute = false;\n    public NodePointer createPath(JXPathContext context);\n    public NodePointer createPath(JXPathContext context, Object value);\n    public QName getName();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testBadFactoryImplementation() {\n        try {\n            context.createPath(\"foo/bar\");\n            fail(\"should fail with JXPathException caused by JXPathAbstractFactoryException\");\n        } catch (JXPathException e) {\n            assertTrue(e.getCause() instanceof JXPathAbstractFactoryException);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public static String getNamespaceURI(Node node);\n    protected String getLanguage();\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang);\n    public Object getValue();\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    public Object getValue();\n    protected String getLanguage();\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode();\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class DOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -8751046933894857319L;\n    private Node node;\n    private Map namespaces;\n    private String defaultNamespace;\n    private String id;\n    public static String getNamespaceURI(Node node);\n    protected String getLanguage();\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang);\n    public Object getValue();\n}\n/**\n * A Pointer that points to a DOM node.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class JDOMNodePointer extends NodePointer {\n    private static final long serialVersionUID = -6346532297491082651L;\n    private Object node;\n    private String id;\n    public Object getValue();\n    protected String getLanguage();\n    /**\n     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n     */\n    public Object getImmediateNode();\n    /**\n     * Returns true if the xml:lang attribute for the current node\n     * or its parent has the specified prefix <i>lang</i>.\n     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n     */\n    public boolean isLanguage(String lang);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testPreserveDOM() {\n        doTest(\"preserve\", DocumentContainer.MODEL_DOM, \" foo \");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Common superclass for Pointers of all kinds.  A NodePointer maps to\n * a deterministic XPath that represents the location of a node in an \n * object graph. This XPath uses only simple axes: child, namespace and\n * attribute and only simple, context-independent predicates.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class NodePointer implements Pointer {\n    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n    private boolean attribute = false;\n    private transient Object rootNode;\n    private NamespaceResolver namespaceResolver;\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Common superclass for Pointers of all kinds.  A NodePointer maps to\n * a deterministic XPath that represents the location of a node in an \n * object graph. This XPath uses only simple axes: child, namespace and\n * attribute and only simple, context-independent predicates.\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class NodePointer implements Pointer {\n    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n    private boolean attribute = false;\n    private transient Object rootNode;\n    private NamespaceResolver namespaceResolver;\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testUnionOfVariableAndNode() throws Exception {\n        Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder().parse(\n                        new InputSource(new StringReader(\n                                \"<MAIN><A/><A/></MAIN>\")));\n\n        JXPathContext context = JXPathContext.newContext(doc);\n        context.getVariables().declareVariable(\"var\", \"varValue\");\n        int sz = 0;\n        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {\n            ptrs.next();\n        }\n        assertEquals(3, sz);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testIterateVariable() throws Exception {\n        assertXPathValueIterator(context, \"$d\", list(\"a\", \"b\"));\n        assertXPathValue(context, \"$d = 'a'\", Boolean.TRUE);\n        assertXPathValue(context, \"$d = 'b'\", Boolean.TRUE);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Implementation of Expression for the operation \"&gt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThanOrEqual extends\n        CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"&lt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThan extends CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"&gt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n *\n * @author Matt Benson\n * @version $Revision:$ $Date:$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    protected final int getPrecedence();\n}\n/**\n * Implementation of Expression for the operation \"&lt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThanOrEqual extends\n        CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Implementation of Expression for the operation \"&gt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThanOrEqual extends\n        CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"&lt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThan extends CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"&gt;\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n *\n * @author Matt Benson\n * @version $Revision:$ $Date:$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    protected final int getPrecedence();\n}\n/**\n * Implementation of Expression for the operation \"&lt;=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationLessThanOrEqual extends\n        CoreOperationRelationalExpression {\n    public Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNodeSetOperations() {\n        assertXPathValue(context, \"$array > 0\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array >= 0\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array = 0.25\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array = 0.5\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array = 0.50000\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array = 0.75\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array < 1\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array <= 1\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$array = 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array > 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$array < 0\", Boolean.FALSE, Boolean.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    private boolean compute(Object left, Object right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n    private boolean compute(Object left, Object right);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNan() {\n        assertXPathValue(context, \"$nan > $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = $nan\", Boolean.TRUE, Boolean.class);\n        assertXPathValue(context, \"$nan > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan > 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 1\", Boolean.FALSE, Boolean.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n    protected boolean findMatch(Iterator lit, Iterator rit);\n    protected int getPrecedence();\n}\n/**\n * Implementation of Expression for the operation \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationNotEqual extends CoreOperationCompare {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationEqual extends CoreOperationCompare {\n    public Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Common superclass for the implementations of Expression for the operations\n * \"=\" and \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationCompare extends CoreOperation {\n    protected boolean findMatch(Iterator lit, Iterator rit);\n    protected int getPrecedence();\n}\n/**\n * Implementation of Expression for the operation \"!=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationNotEqual extends CoreOperationCompare {\n    public Object computeValue(EvalContext context);\n}\n/**\n * Implementation of Expression for the operation \"=\".\n *\n * @author Dmitri Plotnikov\n * @version $Revision$ $Date$\n */\npublic class CoreOperationEqual extends CoreOperationCompare {\n    public Object computeValue(EvalContext context);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void testNan() {\n        assertXPathValue(context, \"$nan > $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan <= $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= $nan and $nan <= $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan != $nan\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan > 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan <= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= 0 and $nan <= 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan != 0\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan > 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan < 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan <= 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan >= 1 and $nan <= 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan = 1\", Boolean.FALSE, Boolean.class);\n        assertXPathValue(context, \"$nan != 1\", Boolean.FALSE, Boolean.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Mock private IMethods mock;\n    @Test  // like using several time the captor in the vararg\n    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {\n        //given\n        mock.varargs();\n        Invocation invocation = getLastInvocation();\n\n        //when\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n        //then\n        invocationMatcher.captureArgumentsFrom(invocation);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {\n        NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();\n        assertThat(the_deep_stub).isNotNull();\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class DelegatingMethod implements MockitoMethod {\n    private final Method method;\n    /**\n     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,\n     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.\n     */\n    @Override\n    public boolean equals(Object o);\n    public boolean isAbstract();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class DelegatingMethod implements MockitoMethod {\n    private final Method method;\n    /**\n     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,\n     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.\n     */\n    @Override\n    public boolean equals(Object o);\n    public boolean isAbstract();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void equals_should_return_true_when_equal() throws Exception {\n        DelegatingMethod equal = new DelegatingMethod(someMethod);\n        assertTrue(delegatingMethod.equals(equal));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class GenericMaster {\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class GenericMaster {\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private Field field(String fieldName) throws SecurityException, NoSuchFieldException {\n        return this.getClass().getDeclaredField(fieldName);\n    }\n    public void shouldDealWithNestedGenerics() throws Exception {\n        assertEquals(Set.class, m.getGenericType(field(\"nested\")));\n        assertEquals(Set.class, m.getGenericType(field(\"multiNested\")));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n    private static final long serialVersionUID = -2917871070982574165L;\n    private final MockSettingsImpl mockSettings;\n    public Object handle(Invocation invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n    private static final long serialVersionUID = -2917871070982574165L;\n    private final MockSettingsImpl mockSettings;\n    public Object handle(Invocation invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n        //given\n        when(mock.otherMethod()).thenReturn(\"foo\");\n        \n        //when\n        mockTwo.simpleMethod(\"foo\");\n        \n        //then\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n        try {\n            verify(mockTwo, never()).simpleMethod(mock.otherMethod());\n            fail();\n        } catch (NeverWantedButInvoked e) {}\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class MockitoCore {\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public <T> OngoingStubbing<T> when(T methodCall);\n    public <T> T verify(T mock, VerificationMode mode);\n}\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n    private static final long serialVersionUID = -2917871070982574165L;\n    private final MockSettingsImpl mockSettings;\n    public Object handle(Invocation invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class MockitoCore {\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public <T> OngoingStubbing<T> when(T methodCall);\n    public <T> T verify(T mock, VerificationMode mode);\n}\n/**\n * Invocation handler set on mock objects.\n * \n * @param <T>\n *            type of mock object to handle\n */\npublic class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n    private static final long serialVersionUID = -2917871070982574165L;\n    private final MockSettingsImpl mockSettings;\n    public Object handle(Invocation invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n        //given\n        when(mock.otherMethod()).thenReturn(\"foo\");\n        \n        //when\n        mockTwo.simpleMethod(\"foo\");\n        \n        //then\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldInjectUsingPropertySetterIfAvailable() {\n        assertTrue(awaitingInjection.propertySetterUsed);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class MockitoCore {\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing)  return mock(classToMock, mockSettings); };\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public <T> OngoingStubbing<T> when(T methodCall);\n}\n/**\n * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n * Mockito library enables mocks creation, verification and stubbing.\n * <p>\n * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \n * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\n * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \n * \n * <h1>Contents</h1>\n * \n * <b> \n *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n *      <a href=\"#3\">3. Argument matchers </a><br/>\n *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n *      <a href=\"#6\">6. Verification in order </a><br/> \n *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \n *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\n *      <a href=\"#13\">13. Spying on real objects </a><br/>\n *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n *      <a href=\"#16\">16. Real partial mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#17\">17. Resetting mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>\n *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\n *      <a href=\"#20\">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>\n * </b>\n * \n * <p>\n * Following examples mock a List, because everyone knows its interface (methods\n * like add(), get(), clear() will be used). <br>\n * You probably wouldn't mock List class 'in real'.\n * \n * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n * \n * <pre>\n * //Let's import Mockito statically so that the code looks clearer\n * import static org.mockito.Mockito.*;\n * \n * //mock creation\n * List mockedList = mock(List.class);\n *\n * //using mock object\n * mockedList.add(\"one\");\n * mockedList.clear();\n *\n * //verification\n * verify(mockedList).add(\"one\");\n * verify(mockedList).clear();\n * </pre>\n * \n * <p>\n * Once created, mock will remember all interactions. Then you can selectively\n * verify whatever interaction you are interested in.\n * \n * <h3 id=\"2\">2. How about some stubbing?</h3>\n * \n * <pre>\n * //You can mock concrete classes, not only interfaces\n * LinkedList mockedList = mock(LinkedList.class);\n * \n * //stubbing\n * when(mockedList.get(0)).thenReturn(\"first\");\n * when(mockedList.get(1)).thenThrow(new RuntimeException());\n * \n * //following prints \"first\"\n * System.out.println(mockedList.get(0));\n * \n * //following throws runtime exception\n * System.out.println(mockedList.get(1));\n * \n * //following prints \"null\" because get(999) was not stubbed\n * System.out.println(mockedList.get(999));\n *  \n * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n * verify(mockedList).get(0);\n * </pre>\n * \n * <ul>\n * <li> By default, for all methods that return value, mock returns null, an\n * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n * false, ... for int/Integer, boolean/Boolean, ...). </li>\n * \n * <li> Stubbing can be overridden: for example common stubbing can go to\n * fixture setup but the test methods can override it.\n * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\n * \n * <li> Once stubbed, the method will always return stubbed value regardless\n * of how many times it is called. </li>\n * \n * <li> Last stubbing is more important - when you stubbed the same method with\n * the same arguments many times. </li>\n * \n * </ul>\n * \n * <h3 id=\"3\">3. Argument matchers</h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * Sometimes, when extra flexibility is required then you might use argument matchers:  \n * \n * <pre>\n * //stubbing using built-in anyInt() argument matcher\n * when(mockedList.get(anyInt())).thenReturn(\"element\");\n * \n * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n * \n * //following prints \"element\"\n * System.out.println(mockedList.get(999));\n * \n * //<b>you can also verify using an argument matcher</b>\n * verify(mockedList).get(anyInt());\n * </pre>\n * \n * <p>\n * Argument matchers allow flexible verification or stubbing. \n * {@link Matchers Click here to see} more built-in matchers \n * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n * <p>\n * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n * <p>\n * Be reasonable with using complicated argument matching.\n * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\n * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\n * <p>\n * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n * <p>\n * <b>Warning on argument matchers:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided\n * by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * \n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n * </pre>\n * \n * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n * \n * <pre>\n * //using mock \n * mockedList.add(\"once\");\n * \n * mockedList.add(\"twice\");\n * mockedList.add(\"twice\");\n * \n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * \n * //following two verifications work exactly the same - times(1) is used by default\n * verify(mockedList).add(\"once\");\n * verify(mockedList, times(1)).add(\"once\");\n * \n * //exact number of invocations verification\n * verify(mockedList, times(2)).add(\"twice\");\n * verify(mockedList, times(3)).add(\"three times\");\n * \n * //verification using never(). never() is an alias to times(0)\n * verify(mockedList, never()).add(\"never happened\");\n * \n * //verification using atLeast()/atMost()\n * verify(mockedList, atLeastOnce()).add(\"three times\");\n * verify(mockedList, atLeast(2)).add(\"five times\");\n * verify(mockedList, atMost(5)).add(\"three times\");\n * \n * </pre>\n * \n * <p>\n * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n * omitted.\n * \n * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n * \n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about doThrow|doAnswer family of methods in paragraph 12.\n * <p>\n * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n * \n * <h3 id=\"6\">6. Verification in order</h3>\n * \n * <pre>\n * List firstMock = mock(List.class);\n * List secondMock = mock(List.class);\n * \n * //using mocks\n * firstMock.add(\"was called first\");\n * secondMock.add(\"was called second\");\n * \n * //create inOrder object passing any mocks that need to be verified in order\n * InOrder inOrder = inOrder(firstMock, secondMock);\n * \n * //following will make sure that firstMock was called before secondMock\n * inOrder.verify(firstMock).add(\"was called first\");\n * inOrder.verify(secondMock).add(\"was called second\");\n * </pre>\n * \n * Verification in order is flexible - <b>you don't have to verify all\n * interactions</b> one-by-one but only those that you are interested in\n * testing in order.\n * <p>\n * Also, you can create InOrder object passing only mocks that are relevant for\n * in-order verification.\n * \n * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n * \n * <pre>\n * //using mocks - only mockOne is interacted\n * mockOne.add(\"one\");\n * \n * //ordinary verification\n * verify(mockOne).add(\"one\");\n * \n * //verify that method was never called on a mock\n * verify(mockOne, never()).add(\"two\");\n * \n * //verify that other mocks were not interacted\n * verifyZeroInteractions(mockTwo, mockThree);\n * \n * </pre>\n * \n * <h3 id=\"8\">8. Finding redundant invocations</h3>\n * \n * <pre>\n * //using mocks\n * mockedList.add(\"one\");\n * mockedList.add(\"two\");\n * \n * verify(mockedList).add(\"one\");\n * \n * //following verification will fail \n * verifyNoMoreInteractions(mockedList);\n * </pre>\n * \n * A word of <b>warning</b>: \n * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n * verifyNoMoreInteractions() is not recommended to use in every test method. \n * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n * \n * <p>   \n * See also {@link Mockito#never()} - it is more explicit and\n * communicates the intent well.\n * <p>\n * \n * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n * \n * <ul>\n * <li>Minimizes repetitive mock creation code.</li>\n * <li>Makes the test class more readable.</li>\n * <li>Makes the verification error easier to read because the <b>field name</b>\n * is used to identify the mock.</li>\n * </ul>\n * \n * <pre>\n *   public class ArticleManagerTest { \n *     \n *       &#064;Mock private ArticleCalculator calculator;\n *       &#064;Mock private ArticleDatabase database;\n *       &#064;Mock private UserProvider userProvider;\n *     \n *       private ArticleManager manager;\n * </pre>\n * \n * <b>Important!</b> This needs to be somewhere in the base class or a test\n * runner:\n * \n * <pre>\n * MockitoAnnotations.initMocks(testClass);\n * </pre>\n * \n * You can use built-in runner: {@link MockitoJUnitRunner}.\n * <p>\n * Read more here: {@link MockitoAnnotations}\n * \n * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n * \n * Sometimes we need to stub with different return value/exception for the same\n * method call. Typical use case could be mocking iterators. \n * Original version of Mockito did not have this feature to promote simple mocking. \n * For example, instead of iterators one could use {@link Iterable} or simply\n * collections. Those offer natural ways of stubbing (e.g. using real\n * collections). In rare scenarios stubbing consecutive calls could be useful,\n * though:\n * <p>\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenThrow(new RuntimeException())\n *   .thenReturn(\"foo\");\n * \n * //First call: throws runtime exception:\n * mock.someMethod(\"some arg\");\n * \n * //Second call: prints \"foo\"\n * System.out.println(mock.someMethod(\"some arg\"));\n * \n * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n * System.out.println(mock.someMethod(\"some arg\"));\n * </pre>\n * \n * Alternative, shorter version of consecutive stubbing:\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenReturn(\"one\", \"two\", \"three\");\n * </pre>\n * \n * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n * \n * Allows stubbing with generic {@link Answer} interface.\n*  <p>\n * Yet another controversial feature which was not included in Mockito\n * originally. We recommend using simple stubbing with thenReturn() or\n * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive\n * any clean & simple code.\n * \n * <pre>\n * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n *     Object answer(InvocationOnMock invocation) {\n *         Object[] args = invocation.getArguments();\n *         Object mock = invocation.getMock();\n *         return \"called with arguments: \" + args;\n *     }\n * });\n * \n * //Following prints \"called with arguments: foo\"\n * System.out.println(mock.someMethod(\"foo\"));\n * </pre>\n * \n * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n * \n * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n * <p>\n * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n * The main reason is improved readability and consistency with the family of doAnswer() methods.\n * <p>\n * Use doThrow() when you want to stub a void method with an exception:\n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about other methods:\n * <p>\n * {@link Mockito#doThrow(Throwable)}\n * <p>\n * {@link Mockito#doAnswer(Answer)}\n * <p>\n * {@link Mockito#doNothing()}\n * <p>\n * {@link Mockito#doReturn(Object)}\n * \n * <h3 id=\"13\"> 13. Spying on real objects</h3>\n * \n * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * \n * <p>\n * Spying on real objects can be associated with \"partial mocking\" concept. \n * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n * The reason was we thought partial mock is a code smell. \n * At some point we found legitimate use cases for partial mocks \n * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n * >here</a>)\n * <p>\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n * \n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n * \n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n * \n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n * \n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n * \n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n * \n * <h4>Important gotcha on spying real objects!</h4>\n * \n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n * \n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *   \n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *   \n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n * \n * 2. Watch out for final methods. \n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n * \n * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n * \n * You can create a mock with specified strategy for its return values.\n * It's quite advanced feature and typically you don't need it to write decent tests.\n * However, it can be helpful for working with <b>legacy systems</b>.\n * <p>\n * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n * \n * <pre>\n *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n * </pre>\n * \n * <p>\n * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n * \n * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * This is also the recommended way of matching arguments because it makes tests clean & simple.\n * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n * For example:\n * <pre>\n *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n *   verify(mock).doSomething(argument.capture());\n *   assertEquals(\"John\", argument.getValue().getName());\n * </pre>\n * \n * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n * <p>\n * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n * Both techniques can be used for making sure certain arguments where passed to mocks. \n * However, ArgumentCaptor may be a better fit if:\n * <ul>  \n * <li>custom argument matcher is not likely to be reused</li>\n * <li>you just need it to assert on argument values to complete verification</li>\n * </ul>\n * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n * \n * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n *  \n *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n *  <p>\n *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\n *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n *  <p>\n *  <pre>\n *    //you can create partial mock with spy() method:    \n *    List list = spy(new LinkedList());\n *    \n *    //you can enable partial mock capabilities selectively on mocks:\n *    Foo mock = mock(Foo.class);\n *    //Be sure the real implementation is 'safe'.\n *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n *    when(mock.someMethod()).thenCallRealMethod();\n *  </pre>\n *  \n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n *  \n * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n *  \n * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n * <p>\n * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n * There are several threads about it on mockito mailing list.\n * <p>\n * The only reason we added reset() method is to\n * make it possible to work with container-injected mocks.\n * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n * <p>\n * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). \n * <pre>\n *   List mock = mock(List.class);\n *   when(mock.size()).thenReturn(10);\n *   mock.add(1);\n *   \n *   reset(mock);\n *   //at this point the mock forgot any interactions & stubbing\n * </pre>\n *  \n * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n * \n * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n * <p>\n * In case of questions you may also post to mockito mailing list: \n * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n * <p>\n * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n * \n * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n * \n * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n * This is exactly how we write our tests and we warmly encourage you to do so!\n * <p>\n * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\n * <p>\n * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\n * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \n * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \n * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n * <p>\n * Here is how the test might look like: \n * <pre>\n * import static org.mockito.BDDMockito.*;\n * \n * Seller seller = mock(Seller.class);\n * Shop shop = new Shop(seller);\n * \n * public void shouldBuyBread() throws Exception {\n *   //given  \n *   given(seller.askForBread()).willReturn(new Bread());\n *   \n *   //when\n *   Goods goods = shop.buyBread();\n *   \n *   //then\n *   assertThat(goods, containBread());\n * }  \n * </pre>\n * \n * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n * \n * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n * <p>\n * WARNING: This should be rarely used in unit testing. \n * <p>\n * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n * <p>\n * To create serializable mock use {@link MockSettings#serializable()}:\n * <pre>\n *   List serializableMock = mock(List.class, withSettings().serializable());\n * </pre>\n * <p>\n * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n * serialization requirements</a> are met by the class.\n * <p>\n * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n * which accepts MockSettings. No worries, you will hardly ever use it.\n * \n * <pre>\n * List<Object> list = new ArrayList<Object>();\n * List<Object> spy = mock(ArrayList.class, withSettings()\n *                 .spiedInstance(list)\n *                 .defaultAnswer(CALLS_REAL_METHODS)\n *                 .serializable());\n * </pre>\n */\npublic class Mockito extends Matchers {\n    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n    public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\n    public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\n    public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\n    public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\n    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public static <T> T mock(Class<T> classToMock, String name);\n    @Deprecated\n    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues);\n    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer);\n    /**\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n     * <p>\n     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n     * <p>\n     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n     * <p>\n     * Examples:\n     * \n     * <pre>\n     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n     *\n     * //setting exception to be thrown:\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n     *\n     * //you can set different behavior for consecutive method calls.\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException())\n     *  .thenReturn(\"foo\");\n     *  \n     * //Alternative, shorter version for consecutive stubbing:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\", \"two\");\n     * //is the same as:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\")\n     *  .thenReturn(\"two\");\n     *\n     * //shorter version for consecutive method calls throwing exceptions:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\n     *   \n     * </pre>\n     * \n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * @param methodCall method to be stubbed\n     */\n    public static <T> OngoingStubbing<T> when(T methodCall);\n    public static <T> T mock(Class<T> classToMock);\n    /**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     * \n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     * \n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     * \n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     * \n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     * \n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     * \n     * <h4>Important gotcha on spying real objects!</h4>\n     * \n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Watch out for final methods. \n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */\n    public static <T> T spy(T object);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class MockitoCore {\n    private final Reporter reporter = new Reporter();\n    private final MockUtil mockUtil = new MockUtil();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing)  return mock(classToMock, mockSettings); };\n    public <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public <T> OngoingStubbing<T> when(T methodCall);\n}\n/**\n * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n * Mockito library enables mocks creation, verification and stubbing.\n * <p>\n * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \n * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\n * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \n * \n * <h1>Contents</h1>\n * \n * <b> \n *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n *      <a href=\"#3\">3. Argument matchers </a><br/>\n *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n *      <a href=\"#6\">6. Verification in order </a><br/> \n *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \n *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\n *      <a href=\"#13\">13. Spying on real objects </a><br/>\n *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n *      <a href=\"#16\">16. Real partial mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#17\">17. Resetting mocks (Since 1.8.0) </a><br/>\n *      <a href=\"#18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>\n *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\n *      <a href=\"#20\">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>\n * </b>\n * \n * <p>\n * Following examples mock a List, because everyone knows its interface (methods\n * like add(), get(), clear() will be used). <br>\n * You probably wouldn't mock List class 'in real'.\n * \n * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n * \n * <pre>\n * //Let's import Mockito statically so that the code looks clearer\n * import static org.mockito.Mockito.*;\n * \n * //mock creation\n * List mockedList = mock(List.class);\n *\n * //using mock object\n * mockedList.add(\"one\");\n * mockedList.clear();\n *\n * //verification\n * verify(mockedList).add(\"one\");\n * verify(mockedList).clear();\n * </pre>\n * \n * <p>\n * Once created, mock will remember all interactions. Then you can selectively\n * verify whatever interaction you are interested in.\n * \n * <h3 id=\"2\">2. How about some stubbing?</h3>\n * \n * <pre>\n * //You can mock concrete classes, not only interfaces\n * LinkedList mockedList = mock(LinkedList.class);\n * \n * //stubbing\n * when(mockedList.get(0)).thenReturn(\"first\");\n * when(mockedList.get(1)).thenThrow(new RuntimeException());\n * \n * //following prints \"first\"\n * System.out.println(mockedList.get(0));\n * \n * //following throws runtime exception\n * System.out.println(mockedList.get(1));\n * \n * //following prints \"null\" because get(999) was not stubbed\n * System.out.println(mockedList.get(999));\n *  \n * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n * verify(mockedList).get(0);\n * </pre>\n * \n * <ul>\n * <li> By default, for all methods that return value, mock returns null, an\n * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n * false, ... for int/Integer, boolean/Boolean, ...). </li>\n * \n * <li> Stubbing can be overridden: for example common stubbing can go to\n * fixture setup but the test methods can override it.\n * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\n * \n * <li> Once stubbed, the method will always return stubbed value regardless\n * of how many times it is called. </li>\n * \n * <li> Last stubbing is more important - when you stubbed the same method with\n * the same arguments many times. </li>\n * \n * </ul>\n * \n * <h3 id=\"3\">3. Argument matchers</h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * Sometimes, when extra flexibility is required then you might use argument matchers:  \n * \n * <pre>\n * //stubbing using built-in anyInt() argument matcher\n * when(mockedList.get(anyInt())).thenReturn(\"element\");\n * \n * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n * \n * //following prints \"element\"\n * System.out.println(mockedList.get(999));\n * \n * //<b>you can also verify using an argument matcher</b>\n * verify(mockedList).get(anyInt());\n * </pre>\n * \n * <p>\n * Argument matchers allow flexible verification or stubbing. \n * {@link Matchers Click here to see} more built-in matchers \n * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n * <p>\n * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n * <p>\n * Be reasonable with using complicated argument matching.\n * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\n * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\n * <p>\n * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n * <p>\n * <b>Warning on argument matchers:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided\n * by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * \n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n * </pre>\n * \n * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n * \n * <pre>\n * //using mock \n * mockedList.add(\"once\");\n * \n * mockedList.add(\"twice\");\n * mockedList.add(\"twice\");\n * \n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * mockedList.add(\"three times\");\n * \n * //following two verifications work exactly the same - times(1) is used by default\n * verify(mockedList).add(\"once\");\n * verify(mockedList, times(1)).add(\"once\");\n * \n * //exact number of invocations verification\n * verify(mockedList, times(2)).add(\"twice\");\n * verify(mockedList, times(3)).add(\"three times\");\n * \n * //verification using never(). never() is an alias to times(0)\n * verify(mockedList, never()).add(\"never happened\");\n * \n * //verification using atLeast()/atMost()\n * verify(mockedList, atLeastOnce()).add(\"three times\");\n * verify(mockedList, atLeast(2)).add(\"five times\");\n * verify(mockedList, atMost(5)).add(\"three times\");\n * \n * </pre>\n * \n * <p>\n * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n * omitted.\n * \n * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n * \n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about doThrow|doAnswer family of methods in paragraph 12.\n * <p>\n * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n * \n * <h3 id=\"6\">6. Verification in order</h3>\n * \n * <pre>\n * List firstMock = mock(List.class);\n * List secondMock = mock(List.class);\n * \n * //using mocks\n * firstMock.add(\"was called first\");\n * secondMock.add(\"was called second\");\n * \n * //create inOrder object passing any mocks that need to be verified in order\n * InOrder inOrder = inOrder(firstMock, secondMock);\n * \n * //following will make sure that firstMock was called before secondMock\n * inOrder.verify(firstMock).add(\"was called first\");\n * inOrder.verify(secondMock).add(\"was called second\");\n * </pre>\n * \n * Verification in order is flexible - <b>you don't have to verify all\n * interactions</b> one-by-one but only those that you are interested in\n * testing in order.\n * <p>\n * Also, you can create InOrder object passing only mocks that are relevant for\n * in-order verification.\n * \n * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n * \n * <pre>\n * //using mocks - only mockOne is interacted\n * mockOne.add(\"one\");\n * \n * //ordinary verification\n * verify(mockOne).add(\"one\");\n * \n * //verify that method was never called on a mock\n * verify(mockOne, never()).add(\"two\");\n * \n * //verify that other mocks were not interacted\n * verifyZeroInteractions(mockTwo, mockThree);\n * \n * </pre>\n * \n * <h3 id=\"8\">8. Finding redundant invocations</h3>\n * \n * <pre>\n * //using mocks\n * mockedList.add(\"one\");\n * mockedList.add(\"two\");\n * \n * verify(mockedList).add(\"one\");\n * \n * //following verification will fail \n * verifyNoMoreInteractions(mockedList);\n * </pre>\n * \n * A word of <b>warning</b>: \n * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n * verifyNoMoreInteractions() is not recommended to use in every test method. \n * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n * \n * <p>   \n * See also {@link Mockito#never()} - it is more explicit and\n * communicates the intent well.\n * <p>\n * \n * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n * \n * <ul>\n * <li>Minimizes repetitive mock creation code.</li>\n * <li>Makes the test class more readable.</li>\n * <li>Makes the verification error easier to read because the <b>field name</b>\n * is used to identify the mock.</li>\n * </ul>\n * \n * <pre>\n *   public class ArticleManagerTest { \n *     \n *       &#064;Mock private ArticleCalculator calculator;\n *       &#064;Mock private ArticleDatabase database;\n *       &#064;Mock private UserProvider userProvider;\n *     \n *       private ArticleManager manager;\n * </pre>\n * \n * <b>Important!</b> This needs to be somewhere in the base class or a test\n * runner:\n * \n * <pre>\n * MockitoAnnotations.initMocks(testClass);\n * </pre>\n * \n * You can use built-in runner: {@link MockitoJUnitRunner}.\n * <p>\n * Read more here: {@link MockitoAnnotations}\n * \n * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n * \n * Sometimes we need to stub with different return value/exception for the same\n * method call. Typical use case could be mocking iterators. \n * Original version of Mockito did not have this feature to promote simple mocking. \n * For example, instead of iterators one could use {@link Iterable} or simply\n * collections. Those offer natural ways of stubbing (e.g. using real\n * collections). In rare scenarios stubbing consecutive calls could be useful,\n * though:\n * <p>\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenThrow(new RuntimeException())\n *   .thenReturn(\"foo\");\n * \n * //First call: throws runtime exception:\n * mock.someMethod(\"some arg\");\n * \n * //Second call: prints \"foo\"\n * System.out.println(mock.someMethod(\"some arg\"));\n * \n * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n * System.out.println(mock.someMethod(\"some arg\"));\n * </pre>\n * \n * Alternative, shorter version of consecutive stubbing:\n * \n * <pre>\n * when(mock.someMethod(\"some arg\"))\n *   .thenReturn(\"one\", \"two\", \"three\");\n * </pre>\n * \n * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n * \n * Allows stubbing with generic {@link Answer} interface.\n*  <p>\n * Yet another controversial feature which was not included in Mockito\n * originally. We recommend using simple stubbing with thenReturn() or\n * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive\n * any clean & simple code.\n * \n * <pre>\n * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n *     Object answer(InvocationOnMock invocation) {\n *         Object[] args = invocation.getArguments();\n *         Object mock = invocation.getMock();\n *         return \"called with arguments: \" + args;\n *     }\n * });\n * \n * //Following prints \"called with arguments: foo\"\n * System.out.println(mock.someMethod(\"foo\"));\n * </pre>\n * \n * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n * \n * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n * <p>\n * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n * The main reason is improved readability and consistency with the family of doAnswer() methods.\n * <p>\n * Use doThrow() when you want to stub a void method with an exception:\n * <pre>\n *   doThrow(new RuntimeException()).when(mockedList).clear();\n *   \n *   //following throws RuntimeException:\n *   mockedList.clear();\n * </pre>\n * \n * Read more about other methods:\n * <p>\n * {@link Mockito#doThrow(Throwable)}\n * <p>\n * {@link Mockito#doAnswer(Answer)}\n * <p>\n * {@link Mockito#doNothing()}\n * <p>\n * {@link Mockito#doReturn(Object)}\n * \n * <h3 id=\"13\"> 13. Spying on real objects</h3>\n * \n * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n * <p>\n * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n * \n * <p>\n * Spying on real objects can be associated with \"partial mocking\" concept. \n * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n * The reason was we thought partial mock is a code smell. \n * At some point we found legitimate use cases for partial mocks \n * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n * >here</a>)\n * <p>\n *\n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n * \n *   //optionally, you can stub out some methods:\n *   when(spy.size()).thenReturn(100);\n * \n *   //using the spy calls <b>real</b> methods\n *   spy.add(\"one\");\n *   spy.add(\"two\");\n * \n *   //prints \"one\" - the first element of a list\n *   System.out.println(spy.get(0));\n * \n *   //size() method was stubbed - 100 is printed\n *   System.out.println(spy.size());\n * \n *   //optionally, you can verify\n *   verify(spy).add(\"one\");\n *   verify(spy).add(\"two\");\n * </pre>\n * \n * <h4>Important gotcha on spying real objects!</h4>\n * \n * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n * \n * <pre>\n *   List list = new LinkedList();\n *   List spy = spy(list);\n *   \n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n *   when(spy.get(0)).thenReturn(\"foo\");\n *   \n *   //You have to use doReturn() for stubbing\n *   doReturn(\"foo\").when(spy).get(0);\n * </pre>\n * \n * 2. Watch out for final methods. \n * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n * \n * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n * \n * You can create a mock with specified strategy for its return values.\n * It's quite advanced feature and typically you don't need it to write decent tests.\n * However, it can be helpful for working with <b>legacy systems</b>.\n * <p>\n * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n * \n * <pre>\n *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n * </pre>\n * \n * <p>\n * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n * \n * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n * \n * Mockito verifies argument values in natural java style: by using an equals() method.\n * This is also the recommended way of matching arguments because it makes tests clean & simple.\n * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n * For example:\n * <pre>\n *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n *   verify(mock).doSomething(argument.capture());\n *   assertEquals(\"John\", argument.getValue().getName());\n * </pre>\n * \n * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n * <p>\n * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n * Both techniques can be used for making sure certain arguments where passed to mocks. \n * However, ArgumentCaptor may be a better fit if:\n * <ul>  \n * <li>custom argument matcher is not likely to be reused</li>\n * <li>you just need it to assert on argument values to complete verification</li>\n * </ul>\n * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n * \n * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n *  \n *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n *  <p>\n *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\n *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n *  <p>\n *  <pre>\n *    //you can create partial mock with spy() method:    \n *    List list = spy(new LinkedList());\n *    \n *    //you can enable partial mock capabilities selectively on mocks:\n *    Foo mock = mock(Foo.class);\n *    //Be sure the real implementation is 'safe'.\n *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n *    when(mock.someMethod()).thenCallRealMethod();\n *  </pre>\n *  \n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n *  \n * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n *  \n * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n * <p>\n * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\n * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n * There are several threads about it on mockito mailing list.\n * <p>\n * The only reason we added reset() method is to\n * make it possible to work with container-injected mocks.\n * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n * <p>\n * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). \n * <pre>\n *   List mock = mock(List.class);\n *   when(mock.size()).thenReturn(10);\n *   mock.add(1);\n *   \n *   reset(mock);\n *   //at this point the mock forgot any interactions & stubbing\n * </pre>\n *  \n * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n * \n * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n * <p>\n * In case of questions you may also post to mockito mailing list: \n * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n * <p>\n * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n * \n * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n * \n * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n * This is exactly how we write our tests and we warmly encourage you to do so!\n * <p>\n * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\n * <p>\n * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\n * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \n * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \n * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n * <p>\n * Here is how the test might look like: \n * <pre>\n * import static org.mockito.BDDMockito.*;\n * \n * Seller seller = mock(Seller.class);\n * Shop shop = new Shop(seller);\n * \n * public void shouldBuyBread() throws Exception {\n *   //given  \n *   given(seller.askForBread()).willReturn(new Bread());\n *   \n *   //when\n *   Goods goods = shop.buyBread();\n *   \n *   //then\n *   assertThat(goods, containBread());\n * }  \n * </pre>\n * \n * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n * \n * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n * <p>\n * WARNING: This should be rarely used in unit testing. \n * <p>\n * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n * <p>\n * To create serializable mock use {@link MockSettings#serializable()}:\n * <pre>\n *   List serializableMock = mock(List.class, withSettings().serializable());\n * </pre>\n * <p>\n * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n * serialization requirements</a> are met by the class.\n * <p>\n * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n * which accepts MockSettings. No worries, you will hardly ever use it.\n * \n * <pre>\n * List<Object> list = new ArrayList<Object>();\n * List<Object> spy = mock(ArrayList.class, withSettings()\n *                 .spiedInstance(list)\n *                 .defaultAnswer(CALLS_REAL_METHODS)\n *                 .serializable());\n * </pre>\n */\npublic class Mockito extends Matchers {\n    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n    public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\n    public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\n    public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\n    public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\n    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings);\n    public static <T> T mock(Class<T> classToMock, String name);\n    @Deprecated\n    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues);\n    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer);\n    /**\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n     * <p>\n     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n     * <p>\n     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n     * <p>\n     * Examples:\n     * \n     * <pre>\n     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n     *\n     * //setting exception to be thrown:\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n     *\n     * //you can set different behavior for consecutive method calls.\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException())\n     *  .thenReturn(\"foo\");\n     *  \n     * //Alternative, shorter version for consecutive stubbing:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\", \"two\");\n     * //is the same as:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\")\n     *  .thenReturn(\"two\");\n     *\n     * //shorter version for consecutive method calls throwing exceptions:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\n     *   \n     * </pre>\n     * \n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar(). \n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed. \n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * @param methodCall method to be stubbed\n     */\n    public static <T> OngoingStubbing<T> when(T methodCall);\n    public static <T> T mock(Class<T> classToMock);\n    /**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     * \n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     * \n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     * \n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     * \n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     * \n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     * \n     * <h4>Important gotcha on spying real objects!</h4>\n     * \n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     * \n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *   \n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *   \n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     * \n     * 2. Watch out for final methods. \n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     * \n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */\n    public static <T> T spy(T object);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\n        IMethods mock = mock(IMethods.class, RETURNS_MOCKS);\n        when(mock.objectReturningMethodNoArgs()).thenReturn(null);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class MockUtil {\n    private final CreationValidator creationValidator;\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings);\n}\npublic class MockSettingsImpl implements MockSettings {\n    private static final long serialVersionUID = 4475297236197939568L;\n    private Class<?>[] extraInterfaces;\n    private String name;\n    private Object spiedInstance;\n    private Answer<Object> defaultAnswer;\n    private MockName mockName;\n    public Answer<Object> getDefaultAnswer();\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces);\n    public boolean isSerializable();\n    public MockSettings serializable();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class MockUtil {\n    private final CreationValidator creationValidator;\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings);\n}\npublic class MockSettingsImpl implements MockSettings {\n    private static final long serialVersionUID = 4475297236197939568L;\n    private Class<?>[] extraInterfaces;\n    private String name;\n    private Object spiedInstance;\n    private Answer<Object> defaultAnswer;\n    private MockName mockName;\n    public Answer<Object> getDefaultAnswer();\n    public MockSettings extraInterfaces(Class<?>... extraInterfaces);\n    public boolean isSerializable();\n    public MockSettings serializable();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n        //when\n        IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n        IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n\n        //then\n        serializeAndBack((List) mock);\n        serializeAndBack((List) mockTwo);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 1998191268711234347L;\n    Object returnValueFor(Class<?> type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 1998191268711234347L;\n    Object returnValueFor(Class<?> type);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void should_return_empty_iterable() throws Exception {\n        assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public interface MockCandidateFilter {\n    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            Object fieldInstance\n    );;\n}\npublic class TypeBasedCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance);\n}\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance);\n}\n/**\n * Inject mocks using first setters then fields, if no setters available.\n *\n * <p>\n * <u>Algorithm :<br></u>\n * for each field annotated by @InjectMocks\n *   <ul>\n *   <li>initialize field annotated by @InjectMocks\n *   <li>for each fields of a class in @InjectMocks type hierarchy\n *     <ul>\n *     <li>make a copy of mock candidates\n *     <li>order fields from sub-type to super-type, then by field name\n *     <li>for the list of fields in a class try two passes of :\n *         <ul>\n *             <li>find mock candidate by type\n *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n *             <li>if one mock candidate then\n *                 <ul>\n *                     <li>set mock by property setter if possible\n *                     <li>else set mock by field injection\n *                 </ul>\n *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n *             <li>remove injected field from list of class fields\n *         </ul>\n *     <li>else don't fail, user will then provide dependencies\n *     </ul>\n *   </ul>\n * </p>\n *\n * <p>\n * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n * to create one using a no-arg constructor of the field type.\n * </p>\n */\npublic class PropertyAndSetterInjection extends MockInjectionStrategy {\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields);\n}\npublic class NameBasedCandidateFilter implements MockCandidateFilter {\n\tprivate final MockCandidateFilter next;\n\tprivate final MockUtil mockUtil = new MockUtil();\n\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public interface MockCandidateFilter {\n    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            Object fieldInstance\n    );;\n}\npublic class TypeBasedCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance);\n}\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance);\n}\n/**\n * Inject mocks using first setters then fields, if no setters available.\n *\n * <p>\n * <u>Algorithm :<br></u>\n * for each field annotated by @InjectMocks\n *   <ul>\n *   <li>initialize field annotated by @InjectMocks\n *   <li>for each fields of a class in @InjectMocks type hierarchy\n *     <ul>\n *     <li>make a copy of mock candidates\n *     <li>order fields from sub-type to super-type, then by field name\n *     <li>for the list of fields in a class try two passes of :\n *         <ul>\n *             <li>find mock candidate by type\n *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n *             <li>if one mock candidate then\n *                 <ul>\n *                     <li>set mock by property setter if possible\n *                     <li>else set mock by field injection\n *                 </ul>\n *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n *             <li>remove injected field from list of class fields\n *         </ul>\n *     <li>else don't fail, user will then provide dependencies\n *     </ul>\n *   </ul>\n * </p>\n *\n * <p>\n * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n * to create one using a no-arg constructor of the field type.\n * </p>\n */\npublic class PropertyAndSetterInjection extends MockInjectionStrategy {\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields);\n}\npublic class NameBasedCandidateFilter implements MockCandidateFilter {\n\tprivate final MockCandidateFilter next;\n\tprivate final MockUtil mockUtil = new MockUtil();\n\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>\tpublic void shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable() {\n\t\tMockitoAnnotations.initMocks(this);\n\t\tassertNull(otherSuperUnderTesting.candidate1);\n\t\tassertNotNull(otherSuperUnderTesting.candidate2);\n\t}\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class Timer {\n    private final long durationMillis;\n    private long startTime = -1;\n    /**\n     * Informs whether the timer is still counting down.\n     */\n    public boolean isCounting();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class Timer {\n    private final long durationMillis;\n    private long startTime = -1;\n    /**\n     * Informs whether the timer is still counting down.\n     */\n    public boolean isCounting();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void oneMillisecondPasses() throws InterruptedException {\n        Thread.sleep(1);\n    }\n    public void should_throw_friendly_reminder_exception_when_duration_is_negative() {\n        try {\n            new Timer(-1);\n            Assert.fail(\"It is forbidden to create timer with negative value of timer's duration.\");\n        } catch (FriendlyReminderException e) {\n            Assert.assertTrue(true);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class ByteBuddyMockMaker implements MockMaker {\n    private final ClassInstantiator classInstantiator;\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;\n    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class ByteBuddyMockMaker implements MockMaker {\n    private final ClassInstantiator classInstantiator;\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;\n    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Rule public final ExpectedException shouldThrow = ExpectedException.none();\n    @Test\n    public void should_spy_inner_class() throws Exception {\n    \t \n     class WithMockAndSpy {\n    \t\t@Spy private InnerStrength strength;\n    \t\t@Mock private List<String> list;\n\n            abstract class InnerStrength {\n            \tprivate final String name;\n\n            \tInnerStrength() {\n            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\n            \t\tassertNotNull(list);\n            \t\t// Make sure constructor is indeed called.\n            \t\tthis.name = \"inner\";\n            \t}\n            \t\n            \tabstract String strength();\n            \t\n            \tString fullStrength() {\n            \t\treturn name + \" \" + strength();\n            \t}\n            }\n    \t}\n\t\tWithMockAndSpy outer = new WithMockAndSpy();\n        MockitoAnnotations.initMocks(outer);\n        when(outer.strength.strength()).thenReturn(\"strength\");\n        assertEquals(\"inner strength\", outer.strength.fullStrength());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class ConstructorInstantiator implements Instantiator {\n    private final Object outerClassInstance;\n    public <T> T newInstance(Class<T> cls);\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class ConstructorInstantiator implements Instantiator {\n    private final Object outerClassInstance;\n    public <T> T newInstance(Class<T> cls);\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Test public void creates_instances_of_inner_classes() {\n        assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>//stolen from hamcrest because I didn't want to have more dependency than Matcher class \npublic class Equality {\n    public static boolean areEqual(Object o1, Object o2);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>//stolen from hamcrest because I didn't want to have more dependency than Matcher class \npublic class Equality {\n    public static boolean areEqual(Object o1, Object o2);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldKnowIfObjectsAreEqual() throws Exception {\n        int[] arr = new int[] {1, 2};\n        assertTrue(areEqual(arr, arr));\n        assertTrue(areEqual(new int[] {1, 2}, new int[] {1, 2}));\n        assertTrue(areEqual(new Double[] {1.0}, new Double[] {1.0}));\n        assertTrue(areEqual(new String[0], new String[0]));\n        assertTrue(areEqual(new Object[10], new Object[10]));\n        assertTrue(areEqual(new int[] {1}, new Integer[] {1}));\n        assertTrue(areEqual(new Object[] {\"1\"}, new String[] {\"1\"}));\n\tObject badequals=new BadEquals();\n\tassertTrue(areEqual(badequals,badequals));\n\n        assertFalse(areEqual(new Object[9], new Object[10]));\n        assertFalse(areEqual(new int[] {1, 2}, new int[] {1}));\n        assertFalse(areEqual(new int[] {1}, new double[] {1.0}));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private MockitoCore mockitoCore = new MockitoCore();\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata);\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata);\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private MockitoCore mockitoCore = new MockitoCore();\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata);\n    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata);\n    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {\n        // given\n        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());\n        when(sampleClass.getSample().isSth()).thenReturn(STUBBED_BOOLEAN_VALUE);\n        when(sampleClass.getSample().getNumber()).thenReturn(STUBBED_INTEGER_VALUE);\n\n        // when\n        Object o = SimpleSerializationUtil.serializeAndBack(sampleClass);\n\n        // then\n        assertThat(o).isInstanceOf(SampleClass.class);\n        SampleClass deserializedSample = (SampleClass) o;\n        assertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_BOOLEAN_VALUE);\n        assertThat(deserializedSample.getSample().getNumber()).isEqualTo(STUBBED_INTEGER_VALUE);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 1998191268711234347L;\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n *  Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n *  Returns description of mock for toString() method\n * </li>\n * <li>\n *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n *  Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 1998191268711234347L;\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Test public void should_return_zero_if_mock_is_compared_to_itself() {\n        //given\n        Date d = mock(Date.class);\n        d.compareTo(d);\n        Invocation compareTo = this.getLastInvocation();\n\n        //when\n        Object result = values.answer(compareTo);\n\n        //then\n        assertEquals(0, result);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n    private Object getMock(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Returning deep stub implementation.\n *\n * Will return previously created mock if the invocation matches.\n *\n * <p>Supports nested generic information, with this answer you can write code like this :\n *\n * <pre class=\"code\"><code class=\"java\">\n *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n *\n *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n * </code></pre>\n * </p>\n *\n * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n */\npublic class ReturnsDeepStubs implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = -7105341425736035847L;\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n    private Object getMock(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {\n        GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n        ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);\n\n        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n        assertThat(listOfInteger.get(25)).isEqualTo(0);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class Primitives {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class Primitives {\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Test public void should_default_values_for_primitive() {\n        assertThat(h.returnFor(boolean.class)).isFalse();\n        assertThat(h.returnFor(char.class)).isEqualTo('\\u0000');\n        assertThat(h.returnFor(byte.class)).isEqualTo((byte) 0);\n        assertThat(h.returnFor(short.class)).isEqualTo((short) 0);\n        assertThat(h.returnFor(int.class)).isEqualTo(0);\n        assertThat(h.returnFor(long.class)).isEqualTo(0L);\n        assertThat(h.returnFor(float.class)).isEqualTo(0.0F);\n        assertThat(h.returnFor(double.class)).isEqualTo(0.0D);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class MockUtil {\n    private final MockCreationValidator creationValidator;\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class MockUtil {\n    private final MockCreationValidator creationValidator;\n    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void listener() throws Exception {\n        InvocationListener invocationListener = mock(InvocationListener.class);\n\n        List mockedList = mock(List.class, withSettings().invocationListeners(invocationListener));\n        reset(mockedList);\n\n        mockedList.clear();\n\n        verify(invocationListener).reportInvocation(any(MethodInvocationReport.class));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n * <p/>\n * See {@link org.mockito.MockitoAnnotations}\n */\npublic class DefaultInjectionEngine {\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n * <p/>\n * See {@link org.mockito.MockitoAnnotations}\n */\npublic class DefaultInjectionEngine {\n    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Mock private Bean mockedBean;\n    @InjectMocks private Service illegalInjectionExample = new Service();\n    @Test\n    public void mock_should_be_injected_once_and_in_the_best_matching_type() {\n        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);\n        assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class Same extends ArgumentMatcher<Object> implements Serializable {\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n    public void describeTo(Description description);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class Same extends ArgumentMatcher<Object> implements Serializable {\n    private static final long serialVersionUID = -1226959355938572597L;\n    private final Object wanted;\n    public void describeTo(Description description);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldNotThrowNPEWhenNullPassedToSame() {\n        mock.objectArgMethod(\"not null\");\n\n        verify(mock).objectArgMethod(same(null));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Mock private IMethods mock;\n    @Test\n    public void should_capture_varargs_as_vararg() throws Exception {\n        //given\n        mock.mixedVarargs(1, \"a\", \"b\");\n        Invocation invocation = getLastInvocation();\n        CapturingMatcher m = new CapturingMatcher();\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));\n\n        //when\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n        //then\n        Assertions.assertThat(m.getAllValues()).containsExactly(\"a\", \"b\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 7618312406617949441L;\n    public Object answer(final InvocationOnMock invocation) throws Throwable;\n}\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n    public void misplacedArgumentMatcher(Location location);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 7618312406617949441L;\n    public Object answer(final InvocationOnMock invocation) throws Throwable;\n}\n/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n    public void misplacedArgumentMatcher(Location location);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>\tpublic void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\n\n        Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n\n        try {\n            smartNull.get();\n            fail();\n        } catch (SmartNullPointerException ex) {\n        \tString message = ex.getMessage();\n        \tassertTrue(\"Exception message should include oompa and lumpa, but was: \" + message, message.contains(\"oompa, lumpa\"));\n        }\n\t}\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 7618312406617949441L;\n    public Object answer(final InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Optional Answer that can be used with\n * {@link Mockito#mock(Class, Answer)}\n * <p>\n * This implementation can be helpful when working with legacy code. Unstubbed\n * methods often return null. If your code uses the object returned by an\n * unstubbed call you get a NullPointerException. This implementation of\n * Answer returns SmartNulls instead of nulls.\n * SmartNull gives nicer exception message than NPE because it points out the\n * line where unstubbed method was called. You just click on the stack trace.\n * <p>\n * ReturnsSmartNulls first tries to return ordinary return values (see\n * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the\n * return type is not mockable (e.g. final) then ordinary null is returned.\n * <p>\n * ReturnsSmartNulls will be probably the default return values strategy in\n * Mockito 2.0\n */\npublic class ReturnsSmartNulls implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 7618312406617949441L;\n    public Object answer(final InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldPrintTheParametersWhenCallingAMethodWithArgs() throws Throwable {\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\n\n    \tFoo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n\n    \tassertEquals(\"SmartNull returned by unstubbed withArgs(oompa, lumpa) method on mock\", smartNull + \"\");\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class SpyAnnotationEngine implements AnnotationEngine {\n    public Object createMockFor(Annotation annotation, Field field);\n    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class SpyAnnotationEngine implements AnnotationEngine {\n    public Object createMockFor(Annotation annotation, Field field);\n    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldPrintNiceName() {\n        //when\n        veryCoolSpy.add(1);\n\n        try {\n            verify(veryCoolSpy).add(2);\n            fail();\n        } catch(AssertionError e) {\n            Assertions.assertThat(e.getMessage()).contains(\"veryCoolSpy\");\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public boolean hasSameMethod(Invocation candidate);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public boolean hasSameMethod(Invocation candidate);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldStubbingWork() {\n        Mockito.when(iterable.iterator()).thenReturn(myIterator);\n        Assert.assertNotNull(((Iterable) iterable).iterator());\n        Assert.assertNotNull(iterable.iterator());\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n    public void captureArgumentsFrom(Invocation i);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    @Mock private IMethods mock; \n    @Test\n    public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n        //given\n        mock.varargs();\n        Invocation invocation = getLastInvocation();\n\n        //when\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n        //then\n        invocationMatcher.captureArgumentsFrom(invocation);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre>\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </pre>\n * \n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre>\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre>\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\npublic class Matchers {\n    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    /**\n     * generic friendly alias to {@link Matchers#anyCollection()}. \n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz);\n    public static <T> T isA(Class<T> clazz);\n    /**\n     * short argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value);\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre>\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre>\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </pre>\n * \n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre>\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre>\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\npublic class Matchers {\n    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    /**\n     * generic friendly alias to {@link Matchers#anyCollection()}. \n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.     \n     * <p>\n     * any Collection or null.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static <T> Collection<T> anyCollectionOf(Class<T> clazz);\n    public static <T> T isA(Class<T> clazz);\n    /**\n     * short argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     */\n    public static short eq(short value);\n    /**\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     */\n    public static <T> T refEq(T value, String... excludeFields);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldNotThrowNPEWhenIntPassed() {\n        mock.intArgumentMethod(100);\n        \n        verify(mock).intArgumentMethod(isA(Integer.class));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Method call on a mock object.\n * <p>\n * Contains sequence number which should be globally unique and is used for\n * verification in order.\n * <p>\n * Contains stack trace of invocation\n */\npublic class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n    private static final long serialVersionUID = 8240069639250980199L;\n    private static final int MAX_LINE_LENGTH = 45;\n    private final int sequenceNumber;\n    private final Object mock;\n    private final MockitoMethod method;\n    private final Object[] arguments;\n    private final Object[] rawArguments;\n    private final Location location;\n    private boolean verified;\n    private boolean verifiedInOrder;\n    public Object callRealMethod() throws Throwable;\n    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args);\n    public Object[] getRawArguments();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Method call on a mock object.\n * <p>\n * Contains sequence number which should be globally unique and is used for\n * verification in order.\n * <p>\n * Contains stack trace of invocation\n */\npublic class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n    private static final long serialVersionUID = 8240069639250980199L;\n    private static final int MAX_LINE_LENGTH = 45;\n    private final int sequenceNumber;\n    private final Object mock;\n    private final MockitoMethod method;\n    private final Object[] arguments;\n    private final Object[] rawArguments;\n    private final Location location;\n    private boolean verified;\n    private boolean verifiedInOrder;\n    public Object callRealMethod() throws Throwable;\n    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args);\n    public Object[] getRawArguments();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n        //given\n        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n\n        try {\n            //when\n            invocationOnInterface.callRealMethod();\n            //then\n            fail();\n        } catch(MockitoException e) {}\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class AnswersValidator {\n    private Reporter reporter = new Reporter();\n    public void validate(Answer<?> answer, Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class AnswersValidator {\n    private Reporter reporter = new Reporter();\n    public void validate(Answer<?> answer, Invocation invocation);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n        //given\n        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n        try {\n            //when\n            validator.validate(new CallsRealMethods(), inovcationOnIterface);\n            //then\n            fail();\n        } catch (MockitoException e) {}\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>public class ArgumentMatchingTool {\n    private boolean safelyMatches(Matcher m, Object arg);\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>public class ArgumentMatchingTool {\n    private boolean safelyMatches(Matcher m, Object arg);\n    /**\n     * Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different.\n     */\n    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldWorkFineWhenGivenArgIsNull() {\n        //when\n        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null});\n        \n        //then\n        assertEquals(0, suspicious.length);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n    public void cannotInjectDependency(Field field, Object matchingMock, Exception details);\n    public void noMoreInteractionsWantedInOrder(Invocation undesired);\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Reports verification and misusing errors.\n * <p>\n * One of the key points of mocking library is proper verification/exception\n * messages. All messages in one place makes it easier to tune and amend them.\n * <p>\n * Reporter can be injected and therefore is easily testable.\n * <p>\n * Generally, exception messages are full of line breaks to make them easy to\n * read (xunit plugins take only fraction of screen on modern IDEs).\n */\npublic class Reporter {\n    public void cannotInjectDependency(Field field, Object matchingMock, Exception details);\n    public void noMoreInteractionsWantedInOrder(Invocation undesired);\n    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private Field someField() {\n        return Mockito.class.getDeclaredFields()[0];\n    }\n    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {\n        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();\n        new Reporter().noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer);\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Verifies that another verification mode (the delegate) is satisfied within a certain timeframe\n * (before timeoutMillis has passed, measured from the call to verify()), and either returns immediately\n * once it does, or waits until it is definitely satisfied once the full time has passed.\n */\npublic class VerificationOverTimeImpl implements VerificationMode {\n    private final long pollingPeriodMillis;\n    private final long durationMillis;\n    private final VerificationMode delegate;\n    private final boolean returnOnSuccess;\n    private final Timer timer;\n    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Verifies that another verification mode (the delegate) is satisfied within a certain timeframe\n * (before timeoutMillis has passed, measured from the call to verify()), and either returns immediately\n * once it does, or waits until it is definitely satisfied once the full time has passed.\n */\npublic class VerificationOverTimeImpl implements VerificationMode {\n    private final long pollingPeriodMillis;\n    private final long durationMillis;\n    private final VerificationMode delegate;\n    private final boolean returnOnSuccess;\n    private final Timer timer;\n    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    private void checkDependency(ClassLoader classLoader_without_JUnit, String pureMockitoAPIClass) throws ClassNotFoundException {\n        try {\n            Class.forName(pureMockitoAPIClass, true, classLoader_without_JUnit);\n        } catch (Throwable e) {\n            throw new AssertionError(String.format(\"'%s' has some dependency to JUnit\", pureMockitoAPIClass), e);\n        }\n    }\n    public void pure_mockito_should_not_depend_JUnit() throws Exception {\n        ClassLoader classLoader_without_JUnit = ClassLoaders.excludingClassLoader()\n                .withCodeSourceUrlOf(\n                        Mockito.class,\n                        Matcher.class,\n                        Enhancer.class,\n                        Objenesis.class\n                )\n                .without(\"junit\", \"org.junit\")\n                .build();\n\n        Set<String> pureMockitoAPIClasses = ClassLoaders.in(classLoader_without_JUnit).omit(\"runners\", \"junit\", \"JUnit\").listOwnedClasses();\n\n        for (String pureMockitoAPIClass : pureMockitoAPIClasses) {\n            checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);\n        }\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre class=\"code\"><code class=\"java\">\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </code></pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </code></pre>\n * <p>\n * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n * Internally, they record a matcher on a stack and return a dummy value (usually null).\n * This implementation is due static type safety imposed by java compiler.\n * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n *\n * <p>\n * <b>Warning 2:</b>\n * <p>\n * The any family methods <b>*doesn't do any type checks*</b>, those are only here to avoid casting\n * in your code. If you want to perform type checks use the {@link #isA(Class)} method.\n * This <b>might</b> however change (type checks could be added) in a future major release.\n *\n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre class=\"code\"><code class=\"java\">\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </code></pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </code></pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\npublic class Matchers {\n    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n    /**\n     * Any <code>byte</code>, <code>Byte</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte();\n    /**\n     * Any <code>long</code>, <code>Long</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong();\n    public static <T> T any(Class<T> clazz);\n    /**\n     * Any <code>Map</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap();\n    /**\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection();\n    /**\n     * Any <code>char</code>, <code>Character</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar();\n    /**\n     * Generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the list to avoid casting\n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz);\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </code></pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg();\n    /**\n     * Any <code>Set</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet();\n    /**\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList();\n    /**\n     * Any object or <code>null</code>.\n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any();\n    /**\n     * Any <code>double</code>, <code>Double</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble();\n    /**\n     * Any <code>float</code>, <code>Float</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat();\n    /**\n     * Any int, Integer or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt();\n    /**\n     * Any <code>String</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString();\n    /**\n     * Any <code>short</code>, <code>Short</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort();\n    /**\n     * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean();\n    /**\n     * Generic friendly alias to {@link Matchers#anyMap()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Map</code> or <code>null</code>\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param keyClazz Type of the map key to avoid casting\n     * @param valueClazz Type of the value to avoid casting\n     * @return empty Map.\n     */\n    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz);\n    /**\n     * Generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Set</code> or <code>null</code>\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type owned by the Set to avoid casting\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n * <p>\n * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n * <pre class=\"code\"><code class=\"java\">\n *  //stubbing using anyInt() argument matcher\n *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n *  \n *  //following prints \"element\"\n *  System.out.println(mockedList.get(999));\n *  \n *  //you can also verify using argument matcher\n *  verify(mockedList).get(anyInt());\n * </code></pre>\n * Scroll down to see all methods - full list of matchers.\n * <p>\n * <b>Warning:</b>\n * <p>\n * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n * <p>\n * E.g: (example shows verification but the same applies to stubbing):\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n *   //above is correct - eq() is also an argument matcher\n *   \n *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n * </code></pre>\n * <p>\n * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n * Internally, they record a matcher on a stack and return a dummy value (usually null).\n * This implementation is due static type safety imposed by java compiler.\n * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n *\n * <p>\n * <b>Warning 2:</b>\n * <p>\n * The any family methods <b>*doesn't do any type checks*</b>, those are only here to avoid casting\n * in your code. If you want to perform type checks use the {@link #isA(Class)} method.\n * This <b>might</b> however change (type checks could be added) in a future major release.\n *\n * <h1>Custom Argument Matchers</h1>\n * \n * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n * <p>\n * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n * <p>\n * So, how to implement your own argument matcher?\n * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n * <p>\n * Example:\n * \n * <pre class=\"code\"><code class=\"java\">\n *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n *      public boolean matches(Object list) {\n *          return ((List) list).size() == 2;\n *      }\n *   }\n *   \n *   List mock = mock(List.class);\n *   \n *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n *   \n *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n *   \n *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n * </code></pre>\n * \n * To keep it readable you may want to extract method, e.g:\n * <pre class=\"code\"><code class=\"java\">\n *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n *   //becomes\n *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n * </code></pre>\n *\n * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n * Sometimes it's better to implement equals() for arguments that are passed to mocks \n * (Mockito naturally uses equals() for argument matching). \n * This can make the test cleaner. \n * <p>\n * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n * For example, if custom argument matcher is not likely to be reused\n * or you just need it to assert on argument values to complete verification of behavior.\n */\npublic class Matchers {\n    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n    /**\n     * Any <code>byte</code>, <code>Byte</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static byte anyByte();\n    /**\n     * Any <code>long</code>, <code>Long</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static long anyLong();\n    public static <T> T any(Class<T> clazz);\n    /**\n     * Any <code>Map</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     */\n    public static Map anyMap();\n    /**\n     * Any <code>Collection</code> or <code>null</code>.\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     */\n    public static Collection anyCollection();\n    /**\n     * Any <code>char</code>, <code>Character</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static char anyChar();\n    /**\n     * Generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the list to avoid casting\n     * @return empty List.\n     */\n    public static <T> List<T> anyListOf(Class<T> clazz);\n    /**\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </code></pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     */\n    public static <T> T anyVararg();\n    /**\n     * Any <code>Set</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     */\n    public static Set anySet();\n    /**\n     * Any <code>List</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     */\n    public static List anyList();\n    /**\n     * Any object or <code>null</code>.\n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     */\n    public static <T> T any();\n    /**\n     * Any <code>double</code>, <code>Double</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static double anyDouble();\n    /**\n     * Any <code>float</code>, <code>Float</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static float anyFloat();\n    /**\n     * Any int, Integer or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static int anyInt();\n    /**\n     * Any <code>String</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     */\n    public static String anyString();\n    /**\n     * Any <code>short</code>, <code>Short</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     */\n    public static short anyShort();\n    /**\n     * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     */\n    public static boolean anyBoolean();\n    /**\n     * Generic friendly alias to {@link Matchers#anyMap()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Map</code> or <code>null</code>\n     * <p>\n     * This method <b>*doesn't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param keyClazz Type of the map key to avoid casting\n     * @param valueClazz Type of the value to avoid casting\n     * @return empty Map.\n     */\n    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz);\n    /**\n     * Generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any <code>Set</code> or <code>null</code>\n     * <p>\n     * This method <b>*dones't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type owned by the Set to avoid casting\n     * @return empty Set\n     */\n    public static <T> Set<T> anySetOf(Class<T> clazz);\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers() {\n        when(mock.forInteger(anyInt())).thenReturn(\"0\");\n        when(mock.forCharacter(anyChar())).thenReturn(\"1\");\n        when(mock.forShort(anyShort())).thenReturn(\"2\");\n        when(mock.forByte(anyByte())).thenReturn(\"3\");\n        when(mock.forBoolean(anyBoolean())).thenReturn(\"4\");\n        when(mock.forLong(anyLong())).thenReturn(\"5\");\n        when(mock.forFloat(anyFloat())).thenReturn(\"6\");\n        when(mock.forDouble(anyDouble())).thenReturn(\"7\");\n        \n        assertEquals(null, mock.forInteger(null));\n        assertEquals(null, mock.forCharacter(null));\n        assertEquals(null, mock.forShort(null));\n        assertEquals(null, mock.forByte(null));\n        assertEquals(null, mock.forBoolean(null));\n        assertEquals(null, mock.forLong(null));\n        assertEquals(null, mock.forFloat(null));\n        assertEquals(null, mock.forDouble(null));\n    }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * This class can retrieve generic meta-data that the compiler stores on classes\n * and accessible members.\n *\n * <p>\n *     The main idea of this code is to create a Map that will help to resolve return types.\n *     In order to actually work with nested generics, this map will have to be passed along new instances\n *     as a type context.\n * </p>\n *\n * <p>\n *     Hence :\n *     <ul>\n *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real\n *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>\n *\n *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n *         {@link #resolveGenericReturnType(Method)}.</li>\n *     </ul>\n * </p>\n *\n * <p>\n * For now this code support the following kind of generic declarations :\n * <pre class=\"code\"><code class=\"java\">\n * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n *     K returningK();\n *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n *     &lt;S, T extends S&gt; T two_type_params();\n *     &lt;O extends K&gt; O typeVar_with_type_params();\n *     Number returningNonGeneric();\n * }\n * </code></pre>\n *\n * @see #inferFrom(Type)\n * @see #resolveGenericReturnType(Method)\n * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n */\npublic abstract class GenericMetadataSupport {\n    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>  public void discoverDeepMockingOfGenerics() {\n    MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\n    when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n  }\n<|endoftext|>"
  },
  {
    "input": "",
    "instruction": "<fim_prefix>/**\n * Optional Answer that adds partial mocking support\n * <p>\n * {@link Answer} can be used to define the return values of unstubbed invocations.\n * <p>\n * This implementation can be helpful when working with legacy code.\n * When this implementation is used, unstubbed methods will delegate to the real implementation.\n * This is a way to create a partial mock object that calls real methods by default.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n */\npublic class CallsRealMethods implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 9057165148930624087L;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>",
    "output": "<fim_prefix>/**\n * Optional Answer that adds partial mocking support\n * <p>\n * {@link Answer} can be used to define the return values of unstubbed invocations.\n * <p>\n * This implementation can be helpful when working with legacy code.\n * When this implementation is used, unstubbed methods will delegate to the real implementation.\n * This is a way to create a partial mock object that calls real methods by default.\n * <p>\n * As usual you are going to read <b>the partial mock warning</b>:\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n * How does partial mock fit into this paradigm? Well, it just doesn't... \n * Partial mock usually means that the complexity has been moved to a different method on the same object.\n * In most cases, this is not the way you want to design your application.\n * <p>\n * However, there are rare cases when partial mocks come handy: \n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n * <p>\n */\npublic class CallsRealMethods implements Answer<Object>, Serializable {\n    private static final long serialVersionUID = 9057165148930624087L;\n    public Object answer(InvocationOnMock invocation) throws Throwable;\n}\n\npublic class Test { \n    <fim_suffix>\n}\n<fim_middle>    public void abstractMethodStubbed() {\n    \tAbstractThing thing = spy(AbstractThing.class);\n    \twhen(thing.name()).thenReturn(\"me\");\n    \tassertEquals(\"abstract me\", thing.fullName());\n    }\n<|endoftext|>"
  }
]